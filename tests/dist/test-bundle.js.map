{"version":3,"file":"test-bundle.js","mappings":";;;;;;;;;;;;;AAAwC;;AAEjC;AACP,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ,gCAAgC,mBAAmB;AACnE;AACA;AACA;AACA;AACA,gBAAgB,gDAAQ;AACxB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,UAAU;AACV,YAAY,gDAAQ;AACpB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,gDAAQ;;AAEhB;AACA;AACA;AACA,YAAY,gDAAQ,qBAAqB,MAAM,MAAM,4BAA4B;AACjF;AACA,wDAAwD,gDAAgD;AACxG,oCAAoC,MAAM;AAC1C,sBAAsB;AACtB;AACA;AACA,SAAS;;AAET,kFAAkF,gBAAgB;;AAElG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sCAAsC;AAClF,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/PA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,yDAAyD;AACzD;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEgC;AACU;AACO;AACmB;AACZ;AACnB;AACO;AACK;;AAEjD,gDAAQ;;AAER;AACA;AACA,4CAA4C,yBAAyB;AACrE,wBAAwB,uDAAU;AAClC,2BAA2B,2DAAa;AACxC,sBAAsB,oDAAQ;AAC9B,qBAAqB,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,yCAAyC;AACzC,2CAA2C;AAC3C,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAQ;AACpB,WAAW;AACX;AACA;;AAEA;AACA,MAAM,gDAAQ;AACd;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA,MAAM,gDAAQ,iDAAiD,aAAa;AAC5E;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,kDAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ,gDAAQ;AAChB,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,UAAU;AACjB;;AAEA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD,OAAO;AACP;;AAEA;AACA,MAAM,gDAAQ;AACd;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD,YAAY;AACZ;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY,UAAU,UAAU;AAC3C,WAAW,YAAY;;AAEvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B,0DAAY;AAC1C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB;AAC9E,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,OAAO;;AAEP,MAAM,gDAAQ,yCAAyC,4BAA4B;AACnF;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAQ;AACpB,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,gDAAQ;AAClB;AACA;AACA,YAAY,gDAAQ,0BAA0B,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ,YAAY,gDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,gDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,gDAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,oBAAoB;AACtC,2CAA2C,UAAU;AACrD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,gDAAQ;AAClB;AACA;;AAEA;AACA;AACA,UAAU,gDAAQ;AAClB;AACA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;;AAEA;AACA;AACA,YAAY,gDAAQ;AACpB,YAAY;AACZ,YAAY,gDAAQ;AACpB;AACA,YAAY;AACZ,YAAY,gDAAQ;AACpB;;AAEA;AACA;AACA;AACA,UAAU,gDAAQ;;AAElB;AACA;AACA,UAAU,gDAAQ;;AAElB;AACA;AACA;AACA;AACA;AACA,cAAc,gDAAQ;AACtB;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,gDAAQ;AACtB;AACA;AACA,yCAAyC,oBAAoB;;AAE7D;AACA,sEAAsE,UAAU,GAAG,QAAQ;AAC3F;AACA;AACA,gBAAgB,gDAAQ;AACxB;AACA;AACA,cAAc;AACd,cAAc,gDAAQ;AACtB;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,gDAAQ;AAClB;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO,UAAU;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,WAAW;AACX;AACA;AACA;AACA,QAAQ;AACR,QAAQ,gDAAQ;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ,gDAAQ;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAQ;AAChB,QAAQ;AACR,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,gDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,gDAAQ;AACd;AACA;;AAEA,MAAM,gDAAQ,oCAAoC,6BAA6B;AAC/E;AACA;AACA,QAAQ,gDAAQ;AAChB;AACA,QAAQ;AACR,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAQ;AAChB;AACA,4BAA4B,0CAAM;AAClC;AACA,QAAQ,gDAAQ;AAChB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,8FAA8F,WAAW;AACzG,UAAU,gDAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;;AAEX;AACA;AACA;;AAEA,QAAQ,gDAAQ;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA,MAAM,gDAAQ;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,eAAe,sDAAc;AAC7B,eAAe,4EAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4EAAkB,iEAAiE,SAAS;AACzH,UAAU,gDAAQ;AAClB;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gDAAQ;AACd,MAAM,gDAAQ;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,8DAA8D,UAAU;AACxE;AACA;;AAEA;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,sDAAc;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,UAAU,gDAAQ;AAClB;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA,MAAM,gDAAQ;AACd;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB,QAAQ;AACzB,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA,sBAAsB,sBAAsB,cAAc;AAC1D;AACA,iCAAiC,YAAY;AAC7C,uCAAuC,YAAY;AACnD,uCAAuC,YAAY;AACnD;AACA,wCAAwC,0BAA0B;AAClE,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,MAAM,gDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAQ,kCAAkC,kBAAkB;AACxE;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAQ,yCAAyC,4BAA4B;AACzF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,YAAY;AACZ,YAAY,gDAAQ;AACpB;AACA,SAAS;AACT;AACA,MAAM,gDAAQ;AACd;;AAEA;AACA,MAAM,gDAAQ;AACd;AACA;AACA;AACA;AACA,wEAAwE,SAAS;AACjF;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA,wFAAwF,SAAS;AACjG;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8EAA8E,eAAe;AAC7F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE,kDAAkD,YAAY,IAAI,MAAM;AACxE;AACA;AACA,8DAA8D,kBAAkB;AAChF;AACA;AACA,UAAU;AACV;AACA;AACA,gDAAgD,gBAAgB;AAChE,kDAAkD,kBAAkB;AACpE;AACA;AACA,8DAA8D,kBAAkB;AAChF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAiD,EAAE,SAAS;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,kBAAkB;AACnF,kBAAkB;AAClB;AACA,cAAc;AACd;AACA,mEAAmE,gBAAgB;AACnF,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,UAAU,iBAAiB,OAAO;AAC1F,iDAAiD,UAAU;AAC3D,wDAAwD,iBAAiB;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,gDAAQ;AACd;AACA;AACA,oEAAoE,gBAAgB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D,iBAAiB,IAAI,mDAAmD;AACrI;;AAEA;AACA,MAAM,gDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,cAAc,gDAAQ,8CAA8C,UAAU;AAC9E;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM,gDAAQ;AACd,MAAM,gDAAQ;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,WAAW,GAAG,cAAc;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,gDAAQ;;AAEd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA,YAAY,gDAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,0CAA0C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB,QAAQ;AACzB,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,UAAU,wDAA0C;;AAEzB;AAC3B;AACA;;;;;;;;;;;;;;;;ACt6DwC;AACH;;AAErC;AACA;AACA;AACA,qCAAqC;AACrC,oCAAoC;AACpC,sCAAsC;AACtC;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,YAAY,gDAAQ;AACpB,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,gDAAQ;AACxB,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA,QAAQ,gDAAQ,mCAAmC,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,oDAAQ;AACpB;AACA;AACA;AACA,aAAa;AACb,kBAAkB,oDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,gDAAQ,wCAAwC,UAAU;AACtE;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB,0CAA0C,oDAAQ;AAClD;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd,gBAAgB,gDAAQ,oDAAoD,UAAU;AACtF;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ,qCAAqC,UAAU;AAC/D;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;;AAEA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,gBAAgB,gDAAQ,4BAA4B,SAAS,yBAAyB,UAAU;AAChG;AACA;AACA,oBAAoB,gDAAQ,sBAAsB,WAAW;AAC7D;AACA;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ,2CAA2C,WAAW,QAAQ,YAAY;AAC1F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;;AAEA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA,+CAA+C,qCAAqC;AACpF;AACA,aAAa;;AAEb;AACA,0DAA0D,oBAAoB;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU,GAAG,aAAa;AAClE,aAAa;;AAEb;AACA,UAAU;AACV,YAAY,gDAAQ,sCAAsC,UAAU;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,UAAU,GAAG,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA,2DAA2D,qCAAqC;AAChG,6BAA6B;AAC7B,mDAAmD,OAAO;AAC1D,yBAAyB;AACzB;AACA;AACA;AACA,qCAAqC;AACrC;AACA,sBAAsB;AACtB,wBAAwB,gDAAQ,uCAAuC,UAAU;AACjF;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA,2DAA2D,qCAAqC;AAChG,6BAA6B;AAC7B,mDAAmD,mBAAmB;AACtE,yBAAyB;AACzB;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA,sBAAsB;AACtB,wBAAwB,gDAAQ,8CAA8C,UAAU;AACxF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,QAAQ,gDAAQ,0CAA0C,UAAU,EAAE,4CAA4C;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oDAAQ;AAC5B,0BAA0B,oDAAQ;AAClC;;AAEA;AACA,cAAc;AACd,gBAAgB,gDAAQ,+CAA+C,UAAU;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;;AAEA;AACA;;AAEA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA,+CAA+C,qCAAqC;AACpF,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA,oDAAoD,oBAAoB;AACxE;;AAEA;AACA,UAAU;AACV;AACA,gBAAgB,gDAAQ,4CAA4C,QAAQ,QAAQ,yBAAyB;AAC7G,gEAAgE,aAAa;AAC7E;AACA,YAAY,gDAAQ,qCAAqC,aAAa;AACtE;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,QAAQ,gDAAQ,gBAAgB,iBAAiB;AACjD,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA,YAAY,gDAAQ,yBAAyB,SAAS;AACtD;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA,oBAAoB,gDAAQ;AAC5B,kBAAkB;AAClB,oBAAoB,gDAAQ;AAC5B;AACA,aAAa;AACb;AACA,gBAAgB,gDAAQ;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,oBAAoB,gDAAQ,sCAAsC,aAAa;AAC/E;AACA;AACA,cAAc;AACd,gBAAgB,gDAAQ;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,gDAAQ,0CAA0C,aAAa;AACnF;AACA;AACA,cAAc;AACd,gBAAgB,gDAAQ;AACxB;AACA;;AAEA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;AACA,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAQ,gBAAgB,8BAA8B;AAC9D,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,gDAAQ;AAC5B;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB,gDAAQ,mCAAmC,aAAa;AAC5E;AACA,aAAa;AACb;AACA,QAAQ,gDAAQ,iCAAiC,gBAAgB;AACjE,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,GAAG;AACvD;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA,+CAA+C,qCAAqC;AACpF,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA,wDAAwD,oBAAoB;AAC5E;;AAEA;AACA;AACA,UAAU;AACV;AACA,gBAAgB,gDAAQ,8DAA8D,UAAU;AAChG,cAAc;AACd,gBAAgB,gDAAQ,8CAA8C,UAAU;AAChF;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;;AAEA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAQ,yCAAyC,UAAU;AACnF,2EAA2E;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAe,aAAa,EAAC;;;;;;;;;;;;;;;;ACtkB7B;AACA;AACA;AACA;;AAE0D;;AAEnD;AACP;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA,0CAA0C;AAC1C;AACA,wCAAwC;AACxC,uBAAuB,wDAAgB,EAAE;AACzC,4CAA4C;AAC5C,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,wDAAgB;AACjE;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA,YAAY,gDAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV,YAAY,gDAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;;AAEA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,gCAAgC,gDAAQ;AACxC;AACA;AACA,+CAA+C;AAC/C,iCAAiC;AACjC;AACA,0BAA0B;AAC1B,4BAA4B,gDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,gDAAQ,oDAAoD,UAAU;AAC1F;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA,qBAAqB;AACrB;AACA,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY,gDAAQ;AACpB,UAAU;AACV,YAAY,gDAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yBAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,oEAAoE,SAAS;AAC7E,4EAA4E,OAAO;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yBAAyB;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,oEAAoE,UAAU;AAC9E,oEAAoE,gBAAgB;AACpF;AACA;AACA,8CAA8C,2DAA2D,mBAAmB;AAC5H;AACA;AACA;AACA;AACA,kEAAkE,gCAAgC,IAAI,gCAAgC;AACtI;AACA;AACA;AACA,uFAAuF,yDAAyD;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,oEAAoE,IAAI;AACxE;AACA;AACA,8CAA8C,0CAA0C,mBAAmB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA,oEAAoE,IAAI;AACxE;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,gBAAgB,gDAAQ;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,4BAA4B,gDAAQ;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qFAAqF,mBAAmB,8CAA8C,mBAAmB;AACzK;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8EAA8E,iBAAiB;AAC/F;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gDAAQ;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,gDAAQ;AACxB,gBAAgB,gDAAQ;;AAExB;AACA;;AAEA,gBAAgB,gDAAQ;AACxB,gBAAgB,gDAAQ;;AAExB;AACA;AACA,aAAa;AACb;AACA,gBAAgB,gDAAQ;AACxB,aAAa;AACb;AACA,gBAAgB,gDAAQ;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA,QAAQ,gDAAQ,mCAAmC,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,YAAY,gDAAQ,wCAAwC,UAAU;AACtE;AACA;AACA;;AAEA;AACA;AACA,QAAQ,gDAAQ,gCAAgC,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA,aAAa;AACb;AACA;AACA;AACA,UAAU;AACV,YAAY,gDAAQ,qCAAqC,UAAU;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,iEAAe,cAAc,EAAC;;;;;;;;;;;;;;;ACx6BmC;;AAEjE;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,QAAQ,gDAAQ,gBAAgB,iBAAiB;AACjD,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA,YAAY,gDAAQ,yBAAyB,SAAS;AACtD;AACA;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAQ;AAC5B,kBAAkB;AAClB,oBAAoB,gDAAQ;AAC5B;AACA,aAAa;AACb;AACA,gBAAgB,gDAAQ;AACxB,aAAa;AACb;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,gDAAQ;AACpC;AACA;AACA;AACA,gCAAgC,gDAAQ;AACxC;AACA,8BAA8B;AAC9B,gCAAgC,gDAAQ;AACxC;AACA;;AAEA,0BAA0B;AAC1B,4BAA4B,gDAAQ;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,iBAAiB;AACjB;AACA,gBAAgB,gDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAQ,sCAAsC,aAAa;AAC/E;AACA,oBAAoB,gDAAQ;AAC5B;AACA,cAAc;AACd,gBAAgB,gDAAQ;AACxB;AACA;;AAEA;AACA,YAAY,gDAAQ;AACpB;AACA;AACA,QAAQ,gDAAQ;AAChB,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAQ,gBAAgB,8BAA8B;AAC9D,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,gDAAQ;AAC5B;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB,gDAAQ,mCAAmC,aAAa;AAC5E;AACA,aAAa;AACb;AACA,QAAQ,gDAAQ,iCAAiC,gBAAgB;AACjE,QAAQ,gDAAQ;AAChB;AACA;;;AAGA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA,oBAAoB,gDAAQ,6CAA6C,0BAA0B;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAQ;AAChB;AACA;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA,QAAQ,gDAAQ;AAChB;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,sCAAsC,KAAK;AAC3C,sCAAsC,WAAW;AACjD,sCAAsC,oDAAoD;AAC1F,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,gDAAQ;;AAEhB;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD,+CAA+C,OAAO,IAAI,WAAW;AACrE;AACA,kBAAkB,oDAAoD,iBAAiB;AACvF,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA,uDAAuD,mEAAmE;AAC1H;AACA;AACA,kBAAkB,6CAA6C,iBAAiB;AAChF,kBAAkB;AAClB;AACA;AACA,4DAA4D,yEAAyE;AACrI;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA,mDAAmD,OAAO;AAC1D;AACA,wDAAwD,SAAS;AACjE,0BAA0B;AAC1B,qDAAqD,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA,8EAA8E,4DAA4D;AAC1I;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,gDAAQ;AAChB,QAAQ,gDAAQ;AAChB,iBAAiB;AACjB;;AAEA;AACA,QAAQ,gDAAQ;AAChB;AACA;AACA;AACA;AACA,iEAAe,UAAU;;;;;;;;;;;;;;;;;ACpUzB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C,KAAK;AACL;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5DA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,QAAQ;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,mBAAmB,gBAAgB;AACnC,gBAAgB;AAChB,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,qCAAqC,sDAAsD;AAC3F,yBAAyB;AACzB,qCAAqC,oDAAoD;AACzF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,QAAQ;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;;;;;;;;;;;;;;;;AC5lBxB;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,yBAAyB;AAC7C;AACA,8EAA8E,0BAA0B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,yBAAyB;AACzB,cAAc;AACd,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,2CAA2C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA,qBAAqB;AACrB;;AAEA,yBAAyB;AACzB,cAAc;AACd,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,0DAA0D;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;AACA,6BAA6B;AAC7B;;AAEA,yBAAyB;AACzB,cAAc;AACd,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,cAAc;AACd,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,2FAA2F;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA,cAAc,kBAAkB,IAAI,UAAU,gBAAgB,kBAAkB,IAAI;AACpF;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA,yBAAyB;AACzB,cAAc;AACd,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qGAAqG;AACrG;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,oCAAoC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,gDAAgD;AACpE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC,6DAA6D;AACpG;AACA,0CAA0C,EAAE,IAAI,EAAE,IAAI,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,oFAAoF;AACpF,oEAAoE;AACpE,oEAAoE;AACpE;AACA;AACA;;AAEA,0CAA0C,oBAAoB,IAAI,oBAAoB,KAAK,oBAAoB;AAC/G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA,yBAAyB;AACzB,cAAc;AACd,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yCAAyC,QAAQ,4BAA4B,SAAS;AACtF;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kFAAkF,YAAY;AAC9F;;AAEA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;;AAEA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtvBA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qBAAqB;AACrB;AACA,kCAAkC;AAClC,qBAAqB;AACrB;AACA;AACA,qEAAqE,2BAA2B;AAChG;AACA;;AAEA;AACA,6CAA6C,UAAU,GAAG,KAAK;AAC/D;AACA;;AAEA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU,GAAG,KAAK;AAC1E;AACA;AACA;AACA,wEAAwE,YAAY;AACpF;AACA;AACA,oCAAoC,kBAAkB;AACtD;;AAEA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU,GAAG,KAAK,WAAW,OAAO,SAAS,MAAM;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;ACrK1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8FAA8F,QAAQ;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,cAAc;AACpG,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;ACtF3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,wDAAwD,cAAc;AACtE;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,wDAAwD,cAAc;AACtE;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D,qCAAqC,uBAAuB;AAC5D;AACA;AACA,oDAAoD,sBAAsB;AAC1E,oDAAoD,sBAAsB;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA,qBAAqB;AACrB;;AAEA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,YAAY;AACzE;;AAEA;AACA;AACA,yCAAyC,eAAe;AACxD,sBAAsB,cAAc;AACpC;;AAEA,yBAAyB,gCAAgC,gBAAgB,oBAAoB,YAAY;AACzG,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;AC3MrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA,gDAAgD,kBAAkB;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;AC5H3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,4CAA4C,sBAAsB;AAClE,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qBAAqB,gBAAgB,sBAAsB,kBAAkB,cAAc,gBAAgB,gBAAgB;AACvK;AACA;AACA;AACA,oDAAoD,8DAA8D;AAClH;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yCAAyC,8BAA8B;AACvE,oBAAoB,iBAAiB;AACrC;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA,aAAa;AACb,gDAAgD,gCAAgC;AAChF;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA,oCAAoC,4IAA4I;AAChL;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,qBAAqB,yBAAyB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,sCAAsC;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,qCAAqC;AAC/E;AACA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD,+DAA+D,sBAAsB,GAAG,mBAAmB,cAAc,oBAAoB,KAAK,aAAa;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iDAAiD,2CAA2C;AAC5F,0BAA0B;AAC1B,wEAAwE,cAAc,IAAI,oBAAoB;AAC9G;AACA,sBAAsB;AACtB;AACA,oEAAoE,cAAc,IAAI,oBAAoB;AAC1G;AACA;AACA;AACA;AACA,sDAAsD,6CAA6C;AACnG;AACA;AACA;AACA;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;AACA,+BAA+B,wBAAwB;AACvD,8DAA8D,qBAAqB,GAAG,wBAAwB,cAAc,yBAAyB,KAAK,aAAa;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iDAAiD,yCAAyC;AAC1F,0BAA0B;AAC1B,uEAAuE,aAAa;AACpF;AACA,sBAAsB;AACtB;AACA,mEAAmE,aAAa;AAChF;AACA;AACA;AACA;AACA,qDAAqD,6CAA6C;AAClG;AACA;AACA;AACA;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;AACA,+BAA+B,wBAAwB;AACvD,8DAA8D,4BAA4B,GAAG,wBAAwB,cAAc,yBAAyB,KAAK,aAAa;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iDAAiD,oDAAoD;AACrG,0BAA0B;AAC1B,uEAAuE,aAAa;AACpF;AACA,sBAAsB;AACtB;AACA,mEAAmE,aAAa;AAChF;AACA;AACA;AACA;AACA,qDAAqD,oDAAoD;AACzG;AACA;AACA;AACA;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;AACA,+BAA+B,2BAA2B;AAC1D,iEAAiE,+BAA+B,GAAG,2BAA2B,cAAc,4BAA4B,KAAK,aAAa;AAC1L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iDAAiD,0DAA0D;AAC3G,0BAA0B;AAC1B,0EAA0E,aAAa;AACvF;AACA,sBAAsB;AACtB;AACA,sEAAsE,aAAa;AACnF;AACA;AACA;AACA;AACA,wDAAwD,oDAAoD;AAC5G;AACA;AACA;AACA;;;AAGA,2BAA2B,sBAAsB;AACjD;AACA;AACA,+BAA+B,4BAA4B;AAC3D,kEAAkE,yBAAyB,GAAG,4BAA4B,cAAc,6BAA6B,KAAK,aAAa;AACvL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,kBAAkB;AACpH;AACA;AACA,iDAAiD,iDAAiD;AAClG,0BAA0B;AAC1B,2EAA2E,aAAa;AACxF;AACA,sBAAsB;AACtB;AACA,uEAAuE,aAAa;AACpF;AACA;AACA;AACA;AACA,yDAAyD,6CAA6C;AACtG;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,oBAAoB,iDAAiD;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iBAAiB,2BAA2B,MAAM,IAAI,OAAO;AAClI,iCAAiC,mDAAmD,iBAAiB,gBAAgB,yBAAyB,MAAM,IAAI,OAAO,IAAI;AACnK;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,qCAAqC;AACrC,0BAA0B;AAC1B;AACA,qCAAqC;AACrC;AACA,sBAAsB;AACtB,iCAAiC,kEAAkE,UAAU;AAC7G;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC,sBAAsB;AACtB;AACA,iCAAiC;AACjC;AACA;;AAEA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yCAAyC;AACzC,8BAA8B;AAC9B;AACA,kEAAkE;AAClE,yCAAyC;AACzC;AACA,0BAA0B;AAC1B;AACA,4DAA4D;AAC5D;AACA,qCAAqC;AACrC;AACA,sBAAsB;AACtB,iCAAiC,oEAAoE,UAAU;AAC/G;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qCAAqC;AACrC,0BAA0B;AAC1B;AACA,8DAA8D;AAC9D,qCAAqC;AACrC;AACA,sBAAsB;AACtB;AACA,wDAAwD;AACxD;AACA,iCAAiC;AACjC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yCAAyC;AACzC,8BAA8B;AAC9B,yCAAyC;AACzC;AACA,0BAA0B;AAC1B;AACA,qCAAqC;AACrC;AACA,sBAAsB;AACtB,iCAAiC,gEAAgE,UAAU;AAC3G;AACA,kBAAkB;AAClB;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qCAAqC;AACrC,0BAA0B;AAC1B,qCAAqC;AACrC;AACA,sBAAsB;AACtB;AACA,iCAAiC;AACjC;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yCAAyC;AACzC,8BAA8B;AAC9B,yCAAyC;AACzC;AACA,0BAA0B;AAC1B;AACA,qCAAqC;AACrC;AACA,sBAAsB;AACtB,iCAAiC,gEAAgE,UAAU;AAC3G;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qCAAqC;AACrC,0BAA0B;AAC1B,qCAAqC;AACrC;AACA,sBAAsB;AACtB;AACA,iCAAiC;AACjC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yCAAyC;AACzC,8BAA8B;AAC9B,yCAAyC;AACzC;AACA,0BAA0B;AAC1B;AACA,qCAAqC;AACrC;AACA,sBAAsB;AACtB,iCAAiC,kEAAkE,UAAU;AAC7G;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qCAAqC;AACrC,0BAA0B;AAC1B,qCAAqC;AACrC;AACA,sBAAsB;AACtB;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,qBAAqB,qDAAqD,KAAK;AAC/E;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ,GAAG,cAAc,GAAG,iBAAiB;AACrH,kBAAkB;AAClB;AACA;AACA,sEAAsE,cAAc,GAAG,iBAAiB;AACxG;;AAEA,yBAAyB,+BAA+B,YAAY;AACpE,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,qBAAqB,kCAAkC,WAAW;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qBAAqB,+BAA+B,cAAc;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,iBAAiB;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E,eAAe,GAAG,YAAY,GAAG,cAAc;AAC5H,kBAAkB;AAClB;AACA,6EAA6E,eAAe,GAAG,YAAY;AAC3G;AACA;AACA,yBAAyB,gCAAgC,cAAc,SAAS,gBAAgB;AAChG,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,aAAa,YAAY,iBAAiB,IAAI,cAAc,WAAW,cAAc,MAAM,iBAAiB;AACzJ;AACA;;AAEA;AACA,qBAAqB,iDAAiD,QAAQ;AAC9E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD,kDAAkD,uEAAuE;AACzH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB;AACzB;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,0CAA0C,iBAAiB;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,2CAA2C,8BAA8B,IAAI,uCAAuC,oBAAoB,UAAU;AACvK;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe;AACxD;AACA,6CAA6C,sBAAsB;AACnE,iBAAiB;;AAEjB,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA,wBAAwB;;;;;;;;;;;;;;;;AC5sDxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,0EAA0E,aAAa;AACvF,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+CAA+C,sCAAsC;AACrF,kBAAkB;AAClB,+CAA+C,kCAAkC;AACjF;;AAEA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,yEAAyE,cAAc;AACvF,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,kBAAkB;AACtD;;AAEA;AACA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;ACtLnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;AC3G9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE,iBAAiB;;AAEjB,yBAAyB;AACzB,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,cAAc,EAAE,4CAA4C;AAC1G;AACA,cAAc;AACd;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEuB;;;;;;;;;;AC3LvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BO;AACP;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpDA;AACsF;;AAEtF;AACA;;AAEO;AACP;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qCAAqC;AACrC,wCAAwC;AACxC;AACA,qBAAqB;AACrB,yCAAyC;AACzC;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,0CAA0C;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,2FAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yCAAyC;AACzC,4CAA4C;AAC5C;AACA,yBAAyB;AACzB,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sCAAsC,oBAAoB;AAC1D,yCAAyC,mBAAmB;AAC5D;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,2FAAe;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC,0BAA0B;AAC1B,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yCAAyC;AACzC,4CAA4C;AAC5C;AACA,yBAAyB;AACzB,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sCAAsC,oBAAoB;AAC1D,yCAAyC,mBAAmB;AAC5D;AACA;AACA,yBAAyB;AACzB;AACA,oCAAoC,cAAc;AAClD;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,2FAAe;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,iBAAiB;AACjB;AACA;AACA,6CAA6C,aAAa;AAC1D,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA,4CAA4C,4BAA4B;AACxE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC,0BAA0B;AAC1B,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;;;;;;;;;;;;AC3WO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpDO;AACP;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9EO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,IAAI,GAAG,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B,kCAAkC,IAAI;AACtC,kCAAkC,IAAI;AACtC;AACA,4BAA4B,IAAI,MAAM,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,GAAG,EAAE;AACrC;AACA;AACA,yCAAyC,IAAI,kBAAkB,IAAI,MAAM;AACzE,4CAA4C,IAAI,kBAAkB,IAAI,MAAM;AAC5E,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,IAAI,EAAE,KAAK;AACxD,gDAAgD,IAAI,yBAAyB,aAAa,IAAI;AAC9F,wCAAwC,IAAI,yBAAyB,SAAS,GAAG,SAAS,GAAG,WAAW,GAAG;AAC3G,iDAAiD,IAAI,yBAAyB;AAC9E,kDAAkD,IAAI,yBAAyB;AAC/E,+CAA+C,IAAI,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA,0BAA0B,EAAE,GAAG,IAAI;AACnC,mBAAmB,IAAI,GAAG,GAAG,sBAAsB,GAAG,6CAA6C,IAAI;AACvG,eAAe,IAAI,aAAa,GAAG,aAAa,GAAG,cAAc,GAAG;AACpE,oBAAoB,IAAI,GAAG,IAAI;AAC/B,4BAA4B,IAAI;AAChC,mJAAmJ,IAAI;AACvJ;AACA,iCAAiC,EAAE,GAAG,IAAI;AAC1C,2BAA2B,IAAI,KAAK,GAAG,GAAG,GAAG;AAC7C,+BAA+B,IAAI;AACnC,4BAA4B,IAAI,EAAE,IAAI;AACtC,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI,EAAE,IAAI;AACrC;AACA;AACA,8BAA8B,IAAI;AAClC,0BAA0B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC3D,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA,2BAA2B,IAAI,EAAE,IAAI;AACrC,8BAA8B,IAAI;AAClC,2BAA2B,EAAE,GAAG,IAAI;AACpC,0BAA0B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC3D,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,EAAE,IAAI;AACzC;AACA;AACA,kCAAkC,IAAI;AACtC,8BAA8B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC/D,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,GAAG;AAC9C,oEAAoE,GAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI;AACtB;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe,EAAE;AAC1D;AACA,gBAAgB,GAAG;AACnB,sCAAsC,GAAG,8CAA8C,GAAG;AAC1F;AACA,0BAA0B,EAAE,GAAG,EAAE;AACjC,mCAAmC,EAAE,GAAG,EAAE;AAC1C,uCAAuC,EAAE,GAAG,EAAE;AAC9C;AACA;AACA;AACA,0CAA0C,EAAE,GAAG,EAAE;AACjD,mDAAmD,EAAE,GAAG,EAAE;AAC1D,qDAAqD,EAAE,GAAG,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD,iDAAiD,EAAE,kCAAkC,KAAK,6CAA6C,KAAK;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC,UAAU;AAC5E;AACA,iCAAiC,GAAG,iCAAiC,GAAG,6EAA6E,GAAG,+BAA+B,GAAG,gCAAgC,GAAG;AAC7N;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA,iCAAiC,GAAG;AACpC,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,IAAI,WAAW;AAClD,iCAAiC,KAAK,IAAI,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,IAAI,IAAI,eAAe,SAAS,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,sDAAsD;AACtD;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mIAAmI;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,EAAE,GAAG,GAAG;AAC5D;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,gCAAgC,KAAK;AACrC;AACA,WAAW,MAAM;AACjB;AACA;AACA,cAAc,eAAe;AAC7B,oBAAoB,MAAM,GAAG,gCAAgC,KAAK,MAAM;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM,SAAS,YAAY;AAC7C,kBAAkB,KAAK;AACvB,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,0BAA0B,gCAAgC;AAC1D;AACA,SAAS,QAAQ;AACjB,sBAAsB,gCAAgC;AACtD;AACA,eAAe,MAAM;AACrB,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,uBAAuB,gCAAgC;AACvD;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,SAAS,KAAK;AAClD;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,wFAAwF,cAAc;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAoD;AAC3F,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,oFAAoF,cAAc;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,SAAS;AACT;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2R;AAC3R;;;;;;;SCvgFA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;;;;;;;;;;;;;;ACN4C;AACkB;AACZ;AACF;AACY;AACQ;AACN;AACE;AAChB;;AAEhD;AACA;AACA,oBAAoB,uEAAe;AACnC,cAAc,2DAAS;AACvB,aAAa,yDAAQ;AACrB,mBAAmB,qEAAc;AACjC,uBAAuB,6EAAkB;AACzC,oBAAoB,uEAAe;AACnC,qBAAqB,yEAAgB;AACrC,aAAa,yDAAQ;AACrB;;AAEA;AACA,QAAQ,oDAAQ,8BAA8B,UAAU;AACxD;AACA;AACA;AACA,yCAAyC,UAAU;AACnD,YAAY,oDAAQ;AACpB,YAAY,oDAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,oDAAQ,sBAAsB,WAAW;AACrD;AACA;AACA;;AAEA;AACA,YAAY,oDAAQ,eAAe,cAAc;;AAEjD;AACA,gBAAgB,oDAAQ,wBAAwB,SAAS;AACzD;AACA,oBAAoB,oDAAQ;AAC5B;AACA,oBAAoB,oDAAQ;AAC5B;AACA,oBAAoB,oDAAQ,wBAAwB,SAAS;AAC7D,kBAAkB;AAClB,oBAAoB,oDAAQ;AAC5B;AACA;AACA,wBAAwB,oDAAQ,yBAAyB,SAAS;AAClE,sBAAsB;AACtB;AACA,wBAAwB,oDAAQ,yBAAyB,SAAS;AAClE,wBAAwB,oDAAQ,iBAAiB,cAAc;AAC/D;AACA,4BAA4B,oDAAQ,iBAAiB,YAAY;AACjE;AACA;AACA;AACA,gBAAgB,oDAAQ;AACxB;AACA,UAAU;AACV,YAAY,oDAAQ,+BAA+B,UAAU;AAC7D;AACA;;AAEA,QAAQ,oDAAQ,UAAU,WAAW;AACrC,QAAQ,oDAAQ,gBAAgB,cAAc;AAC9C,QAAQ,oDAAQ,iBAAiB,eAAe;AAChD,QAAQ,oDAAQ,iBAAiB,eAAe;AAChD,QAAQ,oDAAQ,kBAAkB,gBAAgB;AAClD,QAAQ,oDAAQ;AAChB;AACA,QAAQ,oDAAQ;AAChB;AACA;;AAEA;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,oDAAQ,8BAA8B,UAAU;AAChE;AACA;;AAEA,QAAQ,oDAAQ;AAChB,QAAQ,oDAAQ,sBAAsB,cAAc;AACpD,QAAQ,oDAAQ,iBAAiB,eAAe;AAChD,QAAQ,oDAAQ,iBAAiB,eAAe;AAChD,QAAQ,oDAAQ,kBAAkB,gBAAgB;AAClD,QAAQ,oDAAQ;AAChB;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA;;AAEA;AACA,IAAI,gEAAe;AACnB;AACA;;AAE2B,C","sources":["webpack://carboncommander/./src/chrome-carbonbar-page/autocomplete.js","webpack://carboncommander/./src/chrome-carbonbar-page/carbon-commander.js","webpack://carboncommander/./src/chrome-carbonbar-page/mcp-tool-caller.js","webpack://carboncommander/./src/chrome-carbonbar-page/settings.js","webpack://carboncommander/./src/chrome-carbonbar-page/tool-caller.js","webpack://carboncommander/./src/global.js","webpack://carboncommander/./src/tools/CarbonBarHelpTools.js","webpack://carboncommander/./src/tools/GeneralTools.js","webpack://carboncommander/./src/tools/external/BitbucketTools.js","webpack://carboncommander/./src/tools/external/HackerNewsTools.js","webpack://carboncommander/./src/tools/external/JiraTools.js","webpack://carboncommander/./src/tools/external/RocketChatTools.js","webpack://carboncommander/./src/tools/external/SmarterMailTools.js","webpack://carboncommander/./src/tools/external/SmarterTrackPortalTools.js","webpack://carboncommander/./src/tools/external/StackOverflowTools.js","webpack://carboncommander/./src/tools/external/TwitchTools.js","webpack://carboncommander/./src/tools/ sync \\.js$","webpack://carboncommander/./tests/suites/APITests.js","webpack://carboncommander/./tests/suites/CarbonBarTests.js","webpack://carboncommander/./tests/suites/HackerNewsTests.js","webpack://carboncommander/./tests/suites/IntegrationTests.js","webpack://carboncommander/./tests/suites/JiraTests.js","webpack://carboncommander/./tests/suites/MCPTests.js","webpack://carboncommander/./tests/suites/ServiceWorkerTests.js","webpack://carboncommander/./tests/suites/ToolCallerTests.js","webpack://carboncommander/./node_modules/marked/lib/marked.esm.js","webpack://carboncommander/webpack/bootstrap","webpack://carboncommander/webpack/runtime/define property getters","webpack://carboncommander/webpack/runtime/hasOwnProperty shorthand","webpack://carboncommander/webpack/runtime/make namespace object","webpack://carboncommander/./tests/RunAllTests.js"],"sourcesContent":["import { ccLogger } from '../global.js';\n\nexport class Autocomplete {\n    constructor(container, input, options = {}) {\n        this.container = container;\n        this.input = input;\n        this.lastAutocompleteRequest = null;\n        this.autocompleteDebounceTimer = null;\n        this.autocompleteDelay = options.delay || 300;\n        this.lastAutocompleteInput = '';\n        this.minAutocompleteLength = options.minLength || 2;\n        this.currentAutocompleteRequestId = null;\n        this.setupAutocomplete();\n    }\n\n    setupAutocomplete() {\n        // Create autocomplete element\n        this.autocompleteEl = this.container.querySelector('.cc-autocomplete');\n        if (!this.autocompleteEl) {\n            this.autocompleteEl = document.createElement('div');\n            this.autocompleteEl.classList.add('cc-autocomplete');\n            const inputWrapper = this.container.querySelector('.cc-input-wrapper');\n            inputWrapper.appendChild(this.autocompleteEl);\n        }\n\n        // Initialize state\n        this._currentSuggestions = null;\n        this._selectedIndex = 0;\n        this._handleKeyNavigation = null;\n        this._isWindowBlurred = false;\n\n        // Add input event listener\n        this.input.addEventListener('input', (e) => this.handleInputChange(e));\n\n        // Add window blur/focus events to handle alt-tab and window switching\n        window.addEventListener('blur', () => {\n            this._isWindowBlurred = true;\n        });\n\n        window.addEventListener('focus', () => {\n            this._isWindowBlurred = false;\n        });\n\n        // Add blur event listener with improved handling\n        this.input.addEventListener('blur', (e) => {\n            // Don't hide suggestions if window is blurred (alt-tab, etc)\n            if (this._isWindowBlurred) {\n                return;\n            }\n\n            // Longer delay and check if user is interacting with suggestions\n            setTimeout(() => {\n                if (!this._isWindowBlurred && \n                    !this.autocompleteEl.contains(document.activeElement) && \n                    !this.autocompleteEl.matches(':hover')) {\n                    this.autocompleteEl.innerHTML = '';\n                    this._currentSuggestions = null;\n                }\n            }, 300);\n        });\n\n        // Add mouseenter event to prevent hiding while hovering\n        this.autocompleteEl.addEventListener('mouseenter', () => {\n            this.autocompleteEl.setAttribute('data-hovering', 'true');\n        });\n\n        this.autocompleteEl.addEventListener('mouseleave', () => {\n            this.autocompleteEl.removeAttribute('data-hovering');\n            // Only hide if input is not focused\n            if (!this.input.matches(':focus')) {\n                this.autocompleteEl.innerHTML = '';\n                this._currentSuggestions = null;\n            }\n        });\n    }\n\n    handleInputChange(e) {\n        const value = this.input.value.trim();\n        \n        // Clear suggestion if input is empty or too short\n        if (!value || value.length < this.minAutocompleteLength) {\n            this.autocompleteEl.innerHTML = '';\n            this._currentSuggestions = null;\n            return;\n        }\n\n        // Don't trigger autocomplete if the input hasn't changed significantly\n        if (value === this.lastAutocompleteInput) {\n            return;\n        }\n\n        // Generate a unique request ID\n        const requestId = Date.now();\n        this.currentAutocompleteRequestId = requestId;\n\n        // Don't trigger autocomplete for very rapid typing\n        const now = Date.now();\n        if (this.lastAutocompleteRequest && (now - this.lastAutocompleteRequest) < 100) {\n            return;\n        }\n\n        // Clear existing suggestions while waiting for new ones\n        this.autocompleteEl.innerHTML = '';\n        this._currentSuggestions = null;\n\n        this.newAutocompleteRequest(value, requestId);\n    }\n\n    newAutocompleteRequest(input, requestId) {\n        if (this.autocompleteDebounceTimer) {\n            clearTimeout(this.autocompleteDebounceTimer);\n            this.autocompleteDebounceTimer = null;\n        }\n\n        this.lastAutocompleteInput = input;\n        \n        this.autocompleteDebounceTimer = setTimeout(async () => {\n            try {\n                if (requestId === this.currentAutocompleteRequestId) {\n                    this.lastAutocompleteRequest = Date.now();\n                    this.onRequestAutocomplete({\n                        ...this.getAutocompleteContext(input),\n                        requestId: requestId\n                    });\n                }\n            } catch (error) {\n                console.error('Autocomplete error:', error);\n            }\n        }, this.autocompleteDelay);\n    }\n\n    getAutocompleteContext(input) {\n        return {\n            input: input,\n            commandHistory: (this.getCommandHistory?.() || []).slice(-10),\n            context: this.getToolsContext?.() || ''\n        };\n    }\n\n    showSuggestion(input, suggestion) {\n        ccLogger.debug('Showing suggestion:', { input, suggestion });\n        \n        // For array suggestions, check the requestId of the first item\n        if (Array.isArray(suggestion)) {\n            if (!suggestion.length || suggestion[0].requestId !== this.currentAutocompleteRequestId) {\n                ccLogger.debug('Skipping suggestions due to requestId mismatch:', {\n                    current: this.currentAutocompleteRequestId,\n                    received: suggestion[0]?.requestId\n                });\n                return;\n            }\n\n            suggestion = suggestion[0].text;\n        } else if (suggestion.requestId !== this.currentAutocompleteRequestId) {\n            ccLogger.debug('Skipping suggestion due to requestId mismatch:', {\n                current: this.currentAutocompleteRequestId,\n                received: suggestion.requestId\n            });\n            return;\n        }\n\n        // Clear any existing keyboard handlers\n        this.input.removeEventListener('keydown', this._handleKeyNavigation);\n\n        // If we have an array of suggestions\n        if (Array.isArray(suggestion)) {\n            ccLogger.debug('Processing array of suggestions:', suggestion);\n            this._currentSuggestions = suggestion;\n            this._selectedIndex = 0;\n            this._renderBreadcrumbs();\n\n            // Add keyboard navigation\n            this._handleKeyNavigation = (e) => {\n                if (!this.autocompleteEl.isConnected) return;\n                \n                switch (e.key) {\n                    case 'ArrowLeft':\n                        e.preventDefault();\n                        this._selectedIndex = Math.max(0, this._selectedIndex - 1);\n                        this._renderBreadcrumbs();\n                        break;\n                    case 'ArrowRight':\n                        e.preventDefault();\n                        this._selectedIndex = Math.min(this._currentSuggestions.length - 1, this._selectedIndex + 1);\n                        this._renderBreadcrumbs();\n                        break;\n                    case 'Tab':\n                        e.preventDefault();\n                        if (this._currentSuggestions[this._selectedIndex]) {\n                            const selectedSuggestion = this._currentSuggestions[this._selectedIndex];\n                            ccLogger.debug('Selected suggestion:', selectedSuggestion);\n                            this.input.value = selectedSuggestion.text;\n                            this.input.selectionStart = this.input.selectionEnd = this.input.value.length;\n                            this.autocompleteEl.innerHTML = '';\n                            this._currentSuggestions = null;\n                        }\n                        break;\n                }\n            };\n\n            this.input.addEventListener('keydown', this._handleKeyNavigation);\n        } else {\n            this.autocompleteEl.innerHTML = '';\n            this._currentSuggestions = null;\n        }\n    }\n\n    _renderBreadcrumbs() {\n        if (!this._currentSuggestions || !this._currentSuggestions.length) {\n            this.autocompleteEl.innerHTML = '';\n            return;\n        }\n\n        ccLogger.debug('Rendering breadcrumbs for suggestions:', this._currentSuggestions);\n\n        const breadcrumbsHtml = this._currentSuggestions.map((suggestion, index) => {\n            // Ensure we're getting the text property from the suggestion object\n            const suggestionText = suggestion.text || suggestion.toString();\n            ccLogger.debug(`Suggestion ${index}:`, { suggestion, suggestionText });\n            return `\n                <span class=\"cc-suggestion-breadcrumb ${index === this._selectedIndex ? 'selected' : ''}\" \n                      data-index=\"${index}\">\n                    ${suggestionText}\n                </span>\n            `;\n        }).join('<span class=\"cc-suggestion-separator\"></span>');\n\n        this.autocompleteEl.innerHTML = `<div class=\"cc-suggestion-breadcrumbs\">${breadcrumbsHtml}</div>`;\n\n        // Add click handlers for the breadcrumbs\n        const breadcrumbs = this.autocompleteEl.querySelectorAll('.cc-suggestion-breadcrumb');\n        breadcrumbs.forEach((breadcrumb, index) => {\n            breadcrumb.addEventListener('click', () => {\n                this._selectedIndex = index;\n                this._renderBreadcrumbs();\n                // Simulate Tab press to select the suggestion\n                this._handleKeyNavigation({ key: 'Tab', preventDefault: () => {} });\n            });\n        });\n    }\n\n    // Method to be overridden by parent class\n    onRequestAutocomplete(context) {\n        // This should be implemented by the parent class\n        console.warn('onRequestAutocomplete not implemented');\n    }\n\n    // Methods that can be set by parent class\n    setCommandHistoryGetter(fn) {\n        this.getCommandHistory = fn;\n    }\n\n    setToolsContextGetter(fn) {\n        this.getToolsContext = fn;\n    }\n} ","/*\n * CarbonCommander - A command palette interface for quick actions\n * Copyright (C) 2025 Carbonitex\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\nimport { marked } from 'marked';\nimport ToolCaller from './tool-caller.js';\nimport MCPToolCaller from './mcp-tool-caller.js';\nimport { CarbonBarHelpTools } from '../tools/CarbonBarHelpTools.js';\nimport { ccLogger, AICallerModels } from '../global.js';\nimport settings from './settings.js';\nimport styles from './carbon-commander.css';\nimport { Autocomplete } from './autocomplete.js';\n\nccLogger.setPrefix('[CARBONBAR]');\n\nclass CarbonCommander {\n    constructor(doc = document) {\n      this.currentApp = `CarbonCommander [${window.location.hostname}]`;\n      this.toolCaller = ToolCaller;\n      this.mcpToolCaller = MCPToolCaller;\n      this.settings = settings;\n      this.keybind = settings.keybind;\n      this.authTokenInitialized = false;\n      this.initializationComplete = false;\n      this.messageQueue = [];\n      this.isVisible = false;\n      this.messages = [];\n      this.accumulatedChunks = '';\n      this.activeDialog = null;\n      this.dialogCallback = null;\n      this.activeDialogs = new Map(); // Track multiple active dialogs\n      this.commandHistory = [];\n      this.historyIndex = -1;\n      this.hasNoAIMode = false;\n      this.connectedProviders = new Set();\n      this.messageKeyStates = new Map(); // Track message keys\n      this.activeMessagePorts = new Map(); // Track active message ports\n      this.pendingSecureMessages = new Set(); // Track message IDs we've sent\n\n      // Initialize HMAC key from script data attribute\n      const script = doc.querySelector('script[cc-data-key]');\n      if (script) {\n        const keyBase64 = script.getAttribute('cc-data-key');\n        if (keyBase64) {\n          this.initializeHMACKey(keyBase64).catch(error => {\n            ccLogger.error('Error initializing HMAC key:', error);\n          });\n        }\n      }\n\n      var tabId = doc.querySelector('meta[name=\"tabId\"]').getAttribute('content');\n      ccLogger.info(\"Initializing with tabId:\", tabId);\n      window.tabId = tabId;\n\n      if (typeof window.tabId === 'undefined') {\n        ccLogger.error('TabId not initialized properly');\n      }\n      ccLogger.info(`CarbonCommander initialized with tabId: ${window.tabId}`);\n      \n      // Create root element with shadow DOM\n      this.root = doc.createElement('div');\n      this.shadow = this.root.attachShadow({ mode: 'closed' });\n      \n      // Add styles to shadow DOM\n      const style = doc.createElement('style');\n      style.textContent = `\n        :host {\n          all: initial;\n          display: none;\n          position: fixed;\n          top: 20%;\n          left: 50%;\n          transform: translateX(-50%);\n          width: 600px;\n          max-width: 90%;\n          z-index: 1000000;\n          font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n          color: white;\n        }\n        \n        :host(.visible) {\n          display: block;\n        }\n\n        ${styles}\n      `;\n      this.shadow.appendChild(style);\n      \n      // Create container for content\n      this.container = doc.createElement('div');\n      this.shadow.appendChild(this.container);\n      \n      // Setup event listeners first\n      this.setupEventListeners();\n      \n      // Set up settings with postMessage handler\n      this.settings.setPostMessageHandler((message) => this.postMessage(message));\n      \n      doc.body.appendChild(this.root);\n\n      this.ollamaCheckInterval = null;\n\n      // Initialize after event listeners are set up\n      this.waitForAuthThenInitialize();\n\n      // Load command history after initialization\n      this.loadCommandHistory().catch(error => {\n        ccLogger.error('Error loading initial command history:', error);\n      });\n    }\n\n    async waitForAuthThenInitialize() {      \n      // Wait for auth token to be initialized\n      await new Promise(resolve => {\n        const checkAuthToken = () => {\n          if (this.authTokenInitialized) {\n            resolve();\n          } else {\n            setTimeout(checkAuthToken, 50);\n          }\n        };\n        checkAuthToken();\n      });\n\n      // Now that we have the auth token, initialize\n      await this.init();\n      this.initializationComplete = true;\n    }\n\n    startMCPStatusChecks() {\n      // Check MCP service status periodically\n      this.mcpStatusInterval = setInterval(() => {\n        this.updateMCPStatus();\n      }, 30000); // Every 30 seconds\n    }\n\n    async updateMCPStatus() {\n      const services = this.mcpToolCaller.getMCPServices();\n      services.forEach(service => {\n        this.updateProviderStatus(`mcp:${service.id}`, service.connected);\n      });\n    }\n\n    async init() {\n      ccLogger.info(`Initializing CarbonCommander`);\n      this.container.innerHTML = `\n        <div class=\"cc-container\">\n          <div class=\"cc-dialog-header\">\n            <div class=\"cc-title\">${this.currentApp}</div>\n            <div style=\"flex-grow: 1;\"></div>\n            <div class=\"cc-status-badges\">\n              <div class=\"cc-provider-badge\" data-provider=\"ollama\" title=\"Click to toggle\">Ollama</div>\n              <div class=\"cc-provider-badge\" data-provider=\"openai\" title=\"Click to toggle\">OpenAI</div>\n              <div class=\"cc-mcp-badges\"></div>\n              <div class=\"cc-tool-count\"></div>\n            </div>\n            <div class=\"cc-settings-icon\" title=\"Settings\"></div>\n          </div>    \n          <div class=\"cc-results\" style=\"display: none;\"></div>\n          <div class=\"cc-input-wrapper\">\n            <input id=\"cc-input\" data-lpignore=\"true\" autocomplete=\"off\" type=\"text\" \n                   class=\"cc-input\" placeholder=\"Type a command...\" autofocus>\n          </div>\n          <div class=\"cc-tool-list\">\n            <div class=\"cc-tool-list-header\">\n              <div class=\"cc-tool-list-title\">Available Tools</div>\n              <button class=\"cc-tool-list-close\"></button>\n            </div>\n            <div class=\"cc-tool-list-content\"></div>\n          </div>\n        </div>\n      `;\n  \n      this.input = this.container.querySelector('.cc-input');\n      this.resultsContainer = this.container.querySelector('.cc-results');\n      this.toolList = this.container.querySelector('.cc-tool-list');\n\n\n      // Add click handlers for provider badges\n      const providerBadges = this.container.querySelectorAll('.cc-provider-badge');\n      providerBadges.forEach(badge => {\n        badge.addEventListener('click', (e) => {\n          e.stopPropagation();\n          const provider = badge.getAttribute('data-provider');\n          const isEnabled = badge.getAttribute('data-status') === 'connected';\n          \n          // Provide immediate visual feedback\n          if (isEnabled) {\n            badge.setAttribute('data-status', 'disabled');\n            this.sendFakeAIResponse(` ${provider} temporarily disabled`, 500);\n          } else if (badge.getAttribute('data-status') === 'disabled') {\n            badge.setAttribute('data-status', 'connected');\n            this.sendFakeAIResponse(` ${provider} re-enabled`, 500);\n          }\n          \n          // Toggle provider status\n          this.postMessage({\n            type: 'TOGGLE_PROVIDER',\n            payload: {\n              provider,\n              enabled: !isEnabled\n            }\n          });\n        });\n      });\n\n      // Update tool count display to show local and MCP tools separately\n      const localTools = this.toolCaller.getTools(true).length;\n      const mcpTools = this.mcpToolCaller.mcpToolsets.size > 0 ? \n        Array.from(this.mcpToolCaller.mcpToolsets.values())\n          .reduce((count, toolset) => count + toolset.tools.length, 0) : 0;\n      \n      const toolCountEl = this.container.querySelector('.cc-tool-count');\n      toolCountEl.textContent = mcpTools > 0 ? \n        `${localTools} local + ${mcpTools} MCP tools` : \n        `${localTools} tools`;\n\n      // Set up tool list click handlers\n      this.setupToolList();\n\n      this.input.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter') {\n          const value = this.input.value.trim();\n          if (value) {\n            // Add command to history only if it's not empty and different from last command\n            if (this.commandHistory.length === 0 || this.commandHistory[this.commandHistory.length - 1] !== value) {\n              this.commandHistory.push(value);\n              this.saveCommandHistory(); // Save after adding new command\n            }\n            this.historyIndex = this.commandHistory.length;\n            this.handleSubmit(value);\n          }\n        } else if (e.key === 'ArrowUp') {\n          e.preventDefault();\n          if (this.historyIndex > 0) {\n            this.historyIndex--;\n            this.input.value = this.commandHistory[this.historyIndex];\n            // Move cursor to end of input\n            setTimeout(() => {\n              this.input.selectionStart = this.input.selectionEnd = this.input.value.length;\n            }, 0);\n          }\n        } else if (e.key === 'ArrowDown') {\n          e.preventDefault();\n          if (this.historyIndex < this.commandHistory.length - 1) {\n            this.historyIndex++;\n            this.input.value = this.commandHistory[this.historyIndex];\n          } else {\n            this.historyIndex = this.commandHistory.length;\n            this.input.value = '';\n          }\n        }\n      });\n      document.addEventListener('keydown', (e) => {\n        if (this.isVisible && e.key === 'Escape') {\n          this.hide();\n        }\n      });\n\n      // Add click handler for settings icon\n      const settingsIcon = this.container.querySelector('.cc-settings-icon');\n      settingsIcon.addEventListener('click', () => this.showSettingsDialog());\n\n      // Load settings\n      await this.settings.load();\n\n      // Load command history\n      this.loadCommandHistory();\n\n      // Initialize autocomplete\n      this.autocomplete = new Autocomplete(this.container, this.input, {\n        delay: 300,\n        minLength: 2\n      });\n    \n      // Set up autocomplete callbacks\n      this.autocomplete.setCommandHistoryGetter(() => this.commandHistory);\n      this.autocomplete.setToolsContextGetter(() => {\n        return this.toolCaller.getTools(true).map(tool => `${tool.description}`).join('\\n');\n      });\n      this.autocomplete.onRequestAutocomplete = (context) => {\n        this.postMessage({\n          type: 'CB_GET_AUTOCOMPLETE',\n          payload: context\n        });\n      };\n\n      setTimeout(() => {\n        this.checkOllamaAvailability(1000, 10);\n      }, 500);\n\n      ccLogger.debug('Checking OpenAI availability', { noAIMode: this.hasNoAIMode });\n      this.postMessage({ \n        type: \"CHECK_OPENAI_AVAILABLE\",\n        payload: {\n          noAIMode: this.hasNoAIMode\n        }\n      });\n\n      // Add MCP status tracking\n      this.mcpStatusInterval = null;\n      this.startMCPStatusChecks();\n    }\n  \n    setupEventListeners() {\n      // Update keyboard shortcut to use custom keybind\n      document.addEventListener('keydown', (e) => {\n        const matchesKeybind = \n          e.key.toLowerCase() === this.keybind.key.toLowerCase() && \n          (e.ctrlKey === this.keybind.ctrl) && \n          (e.metaKey === this.keybind.meta);\n\n        if (matchesKeybind) {\n          e.preventDefault();\n          if (this.isVisible) {\n            this.hide();\n          } else {\n            this.show();\n          }\n        }\n      });\n\n      // Add event listener for model download progress\n      window.addEventListener('ollama-model-progress', (event) => {\n          const progress = event.detail;\n          this.showModelDownloadProgress(progress);\n      });\n\n      const tempMessageHandler = async (event, unprefixedType) => {\n        // Handle settings loaded message first to get auth token\n        if (unprefixedType === 'GET_SETTINGS_RESPONSE') {\n          if (event.data._authToken && !this.authTokenInitialized) {\n            this.authToken = event.data._authToken;\n            this.authTokenInitialized = true;\n            ccLogger.debug('AUTH_TOKEN_INITIALIZED', this.authToken);\n            delete event.data._authToken; // Remove token from settings object\n          }\n          // Continue with normal settings handling...\n        }\n\n        // Handle our new confirmation dialog type\n        if (unprefixedType === 'SHOW_ACCESS_REQUEST_RESPONSE') {\n            this.handleAccessRequest(event.data);\n        }\n\n        if (unprefixedType === 'AI_EXECUTE_TOOL_RESPONSE') {\n          if(!event.data._authToken || !event.data._authToken == this.authToken) {\n            ccLogger.debug('[RCV]','Invalid auth token', event.data);\n            return;\n          }\n          \n          const payload = event.data.payload?.payload || event.data.payload;\n\n          const toolName = payload.tool.name;\n          const toolArgs = payload.tool.arguments;\n        \n          ccLogger.debug('Received tool execution request:', toolName, toolArgs);\n          const tool = this.toolCaller.getTool(toolName);\n          if (!tool) {\n            ccLogger.error(`Tool not found: ${toolName}`);\n            this.postMessage({ \n              type: 'AI_TOOL_RESPONSE', \n              payload: { \n                result: {\n                  success: false,\n                  error: `Tool not found: ${toolName}`\n                },\n                name: toolName,\n                arguments: toolArgs,\n                tool_call_id: tool?.id\n              }\n            });\n            return;\n          }\n          try {\n            const result = await tool.execute(await this.toolCaller.getToolScope(this), toolArgs);\n            ccLogger.debug(\"AI_EXECUTE_TOOL result:\", result);\n            // Send tool response through secure messaging\n            this.postMessage({ \n              type: 'AI_TOOL_RESPONSE', \n              payload: {\n                result: result,\n                name: toolName,\n                arguments: toolArgs,\n                tool_call_id: tool?.id\n              }\n            });\n          } catch (error) {\n            ccLogger.error('Tool execution error:', error);\n            // Send error through secure messaging\n            this.postMessage({ \n              type: 'AI_TOOL_RESPONSE', \n              payload: {\n                result: {\n                  success: false,\n                  error: error.message\n                },  \n                stop: true,\n                tool_call_id: tool?.id,\n                name: toolName,\n                arguments: toolArgs\n              }\n            });\n          }\n        }\n\n        // Handle AI responses\n        if (unprefixedType === 'AI_CHUNK_RESPONSE' || \n            unprefixedType === 'AI_ERROR_RESPONSE') {\n            this.handleAIResponse(event.data);\n        }\n\n        if (unprefixedType === 'SHOW_CONFIRMATION_DIALOG') {\n            this.showConfirmationDialog(\n                event.data.payload,\n                event.data.payload.callback\n            );\n        }\n\n        if (unprefixedType === 'SHOW_INPUT_DIALOG') {\n            this.showInputDialog(\n                event.data.payload,\n                event.data.payload.callback\n            );\n        }\n\n        if (unprefixedType === 'COMMAND_HISTORY_RESPONSE') {\n          this.commandHistory = event.data.payload || [];\n          this.historyIndex = this.commandHistory.length;\n        }\n\n        if (unprefixedType === 'GET_AUTOCOMPLETE_RESPONSE') {\n            const suggestion = event.data.payload?.payload || event.data.payload;\n            if (suggestion) {\n                ccLogger.debug('showAutocompleteSuggestion', suggestion);\n                // Extract the input from the current input field\n                const currentInput = this.input.value.trim();\n                // Create the suggestion object in the format expected by showAutocompleteSuggestion\n                const formattedSuggestion = {\n                    requestId: this.autocomplete.currentAutocompleteRequestId,\n                    text: suggestion.payload || suggestion\n                };\n                this.showAutocompleteSuggestion(currentInput, formattedSuggestion);\n            }\n        }\n\n        if (unprefixedType === 'PROVIDER_STATUS_UPDATE') {\n          ccLogger.debug('PROVIDER_STATUS_UPDATE', event.data.provider, event.data.status);\n          this.updateProviderStatus(event.data.provider, event.data.status);\n        \n          if(event.data.provider == 'openai' && event.data.status){\n            this.connectedProviders.add('openai');\n          }\n        \n          if(this.hasNoAIMode && this.connectedProviders.has('openai') && this.connectedProviders.has('ollama')){\n            this.hasNoAIMode = false;\n            this.currentApp = await this.toolCaller.getToolScope(this).appName;\n            this.updateTitle(this.currentApp);\n            this.sendFakeAIResponse(\" All AI providers connected! You can now use all features.\", 500);\n            this.sendFakeAIResponse(\"Go ahead and hit ESC or Ctrl+K to close and reopen the command bar to enter normal mode.\", 1000);\n          }\n        \n          if (event.data.provider == 'ollama' && event.data.status && this.ollamaCheckInterval) {\n            clearInterval(this.ollamaCheckInterval);\n            this.ollamaCheckInterval = null;\n          }\n        \n          if (event.data.status && this.hasNoAIMode) {\n            if (this.connectedProviders.size > 0) {\n              //this.hasNoAIMode = false; //Keep this disabled unless openai is connected\n              //this.sendFakeAIResponse(\" AI provider connected! You can now use all features.\", 500);\n            \n              // If connectedProviders does not contain openai, we need to prompt the user to connect it\n              if (event.data.provider == 'ollama' && !this.connectedProviders.has('openai')) {\n                this.sendFakeAIResponse(\" **Tip:** While Ollama provides local AI capabilities, adding OpenAI can greatly enhance functionality with more advanced models like GPT-4.\\n\\nTo connect OpenAI:\\n1. Get an API key from [OpenAI's platform](https://platform.openai.com/api-keys)\\n2. Use the command: `set openai-key YOUR_API_KEY`\", 1000);\n              } else if (event.data.provider == 'openai' && !this.connectedProviders.has('ollama')) {\n                this.sendFakeAIResponse(\" **Tip:** While OpenAI provides great capabilities, adding Ollama allows the command bar to run some prompts locally like autocomplete, summarization, and suggestions.\", 1000);\n              }\n            }\n          }\n        }\n\n        if (unprefixedType === 'MCP_SERVICE_CONFIG') {\n          const config = event.data.payload;\n          await this.mcpToolCaller.configureMCPService(config);\n          this.updateMCPStatus();\n        }\n\n        if (unprefixedType === 'MCP_SERVICE_STATUS') {\n          const { serviceId, status } = event.data.payload;\n          this.updateProviderStatus(`mcp:${serviceId}`, status.connected);\n        }\n\n        if (unprefixedType === 'TOGGLE_CARBONBAR') {\n          this.toggle();\n        }\n\n        if (unprefixedType === 'SHOW_KEYBIND_DIALOG') {\n          this.showKeybindDialog();\n        }\n\n        if (unprefixedType === 'SET_KEYBIND') {\n          this.keybind = event.data.payload;\n        }\n      }\n\n      window.addEventListener(\"message\", (event) => {\n        // We only accept messages from ourselves\n        if (event.source !== window) {\n          ccLogger.warn('Message from external source');\n          //return;\n        }\n\n        // Handle secure message channel setup\n        if (event.data.type === 'SECURE_MESSAGE_DONT_HANDLEATM') {\n          ccLogger.debug('Setting up secure message channel');\n          const port = event.ports[0];\n          const messageId = event.data.messageId;\n          if (!port || !messageId) {\n            ccLogger.error('Missing port or messageId for secure channel');\n            return;\n          }\n\n          // Verify this is a message we sent\n          if(event.data.messageType == 'AI_TOOL_EXECUTE') {\n            ccLogger.debug('Received secure message for AI tool execute:', messageId, event.data);\n          } else if (!this.pendingSecureMessages.has(messageId)) {\n            ccLogger.warn('Received secure message for unknown message ID:', messageId, event.data);\n            return;\n          } else {\n            ccLogger.debug('Received secure message for known message ID:', messageId, event.data);\n          }\n\n          // Store port reference and initialize key state\n          this.activeMessagePorts.set(messageId, port);\n          this.messageKeyStates.set(messageId, this.hmacKey);\n          ccLogger.debug('Initialized message state with HMAC key');\n\n          // Start port immediately\n          port.start();\n          ccLogger.debug('Started message port');\n\n          // Listen for messages on the port\n          port.onmessage = async (e) => {\n            const message = e.data;\n            try {\n              const counter = message._counter;\n              ccLogger.debug('Received message on secure channel:', { \n                type: message.type,\n                counter,\n                messageId \n              });\n\n              // Get current key for this message\n              const currentKey = this.messageKeyStates.get(messageId);\n              if (!currentKey) {\n                throw new Error('No key found for message');\n              }\n\n              // Verify the message signature\n              const isValid = await this.verifySignature(message.data, message.signature, currentKey);\n              if (!isValid) {\n                throw new Error('Invalid message signature');\n              }\n\n              // Process the actual message\n              const unprefixedType = message.data.type.replace(/^CARBON_/, '');\n              ccLogger.debug('Processing secure message:', unprefixedType);\n              \n              // Handle the message based on its type\n              await tempMessageHandler({ data: message.data }, unprefixedType);\n\n              // Derive and update to next key\n              const nextKey = await this.deriveNextKey(currentKey, `${messageId}-${counter}`);\n              if (nextKey) {\n                this.messageKeyStates.set(messageId, nextKey);\n                ccLogger.debug('Updated message key');\n              }\n              \n            } catch (error) {\n              ccLogger.error('Error in secure message handling:', error);\n              // Send error back through port\n              port.postMessage({\n                error: error.message,\n                counter: message?._counter\n              });\n            }\n          };\n\n          // Handle port closure and cleanup\n          port.onclose = () => {\n            ccLogger.debug('Secure message port closed:', messageId);\n            this.messageKeyStates.delete(messageId);\n            this.activeMessagePorts.delete(messageId);\n            this.pendingSecureMessages.delete(messageId);\n          };\n\n          return;\n        }\n\n        if(event.data.type == 'PROVIDER_STATUS_UPDATE' || event.data.type == 'SET_KEYBIND') {\n          event.data.type = 'CARBON_' + event.data.type;\n        }\n\n        if(!event.data.type || (!event.data.type.startsWith('CARBON_') && !event.data.type.startsWith('CB_'))) {\n          ccLogger.debug('[RCV]','Unknown message type', event.data);\n          return;\n        }\n\n        const unprefixedType = event.data.type.replace('CARBON_', '').replace('CB_', '');\n        ccLogger.debug('[RCV]', event.data.type, event.data);\n        tempMessageHandler(event, unprefixedType);\n      });\n    }\n\n    sendFakeAIResponse(content, delay = 500) {\n      setTimeout(() => {\n        this.handleAIResponse({\n          type: 'AI_CHUNK_RESPONSE',\n          payload: {\n            content: content,\n            isFinished: true\n          }\n        });\n      }, delay); // Small delay to separate messages\n    }\n\n    deriveNextKey = async (currentKey, salt) => {\n      try {\n        // Export current key to raw bytes if it's a CryptoKey object\n        const rawKey = currentKey instanceof CryptoKey ? \n          await crypto.subtle.exportKey(\"raw\", currentKey) :\n          currentKey;\n        \n        // Use HKDF to derive a new key\n        const encoder = new TextEncoder();\n        const keyMaterial = await crypto.subtle.importKey(\n          \"raw\",\n          rawKey,\n          { name: \"HKDF\" },\n          false,\n          [\"deriveBits\"]\n        );\n\n        const bits = await crypto.subtle.deriveBits(\n          {\n            name: \"HKDF\",\n            hash: \"SHA-256\",\n            salt: encoder.encode(salt),\n            info: encoder.encode(\"CarbonCommanderRatchet\")\n          },\n          keyMaterial,\n          256\n        );\n\n        // Convert derived bits to new HMAC key\n        return await crypto.subtle.importKey(\n          \"raw\",\n          bits,\n          {\n            name: \"HMAC\",\n            hash: { name: \"SHA-256\" }\n          },\n          true,\n          [\"sign\", \"verify\"]\n        );\n      } catch (error) {\n        ccLogger.error('Error deriving next key:', error);\n        return null;\n      }\n    }\n\n    verifySignature = async (message, signature, key) => {\n      try {\n        const encoder = new TextEncoder();\n        const data = encoder.encode(JSON.stringify(message));\n        return await crypto.subtle.verify(\n          \"HMAC\",\n          key,\n          signature,\n          data\n        );\n      } catch (error) {\n        ccLogger.error('Error verifying signature:', error);\n        return false;\n      }\n    }\n\n    initializeHMACKey = async (keyBase64) => {\n      try {\n        const rawKey = Uint8Array.from(atob(keyBase64), c => c.charCodeAt(0));\n        const hmacKey = await crypto.subtle.importKey(\n          \"raw\",\n          rawKey,\n          {\n            name: \"HMAC\",\n            hash: { name: \"SHA-256\" }\n          },\n          true,\n          [\"sign\", \"verify\"]\n        );\n        // Store initial key for each message channel\n        this.hmacKey = hmacKey;\n        ccLogger.debug('HMAC key initialized');\n      } catch (error) {\n        ccLogger.error('Error initializing HMAC key:', error);\n      }\n    }\n\n    getCurrentResultContainer() {\n      var resultContainer = this.resultsContainer.children[this.resultsContainer.children.length - 1];\n\n      //if the last child is not a cc-result-item, create one\n      if(resultContainer?.classList.contains('cc-result-item')) {\n        return resultContainer;\n      } else {\n        resultContainer = document.createElement('div');\n        resultContainer.classList.add('cc-result-item');\n        this.resultsContainer.appendChild(resultContainer);\n      }\n      return resultContainer;\n    }\n\n    getNoProviderHtml() {\n        return `\n            <div class=\"cc-no-provider\">\n                <h3>No AI Provider Available</h3>\n                <p>To use the command bar, you'll need to set up one of these AI providers:</p>\n                \n                <div class=\"provider-section\">\n                    <h4>OpenAI</h4>\n                    <p>A cloud-based solution offering powerful models like GPT-4.</p>\n                    <ul>\n                        <li>Get an API key from <a href=\"https://platform.openai.com/api-keys\" target=\"_blank\">OpenAI's platform</a></li>\n                        <li>Use the command: <code>set openai-key YOUR_API_KEY</code></li>\n                        ${this.connectedProviders.has('openai') ? \n                            '<li>Or disconnect: <code>disconnect openai</code></li>' : ''}\n                    </ul>\n                </div>\n\n                <div class=\"provider-section\">\n                    <h4>Ollama</h4>\n                    <p>A local AI solution that runs on your machine.</p>\n                    <ul>\n                        <li>Download and install <a href=\"https://ollama.ai\" target=\"_blank\">Ollama</a></li>\n                        <li>Run Ollama locally</li>\n                        <li>For macOS users, enable external connections:</li>\n                        <li><code>launchctl setenv OLLAMA_ORIGINS \"chrome-extension://*\"</code></li>\n                    </ul>\n                </div>\n\n                <div class=\"provider-status\">\n                    <p>Current Status:</p>\n                    <ul>\n                        <li>OpenAI: <span class=\"status-indicator\">Not Connected</span></li>\n                        <li>Ollama: <span class=\"status-indicator\">Not Connected</span></li>\n                    </ul>\n                </div>\n            </div>\n        `;\n    }\n\n    displayError(error) {\n      const container = this.container.querySelector('.cc-container');\n      container.classList.remove('processing', 'tool-running');\n      container.classList.add('has-error');\n      ccLogger.debug('AI_ERROR_RESPONSE', error);\n      let errorMessage = error.message || error.content || 'Unknown error';\n      if(errorMessage.length > 0) {\n        switch(errorMessage) {\n          case 'NO_AI_PROVIDER':\n            if(!this.hasNoAIMode) {\n              this.hasNoAIMode = true;\n              this.currentApp = 'New User Mode [No AI]';\n              this.updateTitle(this.currentApp);\n              let ccError = document.createElement('div');\n              ccError.classList.add('cc-error');\n              ccError.innerHTML = this.getNoProviderHtml();\n              this.resultsContainer.appendChild(ccError);\n              // Start periodic Ollama check\n              this.checkOllamaAvailability(5000);\n            } else {\n              this.sendFakeAIResponse(errorMessage);\n            }\n            \n            break;\n          default:\n            break;\n        }\n      }\n    }\n\n    // Helper method to handle AI responses\n    handleAIResponse(message) {\n      ccLogger.group('AI Response Handler');\n      const container = this.container.querySelector('.cc-container');\n      const payload = message.payload || message.data.payload;\n\n      ccLogger.debug('Processing AI response:', { type: message.type, payload });\n        \n      if (payload.error) {\n        ccLogger.error('AI response error:', payload.error);\n        this.displayError(payload);\n      } else if (message.type == 'AI_ERROR_RESPONSE') {\n        ccLogger.error('AI response error:', payload);\n        this.displayError(payload);\n      } \n      //else {\n      if (typeof payload.content === 'string' && payload.content.length > 0) {\n        const chunk = payload.content;\n        ccLogger.debug('AI_CHUNK_RESPONSE2', payload.error, message.type, chunk);\n        this.accumulatedChunks += chunk;\n        const htmlContent = marked.parse(this.accumulatedChunks);\n        const resultContainer = this.getCurrentResultContainer();\n        ccLogger.debug('AI_CHUNK_RESPONSE3', resultContainer);\n        let aiOutput = resultContainer.querySelector('.cc-ai-output');\n\n        if(!aiOutput || aiOutput.classList.contains('state_finished')) {\n          aiOutput = document.createElement('div');\n          aiOutput.classList.add('cc-ai-output');\n          resultContainer.appendChild(aiOutput);\n        }\n\n        if(htmlContent.length > 0) {\n          aiOutput.innerHTML = htmlContent;\n        } else {\n          aiOutput.remove();\n          aiOutput = null;\n        }\n\n        if(aiOutput && payload.isFinished) {\n          aiOutput.classList.add('state_finished');\n        }\n        \n      } else {\n        //tool call result\n        if(payload.content?.type == \"TOOL_CALL_CHUNK\") {\n          this.accumulatedChunks = '';\n          const chunk = payload.content.payload;\n          const toolCallId = chunk.id;\n\n          let currentResultContainer = this.resultsContainer;\n          let toolCallDiv = currentResultContainer.querySelectorAll(`.cc-tool-call[data-id=\"${toolCallId}\"]`);\n          ccLogger.debug('toolCallDiv', toolCallDiv);\n          if(!toolCallDiv || toolCallDiv.length == 0) {\n            toolCallDiv = document.createElement('div');\n            toolCallDiv.classList.add('cc-tool-call');\n            toolCallDiv.setAttribute('data-id', toolCallId);\n            \n            // Create containers for both views\n            toolCallDiv.innerHTML = `\n              <div class=\"tool-simple-view tool-view-toggle\"></div>\n              <div class=\"tool-advanced-view\" style=\"display: none;\"></div>\n            `;\n            currentResultContainer.appendChild(toolCallDiv);\n          }\n\n          if(Array.isArray(toolCallDiv) || NodeList.prototype.isPrototypeOf(toolCallDiv) || HTMLCollection.prototype.isPrototypeOf(toolCallDiv)){\n            toolCallDiv = toolCallDiv[0];\n          }\n\n          let simpleView = toolCallDiv.querySelector('.tool-simple-view');\n          let advancedView = toolCallDiv.querySelector('.tool-advanced-view');\n\n          // Update both views\n          const {simpleHtml, advancedHtml} = this.toolCaller.getToolHtml(chunk);\n          simpleView.innerHTML = simpleHtml;\n          advancedView.innerHTML = advancedHtml;\n\n          // Add click handlers for toggle buttons if they don't exist\n          const toggleButtons = toolCallDiv.querySelectorAll('.tool-view-toggle');\n          toggleButtons.forEach(button => {\n            if (!button.hasClickHandler) {\n              button.hasClickHandler = true;\n              button.addEventListener('click', () => {\n                const isSimpleView = simpleView.style.display !== 'none';\n                simpleView.style.display = isSimpleView ? 'none' : 'block';\n                advancedView.style.display = isSimpleView ? 'block' : 'none';\n              });\n            }\n          });\n\n          container.classList.remove('processing');\n          container.classList.add('tool-running');\n        }\n\n        ccLogger.debug('AI_TOOL_CALL_RESULT', payload.content?.payload?.id, payload);\n      }\n\n      this.resultsContainer.scrollTop = this.resultsContainer.scrollHeight;\n      \n\n      if (payload.isFinished) {\n        container.classList.remove('processing', 'tool-running', 'has-error');\n        container.classList.add('success');\n        setTimeout(() => {\n          container.classList.remove('success');\n          container.classList.add('waiting-input');\n        }, 2000);\n        ccLogger.debug('AI response finished', payload, container.classList);\n        this.createNewResultContainer = true;\n        this.accumulatedChunks = '';\n        // Reset input\n        this.input.value = '';\n        this.input.disabled = false;\n        this.input.focus();\n      }\n\n      if (payload.messages && !payload.error) {\n        ccLogger.debug('AI response messages', payload.messages);\n        this.messages = payload.messages;\n      }\n      ccLogger.groupEnd();\n    }\n\n    getService(serviceName) {\n      return angular.element(document).injector().get(serviceName);\n    }\n\n    async noAIModeOpenAIInputRespond(){\n      var msgs = [];\n      let newSystemPrompt = `You are a helpful AI assistant integrated into a smart command bar. You are currently in low-AI mode using OpenAI's cloud-based models.\n\nKey capabilities:\n- Answering questions about the application and its features\n- Providing help and guidance on using available tools\n- Explaining concepts and offering suggestions\n- Processing natural language commands into tool actions\n\nGuidelines:\n- Keep responses clear and concise\n- When suggesting tools, explain their purpose\n- If you can't help with something, explain why and suggest alternatives\n- Format responses using markdown for better readability\n\nAvailable tools are being limited. For more additional features like autocomplete, summarization, and suggestions, recommend connecting to Ollama. \nIf you can't fulfill a request remind them that they are running in a low-AI mode and that they can connect to Ollama for more advanced features. \nTell them that they can refresh the page to enter normal mode.`;\n\n      msgs.push({\n        role: 'system',\n        content: newSystemPrompt\n      });\n\n      msgs.push(this.messages[this.messages.length - 1]);\n      \n      var request = {\n        messages: msgs,\n        model: AICallerModels.FAST, //this will be set by the ai-service if null\n        tools: CarbonBarHelpTools.GetNoAIModeToolInfo(),\n        temp: 0.6,\n        keepAlive: '30m',\n        provider: 'openai'\n      };\n      this.postMessage({ \n        type: \"AI_REQUEST\", \n        payload: request\n      });\n    }\n\n    async noAIModeOllamaInputRespond(){\n      var msgs = [];\n      let newSystemPrompt = `You are a helpful AI assistant integrated into a smart command bar. You are currently in low-AI mode using Ollama's local models.\n\nKey capabilities:\n- Answering questions about the application and its features\n- Providing help and guidance on using available tools\n- Explaining concepts and offering suggestions\n- Processing natural language commands into tool actions\n\nGuidelines:\n- Keep responses clear and concise\n- When suggesting tools, explain their purpose\n- If you can't help with something, explain why and suggest alternatives\n- Format responses using markdown for better readability\n\nAvailable tools are being limited. For more advanced features, recommend connecting to OpenAI. If you can't fulfill a request remind them that they are running in a low-AI mode and that they can connect to OpenAI for more advanced features. Or that they may refresh the page to enter normal mode.`;\n\n      msgs.push({\n        role: 'system',\n        content: newSystemPrompt\n      });\n\n      msgs.push(this.messages[this.messages.length - 1]);\n      \n      var request = {\n        messages: msgs,\n        model: 'mistral-small',//AICallerModels.FAST,\n        tools: CarbonBarHelpTools.GetNoAIModeToolInfo(),\n        temp: 0.5,\n        keepAlive: '30m',\n        provider: 'ollama'\n      };\n      this.postMessage({ \n        type: \"AI_REQUEST\", \n        payload: request\n      });\n    }\n\n    async noAIModeInputHandler(messages) {\n      const userMessage = messages[messages.length - 1];\n      const userInput = userMessage.content;\n\n      // Check if it's an OpenAI key setting command\n      if (userInput.toLowerCase().startsWith('set openai-key ')) {\n        const key = userInput.substring(14).trim();\n        \n        try {\n          var result = await CarbonBarHelpTools.SetOpenAIKey.execute(await this.toolCaller.getToolScope(this), {key: key});\n          ccLogger.debug('result', result);\n          if(result.success){\n            this.sendFakeAIResponse('OpenAI key set successfully');\n          } else {\n            this.sendFakeAIResponse(\"Failed to set OpenAI key. Please try again.\");\n          }\n        } catch (error) {\n          this.sendFakeAIResponse(\"Failed to set OpenAI key. Please try again.\");\n        }\n\n        //// Send message to set OpenAI key\n        //window.postMessage(\n        //  { \n        //    type: \"SET_OPENAI_KEY\", \n        //    payload: key,\n        //    tabId: window.tabId\n        //  },\n        //  window.location.origin\n        //);\n\n        // Response will come back through the message event listener\n        return;\n      }\n\n      //if ollama is connected we can prompt it\n      if (this.connectedProviders.has('openai')) {\n        this.noAIModeOpenAIInputRespond();\n        return;\n      } else if(this.connectedProviders.has('ollama')) {\n        this.noAIModeOllamaInputRespond();\n        return;\n      }\n      \n\n      // Default response with help text\n      this.sendFakeAIResponse(\"To set up an AI provider, you can:\\n\\n\" +\n        \"1. Set your OpenAI key using: `set openai-key YOUR_API_KEY`\\n\" +\n        \"2. Install and run Ollama locally\\n\\n\" +\n        \"Need help? Type 'help' for more information.\"\n      );\n    }\n    \n    async handleSubmit(value) {\n      ccLogger.group('Handle Submit');\n      ccLogger.info('Processing input:', value);\n\n      // Special commands for MCP services\n      if (value.toLowerCase().startsWith('mcp connect ')) {\n        const [_, serviceId, endpoint] = value.split(' ');\n        await this.mcpToolCaller.configureMCPService({\n          serviceId,\n          endpoint,\n          options: { autoConnect: true }\n        });\n        this.sendFakeAIResponse(`Connecting to MCP service: ${serviceId}`);\n        return;\n      }\n\n      if (value.toLowerCase().startsWith('mcp disconnect ')) {\n        const serviceId = value.split(' ')[2];\n        await this.mcpToolCaller.disconnectMCPService(serviceId, true);\n        this.sendFakeAIResponse(`Disconnected from MCP service: ${serviceId}`);\n        return;\n      }\n\n      if (value.toLowerCase() === 'disconnect openai') {\n        ccLogger.info('Disconnecting OpenAI');\n        this.sendFakeAIResponse(\"OpenAI disconnected successfully\");\n        ccLogger.groupEnd();\n        return;\n      }\n\n      const container = this.container.querySelector('.cc-container');\n      \n      // Add transitioning class before changing states\n      container.classList.add('transitioning');\n\n      // Remove previous states after a brief delay\n      setTimeout(() => {\n          container.classList.remove('waiting-input', 'has-error', 'tool-running', 'success', 'rainbow');\n          container.classList.add('processing');\n          // Remove transitioning class to start new animation\n          container.classList.remove('transitioning');\n      }, 150);\n      \n      this.input.disabled = true;\n      this.input.value = 'Processing...';\n      \n      // Show results container with fade\n      this.resultsContainer.classList.remove('hidden');\n      this.resultsContainer.style.display = 'block';\n\n      try {\n          // Add user message to history\n          this.messages.push({\n            role: 'user',\n            content: value\n          });\n\n          // Add user message to display with animation\n          const userElement = document.createElement('div');\n          userElement.classList.add('cc-user-message');\n          userElement.textContent = value;\n          this.resultsContainer.appendChild(userElement);\n          this.resultsContainer.scrollTop = this.resultsContainer.scrollHeight;\n\n          if(this.hasNoAIMode) {\n            this.noAIModeInputHandler(this.messages);\n          } else {\n            // Build request to send to the ai-service\n            const localTools = this.toolCaller.getTools(true);\n            const mcpTools = Array.from(this.mcpToolCaller.mcpToolsets.values())\n                .reduce((tools, toolset) => tools.concat(toolset.tools), []);\n\n            var request = {\n              messages: this.messages,\n              model: AICallerModels.FAST,\n              tools: [...localTools, ...mcpTools], // Combine unique tools\n              temp: 0.7,\n              keepAlive: '30m'\n            };\n\n            // Send message to ai-service using postMessage helper\n            this.postMessage({ \n              type: \"AI_REQUEST\", \n              payload: request\n            });\n          }\n\n          //The messages will come in via previously setup event listeners\n          //and will be handled by the completeResponse function\n      } catch (error) {\n          // Add transitioning class before changing to error state\n          container.classList.add('transitioning');\n          setTimeout(() => {\n              container.classList.remove('processing');\n              container.classList.add('has-error');\n              container.classList.remove('transitioning');\n          }, 150);\n          \n          ccLogger.error('Error:', error);\n          this.resultsContainer.innerHTML += `\n              <div class=\"cc-error\">Error: ${error.message}</div>\n          `;\n          this.input.disabled = false;\n          this.input.value = value;\n          this.resultsContainer.scrollTop = this.resultsContainer.scrollHeight;\n      }\n      ccLogger.groupEnd();\n    }\n  \n\n\n    //TODO: If vision enabled, allow uploads of images (maybe documents)\n    //TODO: Thumbs up/down or star/unstar for commands, or assistant responses\n\n    updateTitle(title) {\n      this.container.querySelector('.cc-title').textContent = title;\n    }\n\n    async show() {\n      this.currentApp = (await this.toolCaller.getToolScope(this))?.appName || 'CarbonCommander [Unknown App]';\n      this.updateTitle(this.currentApp);\n      \n      const container = this.container.querySelector('.cc-container');\n      container.classList.remove('processing', 'tool-running', 'has-error', 'success');\n      container.classList.add('waiting-input');\n\n      // Clear existing messages before adding system prompt\n      this.messages = [];\n      \n      // Add system prompt first\n      await this.addSystemPrompt();\n      \n      this.root.classList.add('visible');\n      this.isVisible = true;\n      this.input.focus();\n    }\n  \n    hide() {\n      const container = this.container.querySelector('.cc-container');\n      container.classList.remove('waiting-input', 'processing', 'has-error', 'tool-running', 'success', 'rainbow');\n      this.root.classList.remove('visible');\n      this.isVisible = false;\n      let resultsContainer = document.querySelector('.cc-results');\n      if(resultsContainer) {\n        resultsContainer.style.display = 'none';\n      }\n      this.input.value = '';\n      this.messages = []; //clear the message history\n      this.resultsContainer.innerHTML = '';\n      this.toolCaller.reset();\n      // Don't clear command history, just reset the index\n      this.historyIndex = this.commandHistory.length;\n\n      if (this.ollamaCheckInterval) {\n        clearInterval(this.ollamaCheckInterval);\n        this.ollamaCheckInterval = null;\n      }\n\n      if(this.connectedProviders.has('ollama')) {\n        this.noAIMode = false;\n      }\n    }\n  \n    toggle() {\n      if (this.isVisible) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n    showConfirmationDialog(config, callback) {\n        // Create dialog HTML with animation\n        const dialogHTML = `\n            <div class=\"cc-dialog\" style=\"animation: messageAppear 0.3s ease-in-out forwards;\">\n                <div class=\"cc-dialog-content\">\n                    <p>${config.prompt}</p>\n                    <div class=\"cc-dialog-buttons\">\n                        <button class=\"cc-button confirm\" data-action=\"confirm\">Yes</button>\n                        <button class=\"cc-button cancel\" data-action=\"cancel\">No</button>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        // Create dialog container if it doesn't exist\n        let dialogContainer = this.container.querySelector('.cc-dialog-container');\n        if (!dialogContainer) {\n            dialogContainer = document.createElement('div');\n            dialogContainer.classList.add('cc-dialog-container');\n            this.container.appendChild(dialogContainer);\n        }\n\n        // Insert the dialog HTML\n        dialogContainer.innerHTML = dialogHTML;\n        const dialog = dialogContainer.querySelector('.cc-dialog');\n\n        // Add click handlers for buttons\n        const buttons = dialog.querySelectorAll('.cc-button');\n        buttons.forEach(button => {\n            button.addEventListener('click', () => {\n                const action = button.dataset.action;\n                const confirmed = action === 'confirm';\n\n                // Animate dialog out\n                dialog.style.animation = 'messageAppear 0.3s ease-in-out reverse';\n                \n                setTimeout(() => {\n                    // Remove the dialog\n                    dialogContainer.remove();\n\n                    // Send response through secure messaging\n                    this.postMessage({\n                        type: 'CB_DIALOG_RETURN',\n                        payload: {\n                            requestId: config.requestId,\n                            confirmed: confirmed\n                        }\n                    });\n                }, 300); // Match animation duration\n            });\n        });\n\n        // Add escape key handler\n        const escHandler = (e) => {\n            if (e.key === 'Escape') {\n                buttons[1].click(); // Trigger cancel button\n                document.removeEventListener('keydown', escHandler);\n            }\n        };\n        document.addEventListener('keydown', escHandler);\n\n        // Scroll to dialog\n        this.resultsContainer.scrollTop = this.resultsContainer.scrollHeight;\n    }\n\n    showInputDialog(config, callback) {\n        const dialogId = 'input_dialog_' + config.requestId;\n        \n        // Create dialog HTML\n        const dialogHTML = `\n            <div class=\"cc-dialog\" data-dialog-id=\"${dialogId}\">\n                <div class=\"cc-dialog-content\">\n                    ${config.prompt ? `<p>${config.prompt}</p>` : ''}\n                    <div class=\"cc-input-group\">\n                        <label>${config.name}:</label>\n                        <input type=\"${config.type}\" \n                               name=\"${config.name}\"\n                               class=\"cc-dialog-input\"\n                               value=\"${config.defaultValue || ''}\"\n                               placeholder=\"${config.name}\">\n                    </div>\n                    <div class=\"cc-dialog-buttons\">\n                        <button class=\"cc-button confirm\">Submit</button>\n                        <button class=\"cc-button cancel\">Cancel</button>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        // Add dialog to results container\n        const dialogElement = document.createElement('div');\n        dialogElement.innerHTML = dialogHTML;\n        this.resultsContainer.appendChild(dialogElement);\n        \n        // Track this dialog\n        this.activeDialogs.set(dialogId, {\n            element: dialogElement,\n            config: config,\n            callback: callback\n        });\n\n        // Add event listeners\n        const input = dialogElement.querySelector('.cc-dialog-input');\n        const confirmBtn = dialogElement.querySelector('.confirm');\n        const cancelBtn = dialogElement.querySelector('.cancel');\n\n        const submitDialog = () => {\n            this.postMessage({\n                type: 'CB_DIALOG_RETURN',\n                payload: {\n                    tool_call_id: config.tool_call_id,\n                    requestId: config.requestId,\n                    input: input.value\n                }\n            });\n            this.handleDialogResponse(input.value, dialogId);\n        };\n\n        // Add keydown event listener for Enter key\n        input.addEventListener('keydown', (e) => {\n            if (e.key === 'Enter') {\n                e.preventDefault();\n                submitDialog();\n            }\n        });\n\n        confirmBtn.addEventListener('click', submitDialog);\n\n        cancelBtn.addEventListener('click', () => {\n            this.postMessage({\n                type: 'CB_DIALOG_RETURN',\n                payload: {\n                    tool_call_id: config.tool_call_id,\n                    input: null\n                }\n            });\n            this.handleDialogResponse(null, dialogId);\n        });\n\n        // Focus input\n        input.focus();\n\n        // Scroll to dialog\n        this.resultsContainer.scrollTop = this.resultsContainer.scrollHeight;\n    }\n\n    handleDialogResponse(response, dialogId) {\n        const dialog = this.activeDialogs.get(dialogId);\n        if (dialog) {\n            if (dialog.callback) {\n                dialog.callback(response);\n            }\n            dialog.element.remove();\n            this.activeDialogs.delete(dialogId);\n        }\n\n        // Focus the main input only if no more dialogs are active\n        if (this.activeDialogs.size === 0) {\n            this.input.focus();\n        } else {\n            // Focus the next dialog's input\n            const nextDialog = Array.from(this.activeDialogs.values())[0];\n            if (nextDialog) {\n                const nextInput = nextDialog.element.querySelector('.cc-dialog-input');\n                if (nextInput) nextInput.focus();\n            }\n        }\n    }\n\n    // Add new methods to handle command history persistence\n    async loadCommandHistory() {\n      try {\n        this.postMessage({ \n          type: \"GET_COMMAND_HISTORY\",\n          payload: {\n            encrypted: true,\n            hostname: window.location.hostname\n          }\n        });\n      } catch (error) {\n        ccLogger.error('Error loading command history:', error);\n      }\n    }\n\n    async saveCommandHistory() {\n      try {\n        this.postMessage({ \n          type: \"SAVE_COMMAND_HISTORY\", \n          payload: {\n            history: this.commandHistory,\n            encrypted: true,\n            hostname: window.location.hostname\n          }\n        });\n      } catch (error) {\n        ccLogger.error('Error saving command history:', error);\n      }\n    }\n\n    showAutocompleteSuggestion(input, suggestion) {\n      // If suggestion contains a nested array of suggestions, extract it\n      if (suggestion?.payload?.text && Array.isArray(suggestion.payload.text)) {\n        const suggestionsWithId = suggestion.payload.text.map(s => ({\n          text: s.text,\n          requestId: this.autocomplete.currentAutocompleteRequestId\n        }));\n        this.autocomplete.showSuggestion(input, suggestionsWithId);\n        return;\n      }\n\n      // If suggestion is an array of text objects, pass it directly\n      if (Array.isArray(suggestion)) {\n        // Add the current requestId to the array of suggestions\n        const suggestionsWithId = suggestion.map(s => ({\n          text: s.text,\n          requestId: this.autocomplete.currentAutocompleteRequestId\n        }));\n        this.autocomplete.showSuggestion(input, suggestionsWithId);\n        return;\n      }\n\n      // If it's a single suggestion, convert it to our new format\n      if (suggestion && suggestion.text) {\n        this.autocomplete.showSuggestion(input, [{\n          text: suggestion.text,\n          requestId: suggestion.requestId || this.autocomplete.currentAutocompleteRequestId\n        }]);\n      }\n    }\n\n    async checkOllamaAvailability(interval = 1000, maxCount = -1) {\n      ccLogger.time('ollamaCheck');\n      var fastCheck = true;\n      let count = 0;\n      if (!this.ollamaCheckInterval) {\n        this.ollamaCheckInterval = setInterval(async () => {\n          count++;\n          if(maxCount > 0 && count > maxCount && !this.hasNoAIMode){\n            ccLogger.debug('Ollama check complete', { count: count - 1 });\n            clearInterval(this.ollamaCheckInterval);\n            this.ollamaCheckInterval = null;\n            return;\n          }\n          try {\n            ccLogger.debug('Checking Ollama availability', { noAIMode: this.hasNoAIMode });\n            this.postMessage({ \n              type: \"CHECK_OLLAMA_AVAILABLE\",\n              payload: {\n                noAIMode: this.hasNoAIMode\n              }\n            });\n            \n\n          } catch (error) {\n            ccLogger.error('Ollama check failed:', error);\n          }\n        }, interval);\n      }\n      ccLogger.timeEnd('ollamaCheck');\n    }\n\n    updateProviderStatus(provider, isConnected) {\n      ccLogger.debug('PROVIDER_STATUS_UPDATE', provider, isConnected);\n      \n      if (provider.startsWith('mcp:')) {\n        // Handle MCP provider badges\n        const mcpBadgesContainer = this.container.querySelector('.cc-mcp-badges');\n        let badge = mcpBadgesContainer.querySelector(`[data-provider=\"${provider}\"]`);\n        \n        if (!badge) {\n          badge = document.createElement('div');\n          badge.classList.add('cc-provider-badge');\n          badge.setAttribute('data-provider', provider);\n          badge.textContent = provider.substring(4); // Remove 'mcp:' prefix\n          mcpBadgesContainer.appendChild(badge);\n        }\n        \n        if (isConnected) {\n          badge.setAttribute('data-status', 'connected');\n          this.connectedProviders.add(provider);\n        } else {\n          badge.removeAttribute('data-status');\n          this.connectedProviders.delete(provider);\n        }\n      } else {\n        // Handle regular provider badges\n        const badge = this.container.querySelector(`.cc-provider-badge[data-provider=\"${provider}\"]`);\n        if (badge) {\n          if (isConnected) {\n            // Check if the provider is temporarily disabled\n            if (this.disabledProviders && this.disabledProviders.has(provider)) {\n              badge.setAttribute('data-status', 'disabled');\n            } else {\n              badge.setAttribute('data-status', 'connected');\n            }\n            this.connectedProviders.add(provider);\n          } else {\n            badge.removeAttribute('data-status');\n            this.connectedProviders.delete(provider);\n          }\n        }\n      }\n\n      if(!this.addedOllamaReminder && this.connectedProviders.has('ollama') && !this.connectedProviders.has('openai')) {\n        this.addedOllamaReminder = true;\n        this.messages.push({\n          role: 'system',\n          content: `Call the set_openai_key tool to connect to OpenAI if the user provides a key.`\n        });\n      }\n\n      // Update the status in the no-provider view if it exists\n      const statusList = document.querySelectorAll('.provider-status li');\n      const statusElement = Array.from(statusList).find(li => \n        li.textContent.toLowerCase().includes(provider.toLowerCase())\n      );\n      \n      if (statusElement) {\n        const indicator = statusElement.querySelector('.status-indicator');\n        if (indicator) {\n          indicator.textContent = isConnected ? 'Connected' : 'Not Connected';\n          indicator.style.color = isConnected ? '#2ecc71' : '#ff9999';\n          if (isConnected) {\n            indicator.classList.add('connected');\n          } else {\n            indicator.classList.remove('connected');\n          }\n        }\n      }\n    }\n\n    showModelDownloadProgress(progress) {\n        let progressContainer = this.container.querySelector('.cc-model-download-progress');\n        if (!progressContainer) {\n            progressContainer = document.createElement('div');\n            progressContainer.classList.add('cc-model-download-progress');\n            this.resultsContainer.appendChild(progressContainer);\n        }\n\n        // Create or update progress element\n        let progressElement = progressContainer.querySelector(`[data-phase=\"${progress.phase}\"]`);\n        if (!progressElement) {\n            progressElement = document.createElement('div');\n            progressElement.classList.add('cc-download-item');\n            progressElement.setAttribute('data-phase', progress.phase);\n            progressContainer.appendChild(progressElement);\n        }\n\n        // Update progress content\n        let progressHtml = '';\n        if (progress.phase === 'download' && progress.detail) {\n            const downloaded = this.formatBytes(progress.detail.downloaded);\n            const total = this.formatBytes(progress.detail.total);\n            progressHtml = `\n                <div class=\"download-header\">\n                    <span class=\"status-text\">${progress.status}</span>\n                    <span class=\"progress-text\">${downloaded} / ${total}</span>\n                </div>\n                <div class=\"progress-bar-container\">\n                    <div class=\"progress-bar\" style=\"width: ${progress.progress}%\"></div>\n                </div>\n            `;\n        } else {\n            progressHtml = `\n                <div class=\"download-header\">\n                    <span class=\"status-text\">${progress.status}</span>\n                    <span class=\"progress-text\">${progress.progress}%</span>\n                </div>\n                <div class=\"progress-bar-container\">\n                    <div class=\"progress-bar\" style=\"width: ${progress.progress}%\"></div>\n                </div>\n            `;\n        }\n        progressElement.innerHTML = progressHtml;\n\n        // If download is complete, schedule removal\n        if (progress.phase === 'complete') {\n            setTimeout(() => {\n                progressContainer.classList.add('fade-out');\n                setTimeout(() => {\n                    progressContainer.remove();\n                }, 1000);\n            }, 2000);\n        }\n\n        // Scroll to show progress\n        this.resultsContainer.scrollTop = this.resultsContainer.scrollHeight;\n    }\n\n    formatBytes(bytes) {\n        if (!bytes) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;\n    }\n\n    cleanup() {\n      if (this.mcpStatusInterval) {\n        clearInterval(this.mcpStatusInterval);\n        this.mcpStatusInterval = null;\n      }\n      // Disconnect all MCP services permanently during cleanup\n      this.mcpToolCaller.getMCPServices().forEach(service => {\n        this.mcpToolCaller.disconnectMCPService(service.id, true);\n      });\n    }\n\n    setupToolList() {\n        const toolCountEl = this.container.querySelector('.cc-tool-count');\n        const toolList = this.container.querySelector('.cc-tool-list');\n        const closeButton = toolList.querySelector('.cc-tool-list-close');\n        const toolListContent = toolList.querySelector('.cc-tool-list-content');\n\n        // Toggle tool list on tool count click\n        toolCountEl.addEventListener('click', (e) => {\n            e.stopPropagation();\n            this.toggleToolList();\n        });\n\n        // Close tool list when clicking close button\n        closeButton.addEventListener('click', (e) => {\n            e.stopPropagation();\n            this.hideToolList();\n        });\n\n        // Close tool list when clicking outside\n        document.addEventListener('click', (e) => {\n            if (!toolList.contains(e.target) && !toolCountEl.contains(e.target)) {\n                this.hideToolList();\n            }\n        });\n\n        // Handle tool item clicks\n        toolListContent.addEventListener('click', (e) => {\n            const toolItem = e.target.closest('.cc-tool-item');\n            if (toolItem) {\n                const toolName = toolItem.getAttribute('data-tool-name');\n                if (toolName) {\n                    this.input.value = toolName;\n                    this.input.focus();\n                    this.hideToolList();\n                }\n            }\n        });\n\n        // Populate tool list\n        this.updateToolList();\n    }\n\n    updateToolList() {\n        const toolListContent = this.container.querySelector('.cc-tool-list-content');\n        const localTools = this.toolCaller.getTools(true);\n        const mcpTools = Array.from(this.mcpToolCaller.mcpToolsets.values())\n            .reduce((tools, toolset) => tools.concat(toolset.tools), []);\n        \n        // Group tools by source\n        const toolsHtml = `\n            <div class=\"cc-tool-group\">\n                <div class=\"cc-tool-group-header\">Local Tools (${localTools.length})</div>\n                ${localTools.map(tool => this.renderToolItem(tool, 'local')).join('')}\n            </div>\n            ${mcpTools.length > 0 ? `\n                <div class=\"cc-tool-group\">\n                    <div class=\"cc-tool-group-header\">MCP Tools (${mcpTools.length})</div>\n                    ${mcpTools.map(tool => this.renderToolItem(tool, 'mcp')).join('')}\n                </div>\n            ` : ''}\n        `;\n        \n        toolListContent.innerHTML = toolsHtml;\n    }\n\n    renderToolItem(tool, source) {\n        return `\n            <div class=\"cc-tool-item\" data-tool-name=\"${tool.name}\" data-source=\"${source}\">\n                <div class=\"cc-tool-item-name\">${tool.name}</div>\n                <div class=\"cc-tool-item-description\">${tool.description}</div>\n            </div>\n        `;\n    }\n\n    toggleToolList() {\n        const toolList = this.container.querySelector('.cc-tool-list');\n        if (toolList.classList.contains('visible')) {\n            this.hideToolList();\n        } else {\n            this.showToolList();\n        }\n    }\n\n    showToolList() {\n        const toolList = this.container.querySelector('.cc-tool-list');\n        toolList.classList.add('visible');\n        // Update tool list content when showing\n        this.updateToolList();\n    }\n\n    hideToolList() {\n        const toolList = this.container.querySelector('.cc-tool-list');\n        toolList.classList.remove('visible');\n    }\n\n    showKeybindDialog() {\n      this.settings.showKeybindDialog(this.resultsContainer, (newKeybind) => {\n        this.keybind = newKeybind;\n      });\n    }\n\n    showSettingsDialog() {\n      this.settings.showSettingsDialog(this.resultsContainer, this);\n    }\n\n    async addSystemPrompt() {\n      ccLogger.group('System Prompt Generation');\n      \n      // Build base system prompt\n      let systemPrompt = `This is a smart chat bar a popup inside ${this.currentApp}. It can be used to ask questions, get help, and perform tasks.`;\n      systemPrompt += ' The current date and time is ' + new Date().toLocaleString();\n      systemPrompt += '. You can use the tools to perform tasks, chain them together to build context, and perform complex tasks.';\n      \n      // Add custom system prompt from settings if available\n      if (this.settings.systemPrompt) {\n          systemPrompt += '\\n\\Custom User Instructions:\\n' + this.settings.systemPrompt;\n      }\n\n      // Add hostname-specific prompt if available\n      const currentHostname = window.location.hostname;\n      if (this.settings.hostnamePrompts && this.settings.hostnamePrompts.has(currentHostname)) {\n          systemPrompt += `\\n\\nHost-Specific Instructions: ${currentHostname} - ${this.settings.hostnamePrompts.get(currentHostname)}`;\n      }\n\n      // Get system prompts from both local and MCP tools\n      ccLogger.debug('Building system prompt with tools');\n      \n      // First get the tool scope\n      const scope = await this.toolCaller.getToolScope(this);\n      \n      // Then build the system prompt with the scope\n      systemPrompt = await this.toolCaller.buildSystemPrompt(systemPrompt, scope);\n      \n      // Add MCP-specific system prompts\n      for (const [serviceId, client] of this.mcpToolCaller.mcpClients.entries()) {\n          try {\n              if (client.getSystemPrompt) {\n                  systemPrompt = await client.getSystemPrompt(systemPrompt);\n              }\n          } catch (error) {\n              ccLogger.error(`Error getting MCP system prompt for ${serviceId}:`, error);\n          }\n      }\n\n      this.messages.push({\n          role: 'system',\n          content: systemPrompt\n      });\n      \n      ccLogger.debug('Final system prompt:', systemPrompt);\n      ccLogger.groupEnd();\n    }\n\n    // Modify postMessage helper method to use secure messaging\n    async postMessage(message) {\n      // If we don't have an auth token yet and this isn't a settings request, queue the message\n      if (!this.authTokenInitialized && message.type !== 'GET_SETTINGS') {\n        this.messageQueue.push(message);\n        return;\n      }\n\n      // Generate a unique message ID\n      const messageId = `${Date.now()}-${Math.random()}`;\n      this.pendingSecureMessages.add(messageId);\n\n      // Prefix all carbonbar messages to identify them\n      const carbonMessage = {\n        ...message,\n        type: (message.type.startsWith('CARBON_') || message.type.startsWith('CB_')) ? message.type : 'CARBON_' + message.type,\n        tabId: window.tabId,\n        authToken: this.authToken,\n        _messageId: messageId\n      };\n\n      ccLogger.debug('Sending message:', carbonMessage);\n\n      // Use the secure messaging system\n      const promise = window.postMessage(carbonMessage, window.location.origin);\n\n      // Process queued messages if initialization is complete\n      if (this.initializationComplete && this.messageQueue.length > 0) {\n        while (this.messageQueue.length > 0) {\n          const queuedMessage = this.messageQueue.shift();\n          this.postMessage(queuedMessage);\n        }\n      }\n      return promise;\n    }\n\n    // Add method to handle settings loaded\n    handleSettingsLoaded(settings) {\n      if (settings._authToken) {\n        //this.authToken = settings._authToken;\n        //this.authTokenInitialized = true;\n        //ccLogger.debug('[SECURITYDEBUG] AUTH_TOKEN_INITIALIZED.settings', this.authToken);\n        \n        // Process any queued messages now that we have the auth token\n        while (this.messageQueue.length > 0) {\n          const message = this.messageQueue.shift();\n          this.postMessage(message);\n        }\n        \n        this.initializationComplete = true;\n      }\n    }\n\n    handleAccessRequest(message) {\n        ccLogger.debug('handleAccessRequest', message);\n        if(message.payload?.payload) {\n            message.payload = message.payload.payload;\n        }\n        if (!message?.payload) {\n            ccLogger.error('Invalid access request message:', message);\n            return;\n        }\n\n        const { requestId, prompt } = message.payload;\n        if (!requestId) {\n            ccLogger.error('No requestId provided in access request');\n            return;\n        }\n\n        // Generate dialog HTML if not provided\n        const dialogHtml = message.payload.dialogHtml || `\n            <div class=\"cc-dialog\">\n                <div class=\"cc-dialog-content\">\n                    <p>${prompt || 'Allow access to this feature?'}</p>\n                    <div class=\"cc-dialog-buttons\">\n                        <button class=\"cc-button confirm\" data-action=\"confirm\">Allow</button>\n                        <button class=\"cc-button cancel\" data-action=\"cancel\">Deny</button>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        // Create a new result item for the dialog\n        const resultContainer = document.createElement('div');\n        resultContainer.classList.add('cc-result-item');\n        this.resultsContainer.appendChild(resultContainer);\n\n        // Insert the dialog HTML into the result container\n        resultContainer.innerHTML = dialogHtml;\n        const dialog = resultContainer.querySelector('.cc-dialog');\n        if (!dialog) {\n            ccLogger.error('Failed to create dialog element');\n            resultContainer.remove();\n            return;\n        }\n\n        // Add click handlers for buttons\n        const buttons = dialog.querySelectorAll('.cc-button');\n        if (!buttons || buttons.length === 0) {\n            ccLogger.error('No buttons found in dialog');\n            resultContainer.remove();\n            return;\n        }\n\n        buttons.forEach(button => {\n            button.addEventListener('click', () => {\n                const action = button.dataset.action;\n                const confirmed = action === 'confirm';\n\n                // Animate dialog out\n                dialog.style.animation = 'messageAppear 0.3s ease-in-out reverse';\n                \n                setTimeout(() => {\n                    // Remove the dialog\n                    resultContainer.remove();\n\n                    // Send response through secure messaging\n                    this.postMessage({\n                        type: 'ACCESS_REQUEST_RESPONSE',\n                        payload: {\n                            requestId: requestId,\n                            confirmed: confirmed\n                        }\n                    });\n                }, 300); // Match animation duration\n            });\n        });\n\n        // Add escape key handler\n        const escHandler = (e) => {\n            if (e.key === 'Escape' && resultContainer.isConnected) {\n                const cancelButton = Array.from(buttons).find(btn => btn.dataset.action === 'cancel');\n                if (cancelButton) {\n                    cancelButton.click(); // Trigger cancel button\n                }\n                document.removeEventListener('keydown', escHandler);\n            }\n        };\n        document.addEventListener('keydown', escHandler);\n\n        // Show results container if hidden\n        this.resultsContainer.style.display = 'block';\n        this.resultsContainer.classList.remove('hidden');\n\n        // Scroll to dialog\n        if (this.resultsContainer) {\n            this.resultsContainer.scrollTop = this.resultsContainer.scrollHeight;\n        }\n    }\n}\n\n\nfunction importAll(r) {\n  r.keys().forEach(r);\n}\n\nimportAll(require.context('../tools', true, /\\.js$/));\n\nexport { CarbonCommander };\nconst carbonCommander = new CarbonCommander();\nwindow.carbonCommander = carbonCommander;","import { ccLogger } from '../global.js';\nimport settings from './settings.js';\n\nclass MCPToolCaller {\n    constructor() {\n        this.currentPageTools = null;\n        this.mcpClients = new Map(); // Map of MCP client connections\n        this.mcpConfig = new Map(); // Map of MCP service configurations\n        this.mcpToolsets = new Map(); // Map of MCP-provided toolsets\n        this.reconnectInterval = null;\n        this.refreshInProgress = false; // Flag to prevent concurrent refresh operations\n        this.startReconnectInterval();\n        \n        // Load saved configurations on startup\n        this.loadSavedConfigurations().catch(error => {\n            ccLogger.error('Failed to load saved MCP configurations:', error);\n        });\n    }\n\n    startReconnectInterval() {\n        // Check connections every 30 seconds\n        this.reconnectInterval = setInterval(async () => {\n            // Skip if a refresh operation is already in progress\n            if (this.refreshInProgress) {\n                ccLogger.debug('Skipping MCP connection refresh - another refresh operation is in progress');\n                return;\n            }\n            \n            try {\n                this.refreshInProgress = true;\n                await this.refreshMCPConnections();\n            } catch (error) {\n                ccLogger.error('Error during MCP connection refresh:', error);\n            } finally {\n                this.refreshInProgress = false;\n            }\n        }, 30000);\n    }\n\n    stopReconnectInterval() {\n        if (this.reconnectInterval) {\n            clearInterval(this.reconnectInterval);\n            this.reconnectInterval = null;\n        }\n    }\n\n    // MCP-specific methods\n    async configureMCPService(serviceConfig) {\n        const { serviceId, endpoint, apiKey, options = {} } = serviceConfig;\n        \n        ccLogger.debug(`Configuring MCP service: ${serviceId}`);\n        \n        try {\n            const config = {\n                endpoint,\n                apiKey,\n                options,\n                status: 'configured',\n                toolsets: [] // Will store toolsets provided by this service\n            };\n\n            this.mcpConfig.set(serviceId, config);\n            \n            // Save configuration to settings\n            settings.mcpConfigurations.set(serviceId, {\n                endpoint,\n                apiKey,\n                options\n            });\n            await settings.save();\n            \n            // Initialize client connection if autoConnect is true\n            if (options.autoConnect) {\n                await this.connectMCPService(serviceId);\n            }\n            \n            return true;\n        } catch (error) {\n            ccLogger.error(`Error configuring MCP service ${serviceId}:`, error);\n            return false;\n        }\n    }\n\n    async loadSavedConfigurations() {\n        ccLogger.debug('Loading saved MCP configurations');\n        for (const [serviceId, config] of settings.mcpConfigurations.entries()) {\n            try {\n                await this.configureMCPService({\n                    serviceId,\n                    ...config\n                });\n            } catch (error) {\n                ccLogger.error(`Error loading saved MCP configuration for ${serviceId}:`, error);\n            }\n        }\n    }\n\n    async connectMCPService(serviceId, retryCount = 3, retryDelay = 1000) {\n        ccLogger.debug(`Connecting to MCP service: ${serviceId}`);\n        \n        const config = this.mcpConfig.get(serviceId);\n        if (!config) {\n            throw new Error(`MCP service ${serviceId} not configured`);\n        }\n\n        let lastError = null;\n        for (let attempt = 1; attempt <= retryCount; attempt++) {\n            try {\n                // Initialize MCP client connection with enhanced capabilities\n                const client = {\n                    serviceId,\n                    endpoint: config.endpoint,\n                    connected: true,\n                    // Enhanced client methods\n                    callFunction: async (functionName, args) => {\n                        return await this.mcpCallFunction(serviceId, functionName, args);\n                    },\n                    discoverTools: async () => {\n                        return await this.discoverMCPTools(serviceId);\n                    },\n                    getSystemPrompt: async (basePrompt, scope) => {\n                        return await this.getMCPSystemPrompt(serviceId, basePrompt, scope);\n                    }\n                };\n\n                this.mcpClients.set(serviceId, client);\n                config.status = 'connected';\n\n                // Discover available tools after connection\n                await this.discoverMCPTools(serviceId);\n                \n                return true;\n            } catch (error) {\n                lastError = error;\n                ccLogger.warn(`Connection attempt ${attempt} failed for MCP service ${serviceId}:`, error);\n                \n                if (attempt < retryCount) {\n                    ccLogger.debug(`Retrying in ${retryDelay}ms...`);\n                    await new Promise(resolve => setTimeout(resolve, retryDelay));\n                }\n            }\n        }\n\n        // If all retries failed, update status and throw error\n        ccLogger.error(`Failed to connect to MCP service ${serviceId} after ${retryCount} attempts:`, lastError);\n        config.status = 'error';\n        config.lastError = lastError.message;\n        return false;\n    }\n\n    async discoverMCPTools(serviceId) {\n        const client = this.mcpClients.get(serviceId);\n        if (!client) {\n            throw new Error(`MCP client ${serviceId} not connected`);\n        }\n\n        try {\n            // Call the MCP service's tool discovery endpoint\n            const response = await fetch(`${client.endpoint}/discover-tools`, {\n                method: 'GET',\n                headers: {\n                    'Authorization': `Bearer ${this.mcpConfig.get(serviceId).apiKey}`\n                }\n            });\n\n            if (!response.ok) {\n                throw new Error(`Tool discovery failed: ${response.statusText}`);\n            }\n\n            const toolsets = await response.json();\n            \n            // Process and store discovered toolsets\n            toolsets.forEach(toolset => {\n                // Add MCP-specific wrapper around toolset\n                const wrappedToolset = this.wrapMCPToolset(serviceId, toolset);\n                this.mcpToolsets.set(`${serviceId}:${toolset.name}`, wrappedToolset);\n            });\n\n            return toolsets;\n        } catch (error) {\n            ccLogger.error(`Error discovering tools for ${serviceId}:`, error);\n            throw error;\n        }\n    }\n\n    wrapMCPToolset(serviceId, toolset) {\n        // Create a wrapper that maintains compatibility with local toolsets\n        return {\n            name: `${serviceId}:${toolset.name}`,\n            toolSet: {\n                ...toolset,\n                _CarbonBarPageLoadFilter: toolset.pageLoadFilter || (() => true),\n                _CarbonBarBuildScope: async (scope) => {\n                    // Call MCP service for scope building if supported\n                    try {\n                        const client = this.mcpClients.get(serviceId);\n                        const response = await fetch(`${client.endpoint}/build-scope`, {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json',\n                                'Authorization': `Bearer ${this.mcpConfig.get(serviceId).apiKey}`\n                            },\n                            body: JSON.stringify({ scope })\n                        });\n                        \n                        if (response.ok) {\n                            const customScope = await response.json();\n                            return { ...scope, ...customScope };\n                        }\n                    } catch (error) {\n                        ccLogger.error(`Error building MCP scope for ${serviceId}:`, error);\n                    }\n                    return scope;\n                },\n                _CarbonBarSystemPrompt: async (basePrompt, scope) => {\n                    // Call MCP service for system prompt customization if supported\n                    try {\n                        const client = this.mcpClients.get(serviceId);\n                        const response = await fetch(`${client.endpoint}/system-prompt`, {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json',\n                                'Authorization': `Bearer ${this.mcpConfig.get(serviceId).apiKey}`\n                            },\n                            body: JSON.stringify({ basePrompt, scope })\n                        });\n                        \n                        if (response.ok) {\n                            const { customPrompt } = await response.json();\n                            return customPrompt || basePrompt;\n                        }\n                    } catch (error) {\n                        ccLogger.error(`Error getting MCP system prompt for ${serviceId}:`, error);\n                    }\n                    return basePrompt;\n                }\n            },\n            tools: toolset.tools.map(tool => ({\n                function: {\n                    name: tool.name,\n                    description: tool.description,\n                    parameters: tool.parameters\n                },\n                execute: async (scope, args) => {\n                    return await this.mcpCallFunction(serviceId, tool.name, args);\n                }\n            }))\n        };\n    }\n\n    async disconnectMCPService(serviceId, permanent = false) {\n        ccLogger.debug(`Disconnecting from MCP service: ${serviceId}${permanent ? ' (permanent)' : ' (temporary)'}`);\n        \n        const client = this.mcpClients.get(serviceId);\n        if (client) {\n            try {\n                // Remove all toolsets from this service\n                for (const [toolsetId, toolset] of this.mcpToolsets.entries()) {\n                    if (toolsetId.startsWith(`${serviceId}:`)) {\n                        this.mcpToolsets.delete(toolsetId);\n                    }\n                }\n\n                // Cleanup client connection\n                this.mcpClients.delete(serviceId);\n                const config = this.mcpConfig.get(serviceId);\n                if (config) {\n                    config.status = 'disconnected';\n                }\n\n                // Remove from settings only if permanent\n                if (permanent) {\n                    settings.mcpConfigurations.delete(serviceId);\n                    await settings.save();\n                }\n\n                return true;\n            } catch (error) {\n                ccLogger.error(`Error disconnecting from MCP service ${serviceId}:`, error);\n                return false;\n            }\n        }\n        return false;\n    }\n\n    async mcpCallFunction(serviceId, functionName, args, timeout = 30000) {\n        const client = this.mcpClients.get(serviceId);\n        if (!client) {\n            throw new Error(`MCP client ${serviceId} not connected`);\n        }\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n        try {\n            const response = await fetch(`${client.endpoint}/execute`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.mcpConfig.get(serviceId).apiKey}`\n                },\n                body: JSON.stringify({\n                    function: functionName,\n                    arguments: args\n                }),\n                signal: controller.signal\n            });\n\n            if (!response.ok) {\n                throw new Error(`MCP call failed: ${response.statusText}`);\n            }\n\n            return await response.json();\n        } catch (error) {\n            if (error.name === 'AbortError') {\n                ccLogger.error(`MCP function call timed out after ${timeout}ms:`, { serviceId, functionName });\n                throw new Error(`MCP function call timed out: ${functionName}`);\n            }\n            ccLogger.error(`Error calling MCP function ${functionName}:`, error);\n            throw error;\n        } finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    // Tool management methods with MCP support\n    reset() {\n        ccLogger.debug('Resetting MCP tool caller state');\n        this.currentPageTools = null;\n        // Don't reset MCP configurations/connections unless explicitly requested\n    }\n\n    getToolSets() {\n        return [...this.getAllToolsets(), ...Array.from(this.mcpToolsets.values())];\n    }\n\n    getTools(onlyFunctionInfo = false) {        \n        ccLogger.group('Getting Tools');\n        let allTools = [];\n        \n        // Get local tools\n        let pageTools = this.getAllToolSetsForPage();\n        pageTools.forEach(toolSet => {\n            toolSet.tools.forEach(prop => {\n                allTools.push(onlyFunctionInfo ? prop.function : prop);\n            });\n        });\n        \n        // Add MCP tools\n        this.mcpToolsets.forEach(toolset => {\n            if (toolset.toolSet._CarbonBarPageLoadFilter(window)) {\n                toolset.tools.forEach(tool => {\n                    allTools.push(onlyFunctionInfo ? tool.function : tool);\n                });\n            }\n        });\n        \n        ccLogger.debug(`Found ${allTools.length} tools (including MCP tools)`);\n        ccLogger.groupEnd();\n        return allTools;\n    }\n\n    getTool(toolName, onlyFunctionInfo = false) {\n        ccLogger.debug('Getting tool:', toolName);\n        const allTools = this.getTools(onlyFunctionInfo);\n        const tool = allTools.find(tool => onlyFunctionInfo ? tool.name == toolName : tool.function.name == toolName);\n        if (!tool) {\n            ccLogger.warn(`Tool not found: ${toolName}`);\n        }\n        return tool;\n    }\n\n    async getToolScope(bar) {\n        ccLogger.group('Building Tool Scope');\n        var scope = {\n            bar: bar,\n            logMessage: (message, important = false) => {\n                if(important) {\n                    ccLogger.info('[ToolScope] ' + message);\n                } else {\n                    ccLogger.debug('[ToolScope] ' + message);\n                }\n            },\n            logError: (message) => {\n                ccLogger.error('[ToolScope] ' + message);\n            }\n        }\n\n        // Add MCP-specific scope items\n        scope.mcpServices = Array.from(this.mcpConfig.entries()).map(([id, config]) => ({\n            id,\n            status: config.status,\n            endpoint: config.endpoint\n        }));\n\n        // Apply local toolsets scope functions\n        for(let toolSet of this.getAllToolSetsForPage()) {\n            try {\n                if(toolSet.toolSet._CarbonBarBuildScope) {\n                    ccLogger.debug(`Building scope for toolset: ${toolSet.name}`);\n                    scope = await toolSet.toolSet._CarbonBarBuildScope(scope);\n                }\n            } catch (e) {\n                ccLogger.error('Error building scope:', e);\n            }\n        }\n\n        // Apply MCP toolsets scope functions\n        for(let [_, toolset] of this.mcpToolsets) {\n            try {\n                if(toolset.toolSet._CarbonBarPageLoadFilter(window) && toolset.toolSet._CarbonBarBuildScope) {\n                    ccLogger.debug(`Building scope for MCP toolset: ${toolset.name}`);\n                    scope = await toolset.toolSet._CarbonBarBuildScope(scope);\n                }\n            } catch (e) {\n                ccLogger.error('Error building MCP scope:', e);\n            }\n        }\n\n        if(!scope.appName) {\n            ccLogger.warn('No app name found in scope, using default');\n            scope.appName = 'CarbonCommander [MCP Mode]';\n        }\n        \n        ccLogger.groupEnd();\n        return scope;\n    }\n\n    getAllToolSetsForPage() {\n        if(this.currentPageTools) {\n            return this.currentPageTools;\n        }\n        \n        ccLogger.group('Getting Tool Sets for Page');\n        this.currentPageTools = this.getAllToolsets().filter(toolSet => \n            (toolSet.tools && toolSet.tools.length > 0) &&\n            (toolSet.toolSet._CarbonBarPageLoadFilter && toolSet.toolSet._CarbonBarPageLoadFilter(window))\n        );\n        \n        ccLogger.debug(`Found ${this.currentPageTools.length} tool sets for current page`);\n        ccLogger.groupEnd();\n        return this.currentPageTools;\n    }\n\n    getAllToolsets() {\n        ccLogger.group('Getting All Tool Sets');\n        const allTools = [];\n        if (window.sbaiTools) {\n            Object.entries(window.sbaiTools).forEach(([_, toolSet]) => {\n                try {\n                    let toolset = {\n                        name: toolSet.name,\n                        toolSet: toolSet,\n                        tools: Object.getOwnPropertyNames(toolSet)\n                            .filter(prop => typeof toolSet[prop] === 'object' && toolSet[prop]?.function)\n                            .map(prop => toolSet[prop])\n                    };\n\n                    ccLogger.debug('Processing toolset:', { \n                        name: toolset.name, \n                        toolCount: toolset.tools.length \n                    });\n\n                    if(toolset.tools && toolset.tools.length > 0) {\n                        allTools.push(toolset);\n                    }\n                } catch (e) {\n                    ccLogger.error(`Error getting tools from ${toolSet.name}:`, e);\n                }\n            });\n        }\n        ccLogger.debug(`Total tool sets found: ${allTools.length}`);\n        ccLogger.groupEnd();\n        return allTools;\n    }\n\n    // MCP Service management methods\n    getMCPServices() {\n        return Array.from(this.mcpConfig.entries()).map(([id, config]) => ({\n            id,\n            status: config.status,\n            endpoint: config.endpoint,\n            connected: this.mcpClients.has(id),\n            toolsets: Array.from(this.mcpToolsets.values())\n                .filter(ts => ts.name.startsWith(`${id}:`))\n                .map(ts => ts.name.substring(id.length + 1))\n        }));\n    }\n\n    getMCPServiceStatus(serviceId) {\n        const config = this.mcpConfig.get(serviceId);\n        return config ? {\n            status: config.status,\n            connected: this.mcpClients.has(serviceId),\n            lastError: config.lastError,\n            toolsets: Array.from(this.mcpToolsets.values())\n                .filter(ts => ts.name.startsWith(`${serviceId}:`))\n                .map(ts => ts.name.substring(serviceId.length + 1))\n        } : null;\n    }\n\n    async checkMCPHealth(serviceId) {\n        const client = this.mcpClients.get(serviceId);\n        if (!client) {\n            return false;\n        }\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 5000);\n\n        try {\n            const response = await fetch(`${client.endpoint}/status`, {\n                method: 'GET',\n                headers: {\n                    'Authorization': `Bearer ${this.mcpConfig.get(serviceId).apiKey}`\n                },\n                signal: controller.signal\n            });\n\n            if (!response.ok) {\n                throw new Error(`Health check failed: ${response.statusText}`);\n            }\n\n            const status = await response.json();\n            return status.healthy === true;\n        } catch (error) {\n            if (error.name === 'AbortError') {\n                ccLogger.error(`Health check timed out after 5000ms for MCP service ${serviceId}`);\n            } else {\n                ccLogger.error(`Health check failed for MCP service ${serviceId}:`, error);\n            }\n            return false;\n        } finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    async refreshMCPConnections() {\n        if (this.refreshInProgress) {\n            ccLogger.debug('Skipping MCP connection refresh - another refresh operation is in progress');\n            return [];\n        }\n\n        try {\n            this.refreshInProgress = true;\n            ccLogger.debug('Refreshing all MCP connections');\n            const results = [];\n            for (const [serviceId, config] of this.mcpConfig.entries()) {\n                // First check health of existing connection\n                if (this.mcpClients.has(serviceId)) {\n                    const isHealthy = await this.checkMCPHealth(serviceId);\n                    if (!isHealthy) {\n                        ccLogger.warn(`Unhealthy MCP service detected: ${serviceId}, attempting reconnect`);\n                        await this.disconnectMCPService(serviceId, false); // Use temporary disconnection\n                    }\n                }\n\n                // Reconnect if needed\n                if (config.status === 'connected' || config.options.autoReconnect) {\n                    results.push({\n                        serviceId,\n                        success: await this.connectMCPService(serviceId)\n                    });\n                }\n            }\n            return results;\n        } finally {\n            this.refreshInProgress = false;\n        }\n    }\n\n    cleanup() {\n        this.stopReconnectInterval();\n        this.refreshInProgress = false; // Reset the flag during cleanup\n        // Disconnect all services\n        for (const [serviceId] of this.mcpClients) {\n            this.disconnectMCPService(serviceId);\n        }\n    }\n}\n\nconst mcpToolCaller = new MCPToolCaller();\nexport default mcpToolCaller; ","/*\n * CarbonCommander - A command palette interface for quick actions\n * Copyright (C) 2025 Carbonitex\n */\n\nimport { ccLogger, ccDefaultKeybind } from '../global.js';\n\nexport class Settings {\n    constructor() {\n        ccLogger.debug('Settings constructor');\n        this._postMessageHandler = null;\n        this.systemPrompt = '';\n        this.hostnamePrompts = new Map(); // Add storage for hostname-specific prompts\n        this.keyValuePairs = new Map();\n        this.encryptedKeys = new Map(); // Track which keys are encrypted and if they have a non-empty value\n        this.keybind = ccDefaultKeybind; // Default keybind\n        this.mcpConfigurations = new Map(); // Store MCP service configurations\n        this.refreshInProgress = false; // Flag to prevent concurrent refresh operations\n        \n        // Add event listener for settings loaded\n        window.addEventListener('message', this.handleSettingsMessage.bind(this));\n    }\n\n    setPostMessageHandler(handler) {\n        this._postMessageHandler = handler;\n        this.load();\n    }\n\n    handleSettingsMessage(event) {\n        if (event.source !== window) return;\n\n        if (event.data.type === 'CARBON_GET_SETTINGS_RESPONSE') {\n            const settings = event.data.payload;\n            if (settings) {\n                this.systemPrompt = settings.systemPrompt || '';\n                this.keyValuePairs = settings.keyValuePairs || new Map();\n                this.hostnamePrompts = settings.hostnamePrompts || new Map();\n                this.mcpConfigurations = settings.mcpConfigurations || new Map();\n\n                if (settings.encryptedKeys) {\n                    this.encryptedKeys = new Map();\n                    for (const [key, value] of settings.encryptedKeys) {\n                        this.encryptedKeys.set(key, value);\n                    }\n                    // Ensure openai-key is always encrypted and exists, mark as empty by default\n                    if (!this.encryptedKeys.has('openai-key'))\n                        this.encryptedKeys.set('openai-key', false);\n                }\n            }\n        }\n\n        if (event.data.type === 'SET_KEYBIND') {\n            this.keybind = event.data.payload || ccDefaultKeybind;\n        }\n    }\n\n    async load() {\n        ccLogger.debug('Settings: load');\n        if (!this._postMessageHandler) {\n            ccLogger.error('Settings: postMessage handler not initialized');\n            return;\n        }\n\n        try {\n            // Request settings from service.js\n            this._postMessageHandler({\n                type: 'GET_SETTINGS',\n                payload: {\n                    init: true\n                }\n            });\n        } catch (error) {\n            ccLogger.error('Error loading settings:', error);\n        }\n    }\n\n    async testOpenAIKey(key) {\n        const response = await new Promise(resolve => {\n            window.postMessage({\n                type: 'CARBON_SET_OPENAI_KEY',\n                payload: { key: key, test: true }\n            }, window.location.origin);\n\n            const listener = (event) => {\n                if (event.data.type === 'SET_OPENAI_KEY_RESPONSE') {\n                    window.removeEventListener('message', listener);\n                    resolve(event.data.payload);\n                }\n            };\n            window.addEventListener('message', listener);\n        });\n        return response;\n    }\n\n    async save() {\n        if (!this._postMessageHandler) {\n            ccLogger.error('Settings: postMessage handler not initialized');\n            return;\n        }\n\n        try {\n            ccLogger.group('Saving settings');\n            // Convert Map to object for storage\n            const settingsToSave = {\n                systemPrompt: this.systemPrompt,\n                keyValuePairs: this.keyValuePairs,\n                encryptedKeys: this.encryptedKeys,\n                hostnamePrompts: this.hostnamePrompts,\n                mcpConfigurations: this.mcpConfigurations\n            };\n            \n            // Save encrypted values first\n            for (const [key, value] of this.keyValuePairs.entries()) {\n                if (this.encryptedKeys.has(key)) {\n                    const isEncryptedSet = this.encryptedKeys.get(key);\n                    if(isEncryptedSet){\n                        const hasValue = value !== null && value !== undefined && value !== '';\n                        if(hasValue){\n                            ccLogger.debug('Saving encrypted value:', key);\n                            await this._postMessageHandler({\n                                type: 'SAVE_ENCRYPTED_VALUE',\n                                payload: {\n                                    key: key,\n                                    value: value\n                                }\n                            });\n                            if(key === 'openai-key') {\n                                ccLogger.debug('Setting OpenAI key:', value);\n                                window.postMessage({\n                                    type: 'CARBON_SET_OPENAI_KEY',\n                                    payload: { key: value, save: true }\n                                }, window.location.origin);\n                            }\n                        } else {\n                            ccLogger.debug('Deleting encrypted value:', key);\n                            await this._postMessageHandler({\n                                type: 'DELETE_ENCRYPTED_VALUE',\n                                payload: {\n                                    key: key\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n\n            // Save MCP configurations with encrypted API keys\n            for (const [serviceId, config] of this.mcpConfigurations.entries()) {\n                if (config.apiKey) {\n                    ccLogger.debug(`Saving encrypted API key for MCP service: ${serviceId}`);\n                    await this._postMessageHandler({\n                        type: 'SAVE_ENCRYPTED_VALUE',\n                        payload: {\n                            key: `mcp-key-${serviceId}`,\n                            value: config.apiKey\n                        }\n                    });\n                    // Remove API key from the configuration before saving\n                    const configCopy = { ...config };\n                    delete configCopy.apiKey;\n                    this.mcpConfigurations.set(serviceId, configCopy);\n                }\n            }\n\n            //remove all encrypted keys from the keyValuePairs map\n            for(const [key, value] of this.encryptedKeys.entries()) {\n                this.keyValuePairs.delete(key);\n            }\n            \n            // Send settings to service.js for storage\n            this._postMessageHandler({\n                type: 'SAVE_SETTINGS',\n                payload: settingsToSave\n            });\n            ccLogger.groupEnd();\n        } catch (error) {\n            ccLogger.error('Error saving settings:', error);\n        }\n    }\n\n    getKeybindDisplay(kb = this.keybind) {\n        const parts = [];\n        if (kb.ctrl) parts.push('Ctrl');\n        if (kb.meta) parts.push('');\n        parts.push(kb.key.toUpperCase());\n        return parts.join(' + ');\n    }\n\n    setKeybind(newKeybind) {\n        if (!this._postMessageHandler) {\n            ccLogger.error('Settings: postMessage handler not initialized');\n            return;\n        }\n\n        this.keybind = newKeybind;\n        this._postMessageHandler({\n            type: 'SAVE_KEYBIND',\n            payload: newKeybind\n        });\n    }\n\n    showKeybindDialog(container, onKeybindChange) {\n        const dialogHTML = `\n            <div class=\"cc-dialog\">\n                <div class=\"cc-dialog-content\">\n                    <h3>Change Keybind</h3>\n                    <p>Press the key combination you want to use to open Carbon Commander.</p>\n                    <p>Current keybind: ${this.getKeybindDisplay()}</p>\n                    <div class=\"cc-keybind-input\" tabindex=\"0\">Press a key...</div>\n                    <div class=\"cc-dialog-buttons\">\n                        <button class=\"cc-button cancel\">Cancel</button>\n                        <button class=\"cc-button confirm\">Save</button>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        const dialogElement = document.createElement('div');\n        dialogElement.innerHTML = dialogHTML;\n        container.appendChild(dialogElement);\n\n        const keybindInput = dialogElement.querySelector('.cc-keybind-input');\n        let newKeybind = null;\n\n        keybindInput.addEventListener('keydown', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n\n            // Only allow modifier keys with a regular key\n            if (e.key.length === 1 || e.key.match(/^[a-zA-Z0-9]$/)) {\n                newKeybind = {\n                    key: e.key.toLowerCase(),\n                    ctrl: e.ctrlKey,\n                    meta: e.metaKey\n                };\n                keybindInput.textContent = this.getKeybindDisplay(newKeybind);\n            }\n        });\n\n        const confirmBtn = dialogElement.querySelector('.confirm');\n        const cancelBtn = dialogElement.querySelector('.cancel');\n\n        confirmBtn.addEventListener('click', () => {\n            if (newKeybind) {\n                this.setKeybind(newKeybind);\n                if (onKeybindChange) {\n                    onKeybindChange(newKeybind);\n                }\n            }\n            dialogElement.remove();\n        });\n\n        cancelBtn.addEventListener('click', () => {\n            dialogElement.remove();\n        });\n\n        keybindInput.focus();\n        return dialogElement;\n    }\n\n    showKeybindDialogInSettings(dialog, onKeybindChange) {\n        const keybindDialog = document.createElement('div');\n        keybindDialog.classList.add('cc-dialog');\n        keybindDialog.innerHTML = `\n            <div class=\"cc-dialog-content\">\n                <h3>Change Keybind</h3>\n                <p>Press the key combination you want to use to open Carbon Commander.</p>\n                <p>Current keybind: ${this.getKeybindDisplay()}</p>\n                <div class=\"cc-keybind-input\" tabindex=\"0\">Press a key...</div>\n                <div class=\"cc-dialog-buttons\">\n                    <button class=\"cc-button cancel\">Cancel</button>\n                    <button class=\"cc-button confirm\">Save</button>\n                </div>\n            </div>\n        `;\n\n        dialog.appendChild(keybindDialog);\n\n        const keybindInput = keybindDialog.querySelector('.cc-keybind-input');\n        let newKeybind = null;\n\n        keybindInput.addEventListener('keydown', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n\n            // Only allow modifier keys with a regular key\n            if (e.key.length === 1 || e.key.match(/^[a-zA-Z0-9]$/)) {\n                newKeybind = {\n                    key: e.key.toLowerCase(),\n                    ctrl: e.ctrlKey,\n                    meta: e.metaKey\n                };\n                keybindInput.textContent = this.getKeybindDisplay(newKeybind);\n            }\n        });\n\n        const confirmKeybindBtn = keybindDialog.querySelector('.confirm');\n        const cancelKeybindBtn = keybindDialog.querySelector('.cancel');\n\n        confirmKeybindBtn.addEventListener('click', () => {\n            if (newKeybind) {\n                this.setKeybind(newKeybind);\n                if (onKeybindChange) {\n                    onKeybindChange(newKeybind);\n                }\n            }\n            keybindDialog.remove();\n        });\n\n        cancelKeybindBtn.addEventListener('click', () => {\n            keybindDialog.remove();\n        });\n\n        keybindInput.focus();\n    }\n\n    showSettingsDialog(container, carbonCommander) {\n        const overlay = document.createElement('div');\n        overlay.classList.add('cc-settings-overlay');\n        \n        const dialog = document.createElement('div');\n        dialog.classList.add('cc-settings-dialog');\n        \n        dialog.innerHTML = `\n            <h2>Settings</h2>\n            \n            <div class=\"cc-settings-section\">\n                <h3>System Prompt</h3>\n                <div class=\"cc-settings-field\">\n                    <label>Global system prompt (applies to all hosts):</label>\n                    <textarea id=\"system-prompt\">${this.systemPrompt || ''}</textarea>\n                </div>\n            </div>\n\n            <div class=\"cc-settings-section hostname-prompts-section\">\n                <h3>Host-Specific System Prompts</h3>\n                <div class=\"cc-settings-field\">\n                    <table class=\"cc-key-value-table hostname-prompts-table\">\n                        <thead>\n                            <tr>\n                                <th>Hostname</th>\n                                <th>System Prompt</th>\n                                <th>Actions</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            ${Array.from(this.hostnamePrompts || []).map(([hostname, prompt]) => `\n                                <tr>\n                                    <td><input type=\"text\" value=\"${hostname}\" class=\"hostname-key\"></td>\n                                    <td><textarea class=\"hostname-prompt\">${prompt}</textarea></td>\n                                    <td>\n                                        <button class=\"cc-button delete-hostname-prompt\">Delete</button>\n                                    </td>\n                                </tr>\n                            `).join('')}\n                        </tbody>\n                    </table>\n                    <div class=\"cc-key-value-actions\">\n                        <button class=\"cc-button\" id=\"add-hostname-prompt\">Add Host-Specific Prompt</button>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"cc-settings-section\">\n                <h3>Keyboard Shortcuts</h3>\n                <div class=\"cc-settings-field-group\">\n                    <div class=\"cc-settings-field\">\n                        <label>Command palette shortcut:</label>\n                        <div class=\"cc-keybind-display\">${this.getKeybindDisplay()}</div>\n                        <button class=\"cc-button\" id=\"change-keybind\">Change Shortcut</button>\n                    </div>\n\n                    <div class=\"cc-settings-field command-history-section\">\n                        <label>Command History Management:</label>\n                        <div class=\"cc-command-history-list\">\n                            <select id=\"hostname-select\" class=\"cc-select\">\n                                <option value=\"\">Select hostname...</option>\n                            </select>\n                            <button class=\"cc-button\" id=\"clear-history\">Clear History</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n            <div class=\"cc-settings-section\">\n                <h3>MCP Services</h3>\n                <div class=\"cc-settings-field\">\n                    <table class=\"cc-key-value-table mcp-services-table\">\n                        <thead>\n                            <tr>\n                                <th>Service ID</th>\n                                <th>Endpoint</th>\n                                <th>API Key</th>\n                                <th>Status</th>\n                                <th>Actions</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            ${Array.from(this.mcpConfigurations || []).map(([serviceId, config]) => `\n                                <tr>\n                                    <td><input type=\"text\" value=\"${serviceId}\" class=\"mcp-service-id\" readonly></td>\n                                    <td><input type=\"text\" value=\"${config.endpoint}\" class=\"mcp-endpoint\"></td>\n                                    <td>\n                                        <div class=\"encrypted-value\">\n                                            ${config.apiKey ? '' : '<span style=\"color: #ff9999; font-style: italic;\">Not Set</span>'}\n                                        </div>\n                                        <button class=\"cc-button update-mcp-key\">Update Key</button>\n                                    </td>\n                                    <td>\n                                        <span class=\"mcp-status ${config.status || 'disconnected'}\">${config.status || 'disconnected'}</span>\n                                    </td>\n                                    <td>\n                                        <button class=\"cc-button delete-mcp-service\">Delete</button>\n                                        <button class=\"cc-button toggle-mcp-service\">${config.status === 'connected' ? 'Disconnect' : 'Connect'}</button>\n                                    </td>\n                                </tr>\n                            `).join('')}\n                        </tbody>\n                    </table>\n                    <div class=\"cc-key-value-actions\">\n                        <button class=\"cc-button\" id=\"add-mcp-service\">Add MCP Service</button>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"cc-settings-section key-value-pairs-section\">\n                <h3>Configuration Key-Value Pairs</h3>\n                <div class=\"cc-settings-field\">\n                    <table class=\"cc-key-value-table key-value-pairs-table\">\n                        <thead>\n                            <tr>\n                                <th>Key</th>\n                                <th>Value</th>\n                                <th>Encrypted</th>\n                                <th>Actions</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            ${Array.from(this.encryptedKeys).map(([key, hasValue]) => `\n                                <tr>\n                                    <td><input type=\"text\" value=\"${key}\" class=\"kv-key\" readonly></td>\n                                    <td>\n                                        <div class=\"encrypted-value\">\n                                            ${!hasValue ? '<span style=\"color: #ff9999; font-style: italic;\">Not Set</span>' : ''}\n                                        </div>\n                                    </td>\n                                    <td>\n                                        <span class=\"encrypted-badge\"></span>\n                                    </td>\n                                    <td>\n                                        <button class=\"cc-button delete-row\">Delete</button>\n                                        <button class=\"cc-button update-encrypted\">Update</button>\n                                    </td>\n                                </tr>\n                            `).join('')}\n\n                            ${Array.from(this.keyValuePairs || []).map(([key, value]) => `\n                                <tr>\n                                    <td><input type=\"text\" value=\"${key}\" class=\"kv-key\"></td>\n                                    <td>\n                                        <input type=\"text\" value=\"${value}\" class=\"kv-value\">\n                                    </td>\n                                    <td>\n                                        <input type=\"checkbox\" class=\"encrypt-toggle\">\n                                    </td>\n                                    <td>\n                                        <button class=\"cc-button delete-row\">Delete</button>\n                                    </td>\n                                </tr>\n                            `).join('')}\n                        </tbody>\n                    </table>\n                    <div class=\"cc-key-value-actions\">\n                        <button class=\"cc-button\" id=\"add-kv-pair\">Add New Pair</button>\n                    </div>\n                </div>\n            </div>\n            \n            <div class=\"cc-settings-buttons\">\n                <button class=\"cc-button cancel\">Cancel</button>\n                <button class=\"cc-button confirm\">Save</button>\n            </div>\n        `;\n\n        // Add event listeners\n        const changeKeybindBtn = dialog.querySelector('#change-keybind');\n        changeKeybindBtn.addEventListener('click', () => {\n            this.showKeybindDialogInSettings(dialog, (newKeybind) => {\n                carbonCommander.keybind = newKeybind;\n                dialog.querySelector('.cc-keybind-display').textContent = this.getKeybindDisplay();\n            });\n        });\n        \n        const addKVPairBtn = dialog.querySelector('#add-kv-pair');\n        addKVPairBtn.addEventListener('click', () => {\n            const tbody = dialog.querySelector('.key-value-pairs-table tbody');\n            const newRow = document.createElement('tr');\n            newRow.innerHTML = `\n                <td><input type=\"text\" class=\"kv-key\"></td>\n                <td><input type=\"text\" class=\"kv-value\"></td>\n                <td><input type=\"checkbox\" class=\"encrypt-toggle\"></td>\n                <td>\n                    <button class=\"cc-button delete-row\">Delete</button>\n                </td>\n            `;\n            tbody.appendChild(newRow);\n        });\n        \n        // Add hostname prompt handlers\n        const addHostnamePromptBtn = dialog.querySelector('#add-hostname-prompt');\n        addHostnamePromptBtn.addEventListener('click', () => {\n            const tbody = dialog.querySelector('.hostname-prompts-table tbody');\n            \n            // Get current hostname and check if it's already configured\n            const currentHostname = window.location.hostname;\n            if (currentHostname && !this.hostnamePrompts.has(currentHostname)) {\n                const newRow = document.createElement('tr');\n                newRow.innerHTML = `\n                    <td><input type=\"text\" class=\"hostname-key\" value=\"${currentHostname}\"></td>\n                    <td><textarea class=\"hostname-prompt\" placeholder=\"Enter host-specific system prompt...\"></textarea></td>\n                    <td>\n                        <button class=\"cc-button delete-hostname-prompt\">Delete</button>\n                    </td>\n                `;\n                tbody.appendChild(newRow);\n                // Focus the prompt textarea\n                newRow.querySelector('.hostname-prompt').focus();\n            } else {\n                const newRow = document.createElement('tr');\n                newRow.innerHTML = `\n                    <td><input type=\"text\" class=\"hostname-key\" placeholder=\"example.com\"></td>\n                    <td><textarea class=\"hostname-prompt\" placeholder=\"Enter host-specific system prompt...\"></textarea></td>\n                    <td>\n                        <button class=\"cc-button delete-hostname-prompt\">Delete</button>\n                    </td>\n                `;\n                tbody.appendChild(newRow);\n                // Focus the hostname input since we don't have a pre-filled value\n                newRow.querySelector('.hostname-key').focus();\n            }\n        });\n        \n        // Add MCP service management handlers\n        const addMCPServiceBtn = dialog.querySelector('#add-mcp-service');\n        addMCPServiceBtn.addEventListener('click', () => {\n            const tbody = dialog.querySelector('.mcp-services-table tbody');\n            const newRow = document.createElement('tr');\n            newRow.innerHTML = `\n                <td><input type=\"text\" class=\"mcp-service-id\" placeholder=\"service-id\"></td>\n                <td><input type=\"text\" class=\"mcp-endpoint\" placeholder=\"https://example.com\"></td>\n                <td>\n                    <div class=\"encrypted-value\">\n                        <span style=\"color: #ff9999; font-style: italic;\">Not Set</span>\n                    </div>\n                    <button class=\"cc-button update-mcp-key\">Set Key</button>\n                </td>\n                <td>\n                    <span class=\"mcp-status disconnected\">disconnected</span>\n                </td>\n                <td>\n                    <button class=\"cc-button delete-mcp-service\">Delete</button>\n                    <button class=\"cc-button toggle-mcp-service\">Connect</button>\n                </td>\n            `;\n            tbody.appendChild(newRow);\n        });\n        \n        dialog.addEventListener('click', async (e) => {\n            if (e.target.classList.contains('delete-hostname-prompt')) {\n                const row = e.target.closest('tr');\n                const hostname = row.querySelector('.hostname-key').value;\n                this.hostnamePrompts.delete(hostname);\n                row.remove();\n            }\n            \n            if (e.target.classList.contains('delete-row')) {\n                const row = e.target.closest('tr');\n                const key = row.querySelector('.kv-key').value;\n                \n                if (this.encryptedKeys.has(key)) {\n                    this.encryptedKeys.set(key, true);\n                    this.keyValuePairs.set(key, ''); \n                } else {\n                    this.keyValuePairs.delete(key);\n                }\n\n                ccLogger.debug('Deleted key:', key, 'new keyValuePairs:', this.keyValuePairs);\n\n                row.remove();\n            }\n            \n            if (e.target.classList.contains('update-encrypted')) {\n                const row = e.target.closest('tr');\n                const key = row.querySelector('.kv-key').value;\n                \n                // Show input dialog for new encrypted value\n                const inputDialog = document.createElement('div');\n                inputDialog.classList.add('cc-dialog');\n                inputDialog.innerHTML = `\n                    <div class=\"cc-dialog-content\">\n                        <h3>Update Encrypted Value</h3>\n                        <div class=\"cc-input-group\">\n                            <label>New value for ${key}:</label>\n                            <input type=\"password\" class=\"cc-dialog-input\">\n                        </div>\n                        <div class=\"cc-dialog-buttons\">\n                            <button class=\"cc-button cancel\">Cancel</button>\n                            <button class=\"cc-button confirm\">Update</button>\n                        </div>\n                    </div>\n                `;\n                \n                dialog.appendChild(inputDialog);\n                \n                const input = inputDialog.querySelector('.cc-dialog-input');\n                input.focus();\n                \n                inputDialog.querySelector('.cancel').addEventListener('click', () => {\n                    inputDialog.remove();\n                });\n                \n                inputDialog.querySelector('.confirm').addEventListener('click', async () => {\n                    const newValue = input.value.trim();\n\n\n                    if(key === 'openai-key') {\n                        const response = await this.testOpenAIKey(newValue);\n                        if(!response.success) {\n                            alert('Invalid OpenAI key, test failed');\n                            ccLogger.error('Failed to set OpenAI key');\n                            return;\n                        }\n                    }\n\n                    this.encryptedKeys.set(key, true);\n                    this.keyValuePairs.set(key, newValue);\n                    //Update the UI with encrypted 'hasValue' status, for kv-value row\n                    const encryptedValue = row.querySelector('.encrypted-value');\n                    const hasValue = newValue !== null && newValue !== undefined && newValue !== '';\n                    encryptedValue.innerHTML = hasValue ? '<span style=\"color: lime; font-style: italic;\">Updated</span>' : '<span style=\"color: red; font-style: italic;\">Empty</span>';\n                        \n                    inputDialog.remove();\n                });\n            }\n\n            if (e.target.classList.contains('delete-mcp-service')) {\n                const row = e.target.closest('tr');\n                const serviceId = row.querySelector('.mcp-service-id').value;\n                await this.removeMCPService(serviceId);\n                row.remove();\n            }\n\n            if (e.target.classList.contains('update-mcp-key')) {\n                const row = e.target.closest('tr');\n                const serviceId = row.querySelector('.mcp-service-id').value;\n                \n                // Show input dialog for new API key\n                const inputDialog = document.createElement('div');\n                inputDialog.classList.add('cc-dialog');\n                inputDialog.innerHTML = `\n                    <div class=\"cc-dialog-content\">\n                        <h3>Update MCP API Key</h3>\n                        <div class=\"cc-input-group\">\n                            <label>New API key for ${serviceId}:</label>\n                            <input type=\"password\" class=\"cc-dialog-input\">\n                        </div>\n                        <div class=\"cc-dialog-buttons\">\n                            <button class=\"cc-button cancel\">Cancel</button>\n                            <button class=\"cc-button confirm\">Update</button>\n                        </div>\n                    </div>\n                `;\n                \n                dialog.appendChild(inputDialog);\n                \n                const input = inputDialog.querySelector('.cc-dialog-input');\n                input.focus();\n                \n                inputDialog.querySelector('.cancel').addEventListener('click', () => {\n                    inputDialog.remove();\n                });\n                \n                inputDialog.querySelector('.confirm').addEventListener('click', async () => {\n                    const newValue = input.value.trim();\n                    if (newValue) {\n                        const config = this.mcpConfigurations.get(serviceId) || {};\n                        config.apiKey = newValue;\n                        await this.configureMCPService({\n                            serviceId,\n                            endpoint: config.endpoint,\n                            apiKey: newValue,\n                            options: config.options\n                        });\n                        \n                        const encryptedValue = row.querySelector('.encrypted-value');\n                        encryptedValue.innerHTML = '';\n                    }\n                    inputDialog.remove();\n                });\n            }\n\n            if (e.target.classList.contains('toggle-mcp-service')) {\n                const row = e.target.closest('tr');\n                const serviceId = row.querySelector('.mcp-service-id').value;\n                const endpoint = row.querySelector('.mcp-endpoint').value;\n                const statusSpan = row.querySelector('.mcp-status');\n                const toggleBtn = e.target;\n\n                if (statusSpan.textContent === 'connected') {\n                    // Disconnect\n                    await carbonCommander.mcpToolCaller.disconnectMCPService(serviceId);\n                    statusSpan.textContent = 'disconnected';\n                    statusSpan.className = 'mcp-status disconnected';\n                    toggleBtn.textContent = 'Connect';\n                } else {\n                    // Connect\n                    const config = this.mcpConfigurations.get(serviceId);\n                    if (config) {\n                        const success = await carbonCommander.mcpToolCaller.connectMCPService(serviceId);\n                        if (success) {\n                            statusSpan.textContent = 'connected';\n                            statusSpan.className = 'mcp-status connected';\n                            toggleBtn.textContent = 'Disconnect';\n                        }\n                    }\n                }\n            }\n        });\n        \n        // Set up command history management\n        const hostnameSelect = dialog.querySelector('#hostname-select');\n        const clearHistoryBtn = dialog.querySelector('#clear-history');\n\n        // Function to load hostnames with command history\n        const loadHistoryHostnames = async () => {\n            const historyKeys = await this._postMessageHandler({\n                type: 'GET_HISTORY_HOSTNAMES'\n            });\n            \n            hostnameSelect.innerHTML = '<option value=\"\">Select hostname...</option>';\n            if (historyKeys && historyKeys.payload) {\n                historyKeys.payload.forEach(hostname => {\n                    const option = document.createElement('option');\n                    option.value = hostname;\n                    option.textContent = hostname;\n                    hostnameSelect.appendChild(option);\n                });\n            }\n        };\n\n        loadHistoryHostnames();\n\n        clearHistoryBtn.addEventListener('click', async () => {\n            const selectedHostname = hostnameSelect.value;\n            if (!selectedHostname) {\n                alert('Please select a hostname first');\n                return;\n            }\n\n            if (confirm(`Are you sure you want to clear command history for ${selectedHostname}?`)) {\n                await this._postMessageHandler({\n                    type: 'CLEAR_COMMAND_HISTORY',\n                    payload: {\n                        hostname: selectedHostname\n                    }\n                });\n                \n                // Refresh the hostname list\n                await loadHistoryHostnames();\n                hostnameSelect.value = '';\n            }\n        });\n        \n        const confirmBtn = dialog.querySelector('.confirm');\n        confirmBtn.addEventListener('click', async () => {\n            ccLogger.group('Saving settings from confirm click');\n            try\n            {\n                // Save system prompt\n                this.systemPrompt = dialog.querySelector('#system-prompt').value.trim();\n                \n                // Save hostname prompts using the specific hostname-prompts-table class\n                const newHostnamePrompts = new Map();\n                const hostnameRows = dialog.querySelector('.hostname-prompts-table tbody').querySelectorAll('tr');\n                for (const row of hostnameRows) {\n                    const hostnameKey = row.querySelector('.hostname-key');\n                    const hostnamePrompt = row.querySelector('.hostname-prompt');\n                    if (hostnameKey && hostnamePrompt) {\n                        const hostname = hostnameKey.value.trim();\n                        const prompt = hostnamePrompt.value.trim();\n                        if (hostname && prompt) {\n                            newHostnamePrompts.set(hostname, prompt);\n                        }\n                    }\n                }\n                this.hostnamePrompts = newHostnamePrompts;\n                            \n                // Save key-value pairs using the specific key-value-pairs-table class\n                const newPairs = new Map();\n                const newEncryptedKeys = this.encryptedKeys;\n\n                const kvRows = dialog.querySelector('.key-value-pairs-table tbody').querySelectorAll('tr');\n                for (const row of kvRows) {\n                    const key = row.querySelector('.kv-key')?.value.trim();\n                    const valueInput = row.querySelector('.kv-value');\n                    const encryptToggle = row.querySelector('.encrypt-toggle');\n                    \n                    if (key) {\n                        if (this.encryptedKeys.has(key) && this.keyValuePairs.has(key)) {\n                            //do nothing but eat this logic, we do this again below\n                        } else if (valueInput) {\n                            const value = valueInput.value;\n                            if (value !== undefined && value !== null) {\n                                const trimmedValue = typeof value === 'string' ? value.trim() : value;\n                                if (trimmedValue !== '') {\n                                    // If this is the OpenAI key and it's being encrypted, test it first\n                                    if(key === 'openai-key') {\n                                        const response = await this.testOpenAIKey(trimmedValue);\n                                        if(!response.success) {\n                                            alert('Invalid OpenAI key, test failed');\n                                            ccLogger.error('Failed to set OpenAI key');\n                                            return;\n                                        }\n                                    }\n\n                                    newPairs.set(key, trimmedValue);\n                                    // Check if this should be encrypted\n                                    if (encryptToggle && encryptToggle.checked)\n                                        newEncryptedKeys.set(key, true);\n                                }\n                            }\n                        }\n                    }\n                }\n                \n                for(const [key, value] of this.keyValuePairs.entries()) {\n                    if(this.encryptedKeys.has(key)) {\n                        const newValue = this.keyValuePairs.get(key);\n                        typeof newValue === 'string' ? newValue.trim() : newValue;\n                        newPairs.set(key, newValue);\n                        newEncryptedKeys.set(key, true);\n                    }\n                }\n\n                ccLogger.debug('Old keyValuePairs:', this.keyValuePairs);\n                ccLogger.debug('Old encryptedKeys:', this.encryptedKeys);\n\n                this.keyValuePairs = newPairs;\n                this.encryptedKeys = newEncryptedKeys;\n\n                ccLogger.debug('New keyValuePairs:', this.keyValuePairs);\n                ccLogger.debug('New encryptedKeys:', this.encryptedKeys);\n\n                await this.save();\n                overlay.remove();\n            }catch(error)\n            {\n                ccLogger.error('Error saving settings:', error);\n            }finally\n            {\n                ccLogger.groupEnd();\n            }\n            \n        });\n        \n        const cancelBtn = dialog.querySelector('.cancel');\n        cancelBtn.addEventListener('click', () => {\n            overlay.remove();\n        });\n        \n        overlay.appendChild(dialog);\n        document.body.appendChild(overlay);\n    }\n\n    // New method to handle MCP configuration\n    async configureMCPService(serviceConfig) {\n        const { serviceId, endpoint, apiKey, options = {} } = serviceConfig;\n        \n        ccLogger.debug(`Configuring MCP service: ${serviceId}`);\n        \n        try {\n            const config = {\n                endpoint,\n                apiKey,\n                options,\n                status: 'configured'\n            };\n\n            this.mcpConfigurations.set(serviceId, config);\n            await this.save();\n            return true;\n        } catch (error) {\n            ccLogger.error(`Error configuring MCP service ${serviceId}:`, error);\n            return false;\n        }\n    }\n\n    // New method to remove MCP configuration\n    async removeMCPService(serviceId) {\n        ccLogger.debug(`Removing MCP service: ${serviceId}`);\n        \n        try {\n            // Remove from configurations\n            this.mcpConfigurations.delete(serviceId);\n            \n            // Remove encrypted API key\n            await this._postMessageHandler({\n                type: 'DELETE_ENCRYPTED_VALUE',\n                payload: {\n                    key: `mcp-key-${serviceId}`\n                }\n            });\n            \n            await this.save();\n            return true;\n        } catch (error) {\n            ccLogger.error(`Error removing MCP service ${serviceId}:`, error);\n            return false;\n        }\n    }\n\n    // New method to get MCP service configuration\n    getMCPServiceConfig(serviceId) {\n        return this.mcpConfigurations.get(serviceId);\n    }\n\n    // New method to list all MCP services\n    getMCPServices() {\n        return Array.from(this.mcpConfigurations.entries()).map(([id, config]) => ({\n            id,\n            endpoint: config.endpoint,\n            options: config.options\n        }));\n    }\n}\n\nexport default new Settings(); ","import { ccLogger, ccOneTimeMessageHandler } from '../global.js';\n\nclass ToolCaller {\n    currentPageTools = null;\n\n    reset() {\n        ccLogger.debug('Resetting tool caller state');\n        this.currentPageTools = null;\n    }\n\n    getToolSets() {\n        return this.getAllToolsets();\n    }\n\n    getTools(onlyFunctionInfo = false) {        \n        ccLogger.group('Getting Tools');\n        let allTools = [];\n        let pageTools = this.getAllToolSetsForPage();\n        pageTools.forEach(toolSet => {\n            toolSet.tools.forEach(prop => {\n                allTools.push(onlyFunctionInfo ? prop.function : prop);\n            });\n        });\n        ccLogger.debug(`Found ${allTools.length} tools`);\n        ccLogger.groupEnd();\n        return allTools;\n    }\n\n    getTool(toolName, onlyFunctionInfo = false) {\n        ccLogger.debug('Getting tool:', toolName);\n        const allTools = this.getTools(onlyFunctionInfo);\n        const tool = allTools.find(tool => onlyFunctionInfo ? tool.name == toolName : tool.function.name == toolName);\n        if (!tool) {\n            ccLogger.warn(`Tool not found: ${toolName}`);\n        }\n        return tool;\n    }\n\n    async getToolScope(bar) {\n        ccLogger.group('Building Tool Scope', \"bar.settings:\", bar.settings, \"bar:\", bar);\n        var scope = {\n            bar: bar,\n            settings: {\n                keyValuePairs: bar.settings?.keyValuePairs || new Map(),\n                encryptedKeys: bar.settings?.encryptedKeys || new Map()\n            },\n            requestIdMap: new Map(),\n            logMessage: (...args) => {\n                let important = false;\n                if(typeof args[0] === 'boolean') {\n                    important = args[0];\n                    args = args.slice(1);\n                }\n                if(important) {\n                    ccLogger.info('[ToolScope]', ...args);\n                } else {\n                    ccLogger.debug('[ToolScope]', ...args);\n                }\n            },\n            logError: (...args) => {\n                ccLogger.error('[ToolScope]', ...args);\n            },\n            promptAccessRequest: async (args) => {\n                const { prompt, default_value } = args;\n                const promise = new Promise(async (resolve) => {\n                    // Generate a unique ID for this request\n                    const requestId = Math.random().toString(36).substr(2, 9);\n\n                    const messageHandler = (event) => {\n                        // ick, I dont really like how this looks.\n                        \n                        if(event.data.type && event.data.type === 'CARBON_ACCESS_REQUEST_RESPONSE_RESPONSE' && event.data.payload.payload.requestId === requestId) {\n                            ccLogger.debug('CARBON_ACCESS_REQUEST_RESPONSE_RESPONSE2', event, \"payload:\", event.data.payload.payload);\n                            window.removeEventListener('message', messageHandler);\n                            const response = event.data.payload.payload;\n                            if(response.confirmed) {\n                                ccLogger.debug('CONFIRMATION_DIALOG_RESPONSE', 'granted', response);\n                                resolve(response);\n                            } else {\n                                ccLogger.debug('CONFIRMATION_DIALOG_RESPONSE', 'denied', response);\n                                resolve(response);\n                            }\n\n                        } else {\n                            ccLogger.debug('CARBON_ACCESS_REQUEST_RESPONSE_RESPONSE1', requestId, event);\n                        }\n                    };\n                    window.addEventListener('message', messageHandler);\n\n                    // Send message to command bar to show confirmation dialog\n                    bar.postMessage({\n                        type: 'SHOW_ACCESS_REQUEST',\n                        payload: {\n                            requestId: requestId,\n                            prompt: prompt\n                        }\n                    });\n\n                });\n                var result = await promise;\n                ccLogger.debug('CONFIRMATION_DIALOG_RESPONSE2', 'result:', result);\n                return result;\n            }\n        }\n        //Apply the current toolsets scope functions\n        for(let toolSet of this.getAllToolSetsForPage()) {\n            try {\n                if(toolSet.toolSet._CarbonBarBuildScope) {\n                    ccLogger.debug(`Building scope for toolset: ${toolSet.name}`);\n                    scope = await toolSet.toolSet._CarbonBarBuildScope(scope);\n                    ccLogger.debug('App name after scope build:', scope.appName);\n                }\n            } catch (e) {\n                ccLogger.error('Error building scope:', e);\n            }\n        }\n\n        if(!scope.appName) {\n            ccLogger.warn('No app name found in scope, using default');\n            scope.appName = 'CarbonCommander [Unknown App (2)]';\n        }\n        ccLogger.debug('Final app name:', scope.appName);\n        ccLogger.groupEnd();\n        return scope;\n    }\n\n    getAllToolSetsForPage() {\n        if(this.currentPageTools) {\n            return this.currentPageTools;\n        }\n        \n        ccLogger.group('Getting Tool Sets for Page');\n        this.currentPageTools = this.getAllToolsets().filter(toolSet => \n            (toolSet.tools && toolSet.tools.length > 0) &&\n            (toolSet.toolSet._CarbonBarPageLoadFilter && toolSet.toolSet._CarbonBarPageLoadFilter(window))\n        );\n        \n        ccLogger.debug(`Found ${this.currentPageTools.length} tool sets for current page`);\n        ccLogger.groupEnd();\n        return this.currentPageTools;\n    }\n\n    getAllToolsets() {\n        ccLogger.group('Getting All Tool Sets');\n        const allTools = [];\n        if (window.sbaiTools) {\n            Object.entries(window.sbaiTools).forEach(([_, toolSet]) => {\n                try {\n                    let toolset = {\n                        name: toolSet.name,\n                        toolSet: toolSet,\n                        tools: Object.getOwnPropertyNames(toolSet)\n                            .filter(prop => typeof toolSet[prop] === 'object' && toolSet[prop]?.function)\n                            .map(prop => toolSet[prop])\n                    };\n\n                    ccLogger.debug('Processing toolset:', { \n                        name: toolset.name, \n                        toolCount: toolset.tools.length \n                    });\n\n                    if(toolset.tools && toolset.tools.length > 0) {\n                        allTools.push(toolset);\n                    }\n                } catch (e) {\n                    ccLogger.error(`Error getting tools from ${toolSet.name}:`, e);\n                }\n            });\n        }\n        ccLogger.debug(`Total tool sets found: ${allTools.length}`);\n        ccLogger.groupEnd();\n        return allTools;\n    }\n\n\n    async buildSystemPrompt(basePrompt, scope) {\n        ccLogger.group('Building System Prompt');\n        let toolSets = this.getAllToolSetsForPage();\n        if(toolSets.length > 0) {\n            for(let toolSet of toolSets) { \n                if(toolSet.toolSet._CarbonBarSystemPrompt) {\n                    ccLogger.debug(`Adding system prompt from toolSet: ${toolSet.name || 'unnamed'}`);\n                    if(toolSet.toolSet._CarbonBarBuildScope) {\n                        scope = await toolSet.toolSet._CarbonBarBuildScope(scope);\n                    }\n                    basePrompt = await toolSet.toolSet._CarbonBarSystemPrompt(basePrompt, scope);\n                }\n            }\n        }\n        ccLogger.groupEnd();\n        return basePrompt;\n    }\n\n    getToolHtml(chunk) {\n        ccLogger.group('Generating Tool HTML');\n        const toolName = chunk.name;\n        const toolArgs = chunk.arguments;\n        let toolResult = chunk.result;\n        const toolCallIndex = chunk.index;\n        const toolCallStarted = chunk.callStarted;\n        const toolCallFinished = chunk.callFinished;\n        const tool = this.getTool(toolName, true);\n\n        ccLogger.debug('Tool chunk info:', {\n            name: toolName,\n            hasArgs: !!toolArgs,\n            started: toolCallStarted,\n            finished: toolCallFinished\n        });\n\n        try {\n            if(toolResult && typeof toolResult === 'string') {\n                toolResult = JSON.parse(toolResult);\n                if(toolResult.startsWith('ERROR: ')) {\n                    toolResult = JSON.parse(toolResult.substring(7));\n                }\n            }\n        } catch(e) {\n            \n        }\n\n        ccLogger.debug('Tool result status:', {\n            hasResult: !!toolResult,\n            hasError: !!toolResult?.error\n        });\n\n        let status = 'pending';\n        let statusText = 'Preparing...';\n        \n        if (toolCallStarted && !toolCallFinished) {\n            status = 'running';\n            statusText = 'Running';\n        } else if (toolCallFinished) {\n            status = toolResult?.error ? 'error' : 'completed';\n            statusText = toolResult?.error ? 'Error' : 'Completed';\n        }\n\n        // Generate parameters documentation HTML\n        let parametersHtml = '';\n        if (tool.parameters?.properties) {\n            parametersHtml = `\n                <div class=\"tool-parameters\">\n                    <h4>Parameters:</h4>\n                    <table class=\"tool-params-table\">\n                        <tr>\n                            <th>Name</th>\n                            <th>Type</th>\n                            <th>Required</th>\n                            <th>Description</th>\n                        </tr>\n                        ${Object.entries(tool.parameters.properties).map(([name, param]) => `\n                            <tr>\n                                <td>${name}</td>\n                                <td>${param.type}</td>\n                                <td>${tool.parameters.required?.includes(name) ? '' : ''}</td>\n                                <td>${param.description || ''}</td>\n                            </tr>\n                        `).join('')}\n                    </table>\n                </div>\n            `;\n        }\n\n        ccLogger.debug('parametersHtmlTest', toolResult?.result ? toolResult.result : 'No result');\n\n        // Generate advanced view HTML\n        const advancedHtml = `\n            <div class=\"tool-advanced-container\">\n                <button class=\"tool-view-toggle\">Show Simple</button>\n                <div class=\"tool-header\">\n                    <span class=\"tool-name\">${toolName}</span>\n                    <span class=\"tool-status ${status}\">${statusText}</span>\n                </div>\n                ${tool.description ? `<div class=\"tool-description\">${tool.description}</div>` : ''}\n                ${parametersHtml}\n                ${toolArgs ? `\n                    <div class=\"tool-arguments-section\">\n                        <h4>Current Call Arguments:</h4>\n                        <div class=\"tool-arguments\">${ (toolArgs instanceof Object) ? JSON.stringify(toolArgs) : toolArgs}</div>\n                    </div>\n                ` : ''}\n                ${toolResult?.error ? `<div class=\"cc-error\">${toolResult.error}</div>` : ''}\n                ${toolResult ? `\n                    <div class=\"tool-result-section\">\n                        <h4>Result:</h4>\n                        <div class=\"tool-result-content\">${ (toolResult instanceof Object) ? JSON.stringify(toolResult) : toolResult}</div>\n                    </div>\n                ` : ''}\n            </div>\n        `;\n\n        // Generate simple view HTML\n        const simpleHtml = `\n            <div class=\"tool-simple-container ${status}\">\n                <div class=\"tool-simple-content\">\n                    <div class=\"tool-simple-icon ${status}\"></div>\n                    <div class=\"tool-simple-info\">\n                        <div class=\"tool-simple-name\">${toolName}</div>\n                        ${toolResult?.error ? \n                            `<div class=\"cc-error\">${toolResult.error}</div>` :\n                            toolResult ? \n                                `<div class=\"tool-simple-progress\">\n                                    <div class=\"progress-bar\" style=\"width: 100%\"></div>\n                                </div>` :\n                                `<div class=\"tool-simple-progress\">\n                                    <div class=\"progress-bar\" style=\"width: ${toolCallFinished ? '100%' : toolCallStarted ? '50%' : '20%'}\"></div>\n                                </div>`\n                        }\n                    </div>\n                </div>\n            </div>\n        `;\n\n        ccLogger.debug('Generated HTML with status:', status);\n        ccLogger.groupEnd();\n        return { simpleHtml, advancedHtml };\n    }\n\n    static getService(serviceName) {\n        ccLogger.debug('Getting service:', serviceName);\n        return angular.element(document).injector().get(serviceName);\n    }\n}\nconst toolCaller = new ToolCaller();\nexport default toolCaller;","/**\n * Global logger implementation for Carbon Commander\n */\nlet ccLoggerPrefix = '';\n\nexport const ccDefaultKeybind = {\n    key: 'k',\n    ctrl: true,\n    meta: false\n};\n\n\nexport const ccOneTimeMessageHandler = async (requestId) => {\n    return new Promise((resolve) => {\n        const messageHandler = (event) => {\n            window.removeEventListener('message', messageHandler);\n            resolve(event);\n        };\n        window.addEventListener(`${requestId}_RESPONSE`, messageHandler);\n    });\n}\n\nexport const ccLogger = {\n    log: console.log,\n    info: console.info,\n    warn: console.warn,\n    error: console.error,\n    debug: console.debug,\n    group: console.group,\n    groupEnd: console.groupEnd,\n    time: console.time,\n    timeEnd: console.timeEnd,\n    setPrefix: (prefix) => {\n        ccLoggerPrefix = prefix;\n        // Wrap console methods to include prefix\n        ccLogger.log = (...args) => console.log(ccLoggerPrefix, ...args);\n        ccLogger.info = (...args) => console.info(ccLoggerPrefix, ...args);\n        ccLogger.warn = (...args) => console.warn(ccLoggerPrefix, ...args);\n        ccLogger.error = (...args) => console.error(ccLoggerPrefix, ...args);\n        ccLogger.debug = (...args) => console.debug(ccLoggerPrefix, ...args);\n    }\n};\n\nexport const AICallerModels = {\n    ['FAST']: {\n        ollama: 'qwen2.5:14b',\n        openai: 'gpt-4o-mini'\n    },\n    ['REASON']: {\n        ollama: \"deepseek-r1:70b\",\n        openai: \"o3-mini\"\n    },\n    ['VISION']: {\n        ollama: \"llama3.2-vision\",\n        openai: \"gpt-4o\"\n    },\n    ['AUTOCOMPLETE']: {\n        ollama: 'mistral-small',//\"qwen2.5:1.5b\",\n        openai: \"gpt-4o-mini\"\n    }\n}","class CarbonBarHelpTools {\n    static name = \"CarbonBarHelpTools\";\n\n    static _CarbonBarPageLoadFilter = (window) => {\n        return true; //manually get injected as needed\n    }\n\n    static GetNoAIModeToolInfo() {\n        return [\n            CarbonBarHelpTools.SetOpenAIKey.function,\n            CarbonBarHelpTools.CheckOllamaStatus.function,\n            CarbonBarHelpTools.GetSetupGuide.function,\n            CarbonBarHelpTools.GetUsageGuide.function,\n            CarbonBarHelpTools.ChangeKeybind.function,\n            CarbonBarHelpTools.ListGuides.function\n        ];\n    }\n\n    static ListGuides = {\n        function: {\n            name: 'list_guides',\n            description: 'List all available guides and documentation',\n            parameters: {}\n        },\n        execute: async function(scope, args) {\n            const guide = `# Available Guides in Carbon Commander\n\n## Setup Guides\nUse \\`get_setup_guide [topic]\\` with:\n- \\`openai\\` - OpenAI API setup and configuration\n- \\`ollama\\` - Ollama local AI setup and configuration\n- \\`mcp\\` - MCP service setup and integration\n- \\`general\\` - General setup and configuration overview\n\n## Usage Guides\nUse \\`get_usage_guide [topic]\\` with:\n- \\`keybinds\\` - Keyboard shortcuts and customization\n- \\`commands\\` - Available commands and usage\n- \\`tools\\` - Tool system and functionality\n- \\`general\\` - Quick start and overview\n\n## Examples\n1. Get OpenAI setup instructions:\n   \\`get_setup_guide openai\\`\n\n2. Learn about keyboard shortcuts:\n   \\`get_usage_guide keybinds\\`\n\n3. Set up MCP services:\n   \\`get_setup_guide mcp\\`\n\n4. Get general usage overview:\n   \\`get_usage_guide general\\`\n\n## Additional Help\n- Type \\`help\\` for general assistance\n- Type \\`change-keybind\\` to customize shortcuts\n- Click the  icon to see all available tools\n- Use \\`mcp connect\\` to add services\n\n## Quick Links\n- [OpenAI Platform](https://platform.openai.com)\n- [Ollama Website](https://ollama.ai)\n- [Chrome Extensions](chrome://extensions)`;\n\n            return { success: true, result: guide };\n        }\n    };\n\n    static GetSetupGuide = {\n        function: {\n            name: 'get_setup_guide',\n            description: 'Get detailed setup instructions for OpenAI, Ollama, and MCP',\n            parameters: {\n                properties: {\n                    topic: {\n                        type: 'string',\n                        description: 'The specific setup topic (openai, ollama, mcp, or general). Use list_guides to see all available guides.'\n                    }\n                },\n                required: ['topic']\n            }\n        },\n        execute: async function(scope, args) {\n            const { topic } = args;\n            let guide = '';\n\n            switch(topic.toLowerCase()) {\n                case 'openai':\n                    guide = `# Setting up OpenAI\n\n1. Visit [OpenAI's platform](https://platform.openai.com/signup)\n2. Create an account or sign in\n3. Go to [API Keys](https://platform.openai.com/api-keys)\n4. Click \"Create new secret key\"\n5. Copy your API key\n6. Use the command: \\`set openai-key YOUR_API_KEY\\`\n\n## Additional Configuration\n- API key is stored securely and encrypted\n- Key can be updated any time with the same command\n- Use \\`disconnect openai\\` to remove the key\n\n## Troubleshooting\n- Ensure your API key is valid and has sufficient credits\n- Check connection status in the status badges\n- If issues persist, try disconnecting and reconnecting\n\n## Tips\n- Keep your API key secure and never share it\n- Regularly rotate your API keys for security\n- Monitor your API usage on OpenAI's platform\n\nNeed more help? Try:\n- \\`get_usage_guide general\\` for general usage\n- \\`list_guides\\` to see all available guides\n- \\`check-ollama\\` to verify Ollama status`;\n                    break;\n\n                case 'ollama':\n                    guide = `# Setting up Ollama\n\n1. Visit [Ollama.ai](https://ollama.ai)\n2. Download the installer for your system\n3. Install and run Ollama\n4. For macOS users, enable external connections:\n   \\`\\`\\`bash\n   launchctl setenv OLLAMA_ORIGINS \"chrome-extension://*\"\n   \\`\\`\\`\n5. Restart Ollama after setting OLLAMA_ORIGINS\n\n## Configuration\n- No API key required\n- Runs completely locally\n- Automatic model management\n- Supports multiple AI models\n\n## Verification\nUse \\`check-ollama\\` to verify:\n- Connection status\n- Available models\n- Service health\n\n## Troubleshooting\n1. If Ollama is not detected:\n   - Check if Ollama is running\n   - Verify OLLAMA_ORIGINS setting (macOS)\n   - Restart Ollama service\n\n2. For connection issues:\n   - Check firewall settings\n   - Verify port 11434 is available\n   - Ensure no conflicts with other services\n\n## Tips\n- Keep Ollama updated for best performance\n- Use lightweight models for faster responses\n- Configure resource limits as needed\n\nNeed more help? Try:\n- \\`get_usage_guide general\\` for general usage\n- \\`list_guides\\` to see all available guides\n- \\`check-ollama\\` for status check`;\n                    break;\n\n                case 'mcp':\n                    guide = `# Setting up MCP (Model Context Protocol)\n\n## Overview\nMCP allows you to extend Carbon Commander with external AI services and tools.\n\n## Basic Setup\n1. **Simple Connection**\n   \\`\\`\\`\n   mcp connect my-service https://my-mcp-service.example.com\n   \\`\\`\\`\n\n2. **With Authentication**\n   \\`\\`\\`javascript\n   window.carbonCommander.mcpToolCaller.configureMCPService({\n     serviceId: 'my-service',\n     endpoint: 'https://my-mcp-service.example.com',\n     apiKey: 'your-api-key',\n     options: {\n       autoConnect: true,\n       autoReconnect: true\n     }\n   });\n   \\`\\`\\`\n\n## Service Management\n1. **View Status**:\n   - Check status badges in UI\n   - Look for \"MCP:\" prefix in tools list\n\n2. **Disconnect Service**:\n   \\`mcp disconnect my-service\\`\n\n## Creating an MCP Service\nRequired endpoints:\n\\`\\`\\`javascript\nGET  /discover-tools    // List available tools\nPOST /execute          // Execute tool function\nGET  /status           // Service status\n\n// Optional endpoints\nPOST /build-scope      // Custom tool scope\nPOST /system-prompt    // Enhance prompts\n\\`\\`\\`\n\n## Example Service Definition\n\\`\\`\\`javascript\n{\n  name: \"email-tools\",\n  tools: [{\n    name: \"send-email\",\n    description: \"Send email via MCP\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        to: { type: \"string\" },\n        subject: { type: \"string\" },\n        body: { type: \"string\" }\n      },\n      required: [\"to\", \"subject\", \"body\"]\n    }\n  }]\n}\n\\`\\`\\`\n\n## Security Best Practices\n1. Use HTTPS for all connections\n2. Implement proper authentication\n3. Validate all requests\n4. Use rate limiting\n5. Monitor service usage\n\n## Troubleshooting\n1. **Connection Issues**:\n   - Verify endpoint URL\n   - Check authentication\n   - Ensure service is running\n\n2. **Tool Discovery**:\n   - Verify /discover-tools endpoint\n   - Check tool definitions\n   - Monitor browser console\n\n3. **Execution Problems**:\n   - Validate parameters\n   - Check error responses\n   - Verify tool implementation\n\n## Tips\n- Use autoConnect for reliability\n- Implement error handling\n- Monitor tool performance\n- Keep services updated\n\nNeed more help? Try:\n- \\`get_usage_guide tools\\` for tool usage\n- \\`list_guides\\` for all guides\n- Check service documentation`;\n                    break;\n\n                case 'general':\n                    guide = `# General Setup Guide\n\n## Quick Start\n1. Install the extension\n2. Configure providers:\n   - OpenAI for advanced features (\\`get_setup_guide openai\\`)\n   - Ollama for local processing (\\`get_setup_guide ollama\\`)\n   - MCP for external services (\\`get_setup_guide mcp\\`)\n3. Customize keyboard shortcuts\n4. Start using commands\n\n## AI Provider Setup\n1. **OpenAI (Recommended)**\n   - Get API key: \\`get_setup_guide openai\\`\n   - Set key: \\`set openai-key YOUR_KEY\\`\n   - Check status in badges\n\n2. **Ollama (Optional)**\n   - Install locally: \\`get_setup_guide ollama\\`\n   - Runs automatically when detected\n   - Provides faster local processing\n\n3. **MCP Services (Optional)**\n   - Connect services: \\`mcp connect [service-id] [endpoint]\\`\n   - View status in badges\n   - Use service-specific tools\n\n## Keyboard Setup\n1. Default: \\`Ctrl/ + K\\`\n2. Customize:\n   - Use \\`change-keybind\\` command\n   - Or click extension icon\n   - Or use Chrome settings\n\n## Verification\n1. Check OpenAI:\n   - Look for green status badge\n   - Try a simple command\n   \n2. Check Ollama:\n   - Use \\`check-ollama\\` command\n   - Verify status badge\n\n3. Check MCP:\n   - Look for service badges\n   - Try service-specific tools\n\n## Next Steps\n1. Try basic commands\n2. Explore available tools\n3. Set up keyboard shortcuts\n4. Configure AI providers\n\nNeed more details? Try:\n- \\`get_setup_guide openai\\` for OpenAI setup\n- \\`get_setup_guide ollama\\` for Ollama setup\n- \\`get_setup_guide mcp\\` for MCP setup\n- \\`get_usage_guide general\\` for usage help\n- \\`list_guides\\` to see all guides`;\n                    break;\n\n                default:\n                    return { \n                        success: false, \n                        result: \"Invalid topic. Available guides:\\n\\n\" +\n                               \"1. Setup Guides (use get_setup_guide):\\n\" +\n                               \"   - openai: OpenAI configuration\\n\" +\n                               \"   - ollama: Ollama setup\\n\" +\n                               \"   - mcp: MCP service setup\\n\" +\n                               \"   - general: Overall setup\\n\\n\" +\n                               \"2. Usage Guides (use get_usage_guide):\\n\" +\n                               \"   - keybinds: Keyboard shortcuts\\n\" +\n                               \"   - commands: Available commands\\n\" +\n                               \"   - tools: Tool system\\n\" +\n                               \"   - general: Quick start\\n\\n\" +\n                               \"Use list_guides to see all available guides.\"\n                    };\n            }\n\n            return { success: true, result: guide };\n        }\n    };\n\n    static CheckOllamaStatus = {\n        function: {\n            name: 'check_ollama_status',\n            description: 'Check if Ollama is running and accessible',\n            parameters: {}\n        },\n        execute: async function(scope, args) {\n            try {\n                const response = await fetch('http://localhost:11434/api/tags');\n                const data = await response.json();\n                \n                if (data) {\n                    return { \n                        success: true, \n                        result: \" Ollama is running and accessible.\\n\\nAvailable models:\\n\" + \n                               data.models?.map(m => `- ${m.name}`).join('\\n') \n                    };\n                }\n            } catch (error) {\n                return { \n                    success: false, \n                    result: \" Ollama is not accessible. Common issues:\\n\\n\" +\n                           \"1. Ollama is not installed\\n\" +\n                           \"2. Ollama service is not running\\n\" +\n                           \"3. OLLAMA_ORIGINS is not set (macOS)\\n\\n\" +\n                           \"Use 'get_setup_guide ollama' for installation instructions.\"\n                };\n            }\n        }\n    };\n\n    static SetOpenAIKey = {\n        function: {\n            name: 'set_openai_key',\n            description: 'Set the OpenAI key',\n            parameters: {\n                properties: {\n                    key: {\n                        type: 'string',\n                        description: 'The OpenAI key'\n                    }\n                },\n                required: ['key']\n            }\n        },\n        execute: async function(scope, args) {\n            const { key } = args;\n            scope.logMessage('set_openai_key', key);\n            return new Promise((resolve, reject) => {\n                window.postMessage({\n                    type: 'CARBON_SET_OPENAI_KEY',\n                    payload: {\n                        key: key,\n                        save: true\n                    }\n                }, window.location.origin);\n\n                const listener = (event) => {   \n                    if (event.data.type === 'CARBON_SET_OPENAI_KEY_RESPONSE') {\n                        const payload = event.data.payload?.payload || event.data.payload;\n                        scope.logMessage('CARBON_SET_OPENAI_KEY_RESPONSE', event.data, payload);\n                        if(payload.success === true){\n                            window.postMessage({\n                                type: 'PROVIDER_STATUS_UPDATE',\n                                provider: 'openai',\n                                status: true\n                            }, window.location.origin);\n                            resolve({success: true, content: 'OpenAI key set successfully'});\n                        }else{\n                            resolve({success: false, content: 'Failed to set OpenAI key'});\n                        }\n                        window.removeEventListener('message', listener);\n                    }\n                };\n                window.addEventListener('message', listener);\n            });\n        }\n    };\n\n    static GetUsageGuide = {\n        function: {\n            name: 'get_usage_guide',\n            description: 'Get detailed usage instructions for Carbon Commander features',\n            parameters: {\n                properties: {\n                    topic: {\n                        type: 'string',\n                        description: 'The specific usage topic (keybinds, commands, tools, or general)'\n                    }\n                },\n                required: ['topic']\n            }\n        },\n        execute: async function(scope, args) {\n            const { topic } = args;\n            let guide = '';\n\n            switch(topic.toLowerCase()) {\n                case 'keybinds':\n                    guide = `# Keyboard Shortcuts Guide\n\n## Default Shortcuts\n- Open/Close: \\`Ctrl + K\\` (Windows/Linux) or \\` + K\\` (Mac)\n- Close: \\`Esc\\`\n- Command History: \\`\\` and \\`\\` arrow keys\n- Autocomplete: \\`Tab\\`\n\n## Customizing Shortcuts\n1. **Through Extension Icon**:\n   - Click Carbon Commander icon\n   - Select \"Change Keybind\"\n   - Press desired key combination\n   - Click \"Save\"\n\n2. **Through Chrome Settings**:\n   - Go to \\`chrome://extensions/shortcuts\\`\n   - Find Carbon Commander\n   - Click the pencil icon\n   - Set your shortcut\n\n3. **Using Command**:\n   - Type \\`change-keybind\\` in Carbon Commander\n   - Follow the prompts\n\n## Tips\n- Combine with \\`Ctrl\\` or \\`\\` for better shortcuts\n- Avoid system-reserved shortcuts\n- Use single letter keys for quick access`;\n                    break;\n\n                case 'commands':\n                    guide = `# Available Commands Guide\n\n## Basic Commands\n- \\`help\\`: Show general help\n- \\`get_usage_guide [topic]\\`: Get detailed usage instructions\n- \\`change-keybind\\`: Change keyboard shortcut\n- \\`set openai-key [key]\\`: Set OpenAI API key\n- \\`check-ollama\\`: Check Ollama status\n\n## Navigation\n- Use arrow keys (/) for command history\n- Press Tab for autocomplete suggestions\n- Type partial command name to search\n\n## Tool Commands\n- Click the  icon to see all available tools\n- Tools are grouped by source (Local/MCP)\n- Each tool has a description and parameters\n\n## Tips\n- Commands are case-insensitive\n- Use autocomplete for faster input\n- Check tool descriptions for parameter info`;\n                    break;\n\n                case 'tools':\n                    guide = `# Tools Usage Guide\n\n## Tool Categories\n1. **Local Tools**\n   - Built-in functionality\n   - No external dependencies\n   - Fast execution\n\n2. **MCP Tools**\n   - External service integration\n   - Additional capabilities\n   - Network-dependent\n\n## Using Tools\n1. Click the  icon to view all tools\n2. Select a tool to auto-fill command\n3. Provide required parameters\n4. View results in the response area\n\n## Tool Features\n- Real-time execution feedback\n- Error handling and recovery\n- Parameter validation\n- Result formatting\n\n## Tips\n- Use tool descriptions for guidance\n- Check parameter requirements\n- Monitor tool status indicators\n- Use command history for repeated tasks`;\n                    break;\n\n                case 'general':\n                    guide = `# Carbon Commander Quick Start Guide\n\n## Getting Started\n1. Open with \\`Ctrl/ + K\\` or click extension icon\n2. Type your command or question\n3. Use Tab for autocomplete\n4. Press Enter to execute\n\n## Key Features\n1. **AI Integration**\n   - OpenAI for advanced processing\n   - Ollama for local operations\n   - Real-time responses\n\n2. **Tool System**\n   - Built-in tools\n   - MCP service integration\n   - Custom tool support\n\n3. **Command History**\n   - Arrow keys navigation\n   - Persistent storage\n   - Quick access to recent commands\n\n4. **Autocomplete**\n   - Smart suggestions\n   - Tab completion\n   - Context-aware\n\n## Best Practices\n- Start with simple commands\n- Use help guides for specific topics\n- Customize shortcuts for efficiency\n- Check tool documentation\n\nNeed more help? Try:\n- \\`get_usage_guide keybinds\\`\n- \\`get_usage_guide commands\\`\n- \\`get_usage_guide tools\\``;\n                    break;\n\n                default:\n                    return { success: false, error: 'Invalid topic. Use \"keybinds\", \"commands\", \"tools\", or \"general\".' };\n            }\n\n            return { success: true, result: guide };\n        }\n    };\n\n    static ChangeKeybind = {\n        function: {\n            name: 'change-keybind',\n            description: 'Change the keyboard shortcut for opening Carbon Commander',\n            parameters: {}\n        },\n        execute: async function(scope, args) {\n            window.postMessage({ type: 'SHOW_KEYBIND_DIALOG' }, window.location.origin);\n            return { \n                success: true, \n                result: \"Opening keybind configuration dialog...\" \n            };\n        }\n    };\n}\n\n(window.sbaiTools ??= {}).CarbonBarHelpTools = CarbonBarHelpTools;\n\nexport { CarbonBarHelpTools };","class GeneralTools {\n    static _CarbonBarPageLoadFilter = (window) => {\n        return true; //Always available\n    }\n\n    static SearchWeb = {\n        function: {\n            name: 'search_web',\n            description: 'Search the web using DuckDuckGo',\n            parameters: {\n                properties: {\n                    query: {\n                        type: 'string',\n                        description: 'The search query'\n                    },\n                    max_results: {\n                        type: 'number',\n                        description: 'Maximum number of results to return (default: 5)'\n                    }\n                },\n                required: ['query']\n            }\n        },\n        execute: async function(scope, args) {\n            const { query, max_results = 5 } = args;\n            try {\n                const response = await fetch(`https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json`);\n                const data = await response.json();\n                \n                const results = data.RelatedTopics\n                    .slice(0, max_results)\n                    .map(topic => ({\n                        title: topic.Text?.split(' - ')[0] || topic.Text,\n                        description: topic.Text,\n                        url: topic.FirstURL\n                    }));\n                \n                return { success: true, result: results };\n            } catch (error) {\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static SecurityCheck = {\n        function: {\n            name: 'security_check',\n            description: 'Perform a basic security analysis of the current website',\n            parameters: {\n                type: 'object',\n                properties: {\n                    include_headers: {\n                        type: 'boolean',\n                        description: 'Whether to include security header analysis',\n                        default: true\n                    },\n                    check_ssl: {\n                        type: 'boolean',\n                        description: 'Whether to check SSL certificate details',\n                        default: true\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const { include_headers = true, check_ssl = true } = args;\n            try {\n                const securityReport = {\n                    url: window.location.href,\n                    protocol: window.location.protocol,\n                    isSecure: window.location.protocol === 'https:',\n                    timestamp: new Date().toISOString()\n                };\n\n                // Check security headers if requested\n                if (include_headers) {\n                    const headers = await fetch(window.location.href, { method: 'HEAD' })\n                        .then(response => {\n                            const headerData = {};\n                            response.headers.forEach((value, key) => {\n                                if (key.toLowerCase().includes('security') || \n                                    ['content-security-policy', 'x-frame-options', 'x-xss-protection',\n                                     'strict-transport-security', 'x-content-type-options'].includes(key.toLowerCase())) {\n                                    headerData[key] = value;\n                                }\n                            });\n                            return headerData;\n                        });\n                    securityReport.securityHeaders = headers;\n                }\n\n                // Check SSL certificate if requested and available\n                if (check_ssl && window.location.protocol === 'https:') {\n                    const certificateInfo = {\n                        issuer: document.querySelector('meta[name=\"ssl-issuer\"]')?.content || 'Not available in client',\n                        validFrom: document.querySelector('meta[name=\"ssl-valid-from\"]')?.content || 'Not available in client',\n                        validTo: document.querySelector('meta[name=\"ssl-valid-to\"]')?.content || 'Not available in client'\n                    };\n                    securityReport.sslCertificate = certificateInfo;\n                }\n\n                // Check for common security issues\n                securityReport.securityIssues = [];\n                \n                // Check if site uses HTTPS\n                if (!securityReport.isSecure) {\n                    securityReport.securityIssues.push({\n                        severity: 'high',\n                        issue: 'Site does not use HTTPS',\n                        recommendation: 'Enable HTTPS to secure data transmission'\n                    });\n                }\n\n                // Check for mixed content\n                const mixedContent = Array.from(document.querySelectorAll('img, script, link, iframe'))\n                    .filter(el => {\n                        const src = el.src || el.href;\n                        return src && src.startsWith('http:');\n                    });\n                if (mixedContent.length > 0) {\n                    securityReport.securityIssues.push({\n                        severity: 'medium',\n                        issue: 'Mixed content detected',\n                        details: `${mixedContent.length} resources loaded over insecure HTTP`,\n                        recommendation: 'Update resource URLs to use HTTPS'\n                    });\n                }\n\n                // Check for vulnerable input fields\n                const passwordFields = Array.from(document.querySelectorAll('input[type=\"password\"]'));\n                const insecurePasswordFields = passwordFields.filter(field => !field.closest('form')?.hasAttribute('autocomplete'));\n                if (insecurePasswordFields.length > 0) {\n                    securityReport.securityIssues.push({\n                        severity: 'medium',\n                        issue: 'Insecure password fields detected',\n                        details: `${insecurePasswordFields.length} password fields without proper autocomplete attributes`,\n                        recommendation: 'Add autocomplete attributes to password fields'\n                    });\n                }\n\n                return { success: true, result: securityReport };\n            } catch (error) {\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static GenerateImage = {\n        function: {\n            name: 'generate_image',\n            description: 'Generate an image using DALL-E',\n            parameters: {\n                type: 'object',\n                properties: {\n                    prompt: {\n                        type: 'string',\n                        description: 'The image generation prompt'\n                    },\n                    size: {\n                        type: 'string',\n                        description: 'Image size (256x256, 512x512, or 1024x1024)',\n                        enum: ['256x256', '512x512', '1024x1024'],\n                        default: '1024x1024'\n                    },\n                    style: {\n                        type: 'string',\n                        description: 'Image style (vivid or natural)',\n                        enum: ['vivid', 'natural'],\n                        default: 'vivid'\n                    },\n                    openai_key: {\n                        type: 'string',\n                        description: 'The OpenAI API key to use for image generation',\n                    }\n                },\n                required: ['prompt', 'openai_key']\n            }\n        },\n        execute: async function(scope, args) {\n            const { prompt, size = '1024x1024', style = 'vivid', openai_key } = args;\n            \n            // Get OpenAI key from settings\n            const openaiKey = openai_key;\n            if (!openaiKey) {\n                return { \n                    success: false, \n                    error: 'OpenAI API key not set. Please set it using the set-openai-key command.' \n                };\n            }\n\n            try {\n                const response = await fetch('https://api.openai.com/v1/images/generations', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': `Bearer ${openaiKey}`\n                    },\n                    body: JSON.stringify({\n                        prompt,\n                        n: 1,\n                        size,\n                        style\n                    })\n                });\n\n                const data = await response.json();\n                if (data.error) {\n                    return { success: false, error: data.error.message };\n                }\n\n                return { success: true, result: data.data[0].url };\n            } catch (error) {\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static GetPageMetadata = {\n        function: {\n            name: 'get_page_metadata',\n            description: 'Get metadata about the current webpage',\n            parameters: {\n                type: 'object',\n                properties: {}  // No parameters needed\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                const metadata = {\n                    title: document.title,\n                    description: document.querySelector('meta[name=\"description\"]')?.content,\n                    keywords: document.querySelector('meta[name=\"keywords\"]')?.content,\n                    author: document.querySelector('meta[name=\"author\"]')?.content,\n                    url: window.location.href,\n                    domain: window.location.hostname,\n                    lastModified: document.lastModified,\n                    language: document.documentElement.lang,\n                    charset: document.characterSet,\n                    viewport: document.querySelector('meta[name=\"viewport\"]')?.content\n                };\n\n                return { success: true, result: metadata };\n            } catch (error) {\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static ExtractPageContent = {\n        function: {\n            name: 'extract_page_content',\n            description: 'Extract main content from the current webpage',\n            parameters: {\n                type: 'object',\n                properties: {\n                    include_images: {\n                        type: 'boolean',\n                        description: 'Whether to include image information',\n                        default: false\n                    },\n                    include_links: {\n                        type: 'boolean',\n                        description: 'Whether to include link information',\n                        default: false\n                    },\n                    include_html: {\n                        type: 'boolean',\n                        description: 'Whether to include HTML (for complex queries)',\n                        default: false\n                    },\n                    body_query_selector: {\n                        type: 'string',\n                        description: 'The query selector to use to extract the body content (optional)'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const { include_images = false, include_links = false, include_html = false, body_query_selector } = args;\n            try {\n                // Get main content (prioritize article or main content areas)\n                let mainContent = document.querySelector('article, [role=\"main\"], main, .main-content, #main-content') || document.body;\n                if (body_query_selector) {\n                    mainContent = document.querySelector(body_query_selector);\n                }\n                \n                const wordLimit = 10000;\n                const charLimit = wordLimit * 5;\n                const chatCount = mainContent.textContent.trim().length;\n                const wordCount = mainContent.textContent.trim().split(/\\s+/).length;\n\n                if(chatCount > charLimit || wordCount > wordLimit) {\n\n                    const trimmedContent = mainContent.textContent.trim().slice(0, 5000);\n                    const trimmedWordCount = trimmedContent.split(/\\s+/).length;\n                    const trimmedChatCount = trimmedContent.length;\n\n                    const content = `\n${trimmedContent}\n\n\nContent is too long. The output has been limited. Try again with a more specific query or use the body_query_selector to target a specific part of the page.\nChat count: ${trimmedChatCount} / ${chatCount}, Word count: ${trimmedWordCount} / ${wordCount}\n                    `.trim();\n\n                    return {\n                        success: true,\n                        content: content\n                    };\n                }\n\n\n                const content = {\n                    text: mainContent.textContent.trim(),\n                    wordCount: wordCount,\n                    html: include_html ? mainContent.innerHTML : null\n                };\n\n                if (include_images) {\n                    content.images = Array.from(mainContent.querySelectorAll('img')).map(img => ({\n                        src: img.src,\n                        alt: img.alt,\n                        width: img.width,\n                        height: img.height\n                    }));\n                }\n\n                if (include_links) {\n                    content.links = Array.from(mainContent.querySelectorAll('a')).map(link => ({\n                        text: link.textContent.trim(),\n                        href: link.href,\n                        title: link.title\n                    }));\n                }\n\n                return { success: true, result: content };\n            } catch (error) {\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static PromptUserForConfirmation = {\n        function: {\n            name: 'prompt_user_for_confirmation',\n            description: 'Prompt the user for confirmation',\n            parameters: {\n                properties: {\n                    prompt: {\n                        type: 'string',\n                        description: 'The prompt to show the user'\n                    }\n                },\n                required: ['prompt']\n            }\n        },\n        execute: async function(scope, args) {\n            const { prompt } = args;\n            return new Promise((resolve) => {\n                // Generate a unique ID for this request\n                const requestId = 'confirm_' + Math.random().toString(36).substr(2, 9);\n                \n                // Create a one-time message handler for this specific request\n                const messageHandler = (event) => {\n                    const payload = event.data.payload?.payload || event.data.payload;\n                    scope.logMessage('CB_DIALOG_RETURN', payload);\n                    if (event.data.type === 'CB_DIALOG_RETURN' && payload.requestId === requestId) {\n                        window.removeEventListener('message', messageHandler);\n                        scope.logMessage('CB_DIALOG_RETURN', event.data);\n                        if (payload.confirmed) {\n                            resolve({\n                                success: true,\n                                result: 'User granted permission'\n                            });\n                        } else {\n                            resolve({\n                                success: false,\n                                error: 'User denied permission'\n                            });\n                        }\n                    }\n                };\n                \n                // Add the message listener\n                window.addEventListener('message', messageHandler);\n\n                // Create dialog HTML with animations\n                const dialogHtml = `\n                    <div class=\"cc-dialog\" style=\"animation: messageAppear 0.3s ease-in-out forwards;\">\n                        <div class=\"cc-dialog-content\">\n                            <p>${prompt}</p>\n                            <div class=\"cc-dialog-buttons\">\n                                <button class=\"cc-button confirm\" data-action=\"confirm\">Confirm</button>\n                                <button class=\"cc-button cancel\" data-action=\"cancel\">Cancel</button>\n                            </div>\n                        </div>\n                    </div>\n                `;\n\n                // Send message to command bar to show confirmation dialog\n                window.postMessage({\n                    type: 'CB_SHOW_CONFIRMATION_DIALOG',\n                    payload: {\n                        requestId: requestId,\n                        prompt: prompt,\n                        dialogHtml: dialogHtml\n                    }\n                }, window.location.origin);\n            });\n        }\n    };\n\n    static PromptUserForInput = {\n        function: {\n            name: 'prompt_user_for_input',\n            description: 'Prompt the user for input, you can spawn multiple prompts at once if needed',\n            parameters: {\n                properties: {\n                    type: {\n                        type: 'string',\n                        description: 'Input type (text, number, date, etc)'\n                    },\n                    name: {\n                        type: 'string',\n                        description: 'The name of the input'\n                    },\n                    default_value: {\n                        type: 'string',\n                        description: 'The default value of the input'\n                    },\n                    prompt: {\n                        type: 'string',\n                        description: 'The prompt to show the user, optional'\n                    }\n                },\n                required: ['type', 'name']\n            }\n        },\n        execute: async function(scope, args) {\n            const { type, name, default_value, prompt } = args;\n            return new Promise((resolve) => {\n                // Generate a unique ID for this request\n                const requestId = 'input_' + Math.random().toString(36).substr(2, 9);\n                \n                // Create a one-time message handler for this specific request\n                const messageHandler = (event) => {\n                    const payload = event.data.payload?.payload || event.data.payload;\n                    scope.logMessage('CB_DIALOG_RETURN', payload);\n                    if (event.data.type === 'CB_DIALOG_RETURN' && payload.requestId === requestId) {\n                        \n                        window.removeEventListener('message', messageHandler);\n                        const input = payload.input;\n                        if (input !== null) {\n                            resolve({\n                                success: true,\n                                result: input\n                            });\n                        } else {\n                            resolve({\n                                success: false,\n                                error: 'User did not provide input'\n                            });\n                        }\n                    }\n                };\n                \n                // Add the message listener\n                window.addEventListener('message', messageHandler);\n\n                // Send message to command bar to show input dialog\n                window.postMessage({\n                    type: 'CB_SHOW_INPUT_DIALOG',\n                    payload: {\n                        requestId: requestId,\n                        type: type,\n                        name: name,\n                        defaultValue: default_value,\n                        prompt: prompt\n                    }\n                }, window.location.origin);\n            });\n        }\n    };\n\n    static ColorPicker = {\n        function: {\n            name: 'color_picker',\n            description: 'Pick colors from the current webpage or get color suggestions',\n            parameters: {\n                type: 'object',\n                properties: {\n                    mode: {\n                        type: 'string',\n                        description: 'Mode of operation (pick, suggest, extract)',\n                        enum: ['pick', 'suggest', 'extract'],\n                        default: 'pick'\n                    },\n                    theme: {\n                        type: 'string',\n                        description: 'Color theme for suggestions (warm, cool, monochrome, complementary)',\n                        default: 'warm'\n                    },\n                    format: {\n                        type: 'string',\n                        description: 'Color format to return (hex, rgb, hsl)',\n                        enum: ['hex', 'rgb', 'hsl'],\n                        default: 'hex'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const { mode = 'pick', theme = 'warm', format = 'hex' } = args;\n            try {\n                let result = {};\n\n                // Helper function to convert colors between formats\n                const convertColor = (color, targetFormat) => {\n                    // Create a temporary div to use the browser's color parsing\n                    const div = document.createElement('div');\n                    div.style.color = color;\n                    document.body.appendChild(div);\n                    const computed = window.getComputedStyle(div).color;\n                    document.body.removeChild(div);\n\n                    // Parse RGB values\n                    const [r, g, b] = computed.match(/\\d+/g).map(Number);\n\n                    switch (targetFormat) {\n                        case 'hex':\n                            return `#${[r, g, b].map(x => x.toString(16).padStart(2, '0')).join('')}`;\n                        case 'rgb':\n                            return `rgb(${r}, ${g}, ${b})`;\n                        case 'hsl':\n                            // Convert RGB to HSL\n                            const rr = r / 255;\n                            const gg = g / 255;\n                            const bb = b / 255;\n                            const max = Math.max(rr, gg, bb);\n                            const min = Math.min(rr, gg, bb);\n                            let h, s, l = (max + min) / 2;\n\n                            if (max === min) {\n                                h = s = 0;\n                            } else {\n                                const d = max - min;\n                                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                                switch (max) {\n                                    case rr: h = (gg - bb) / d + (gg < bb ? 6 : 0); break;\n                                    case gg: h = (bb - rr) / d + 2; break;\n                                    case bb: h = (rr - gg) / d + 4; break;\n                                }\n                                h /= 6;\n                            }\n\n                            return `hsl(${Math.round(h * 360)}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;\n                    }\n                };\n\n                switch (mode) {\n                    case 'pick':\n                        // Create a message handler for the color picker\n                        return new Promise((resolve) => {\n                            const requestId = 'colorpick_' + Math.random().toString(36).substr(2, 9);\n                            \n                            // Create one-time message handler\n                            const messageHandler = (event) => {\n                                if (event.data.type === 'COLOR_PICKED' && event.data.requestId === requestId) {\n                                    window.removeEventListener('message', messageHandler);\n                                    const color = convertColor(event.data.color, format);\n                                    resolve({\n                                        success: true,\n                                        result: {\n                                            color,\n                                            element: event.data.elementInfo,\n                                            originalFormat: event.data.originalFormat\n                                        }\n                                    });\n                                }\n                            };\n                            \n                            window.addEventListener('message', messageHandler);\n\n                            // Send message to activate color picker\n                            window.postMessage({\n                                type: 'ACTIVATE_COLOR_PICKER',\n                                payload: {\n                                    requestId: requestId\n                                }\n                            }, window.location.origin);\n                        });\n\n                    case 'suggest':\n                        // Generate color suggestions based on theme\n                        const suggestions = {\n                            warm: ['#FF6B6B', '#FFA07A', '#FFD93D', '#FF8C42', '#FF4E50'],\n                            cool: ['#4A90E2', '#67B26F', '#4CA1AF', '#5D4157', '#2F80ED'],\n                            monochrome: ['#2C3E50', '#34495E', '#547891', '#95A5A6', '#BDC3C7'],\n                            complementary: ['#2ECC71', '#E74C3C', '#3498DB', '#F1C40F', '#9B59B6']\n                        };\n\n                        result = {\n                            theme,\n                            colors: suggestions[theme].map(color => ({\n                                [format]: convertColor(color, format),\n                                hex: color\n                            }))\n                        };\n                        break;\n\n                    case 'extract':\n                        // Extract dominant colors from the page\n                        const elements = document.querySelectorAll('*');\n                        const colors = new Set();\n                        \n                        elements.forEach(el => {\n                            const style = window.getComputedStyle(el);\n                            ['color', 'backgroundColor', 'borderColor'].forEach(prop => {\n                                const color = style[prop];\n                                if (color && color !== 'transparent' && color !== 'rgba(0, 0, 0, 0)') {\n                                    colors.add(color);\n                                }\n                            });\n                        });\n\n                        result = {\n                            colors: Array.from(colors)\n                                .slice(0, 10) // Limit to top 10 colors\n                                .map(color => ({\n                                    [format]: convertColor(color, format),\n                                    original: color\n                                }))\n                        };\n                        break;\n                }\n\n                return { success: true, result };\n            } catch (error) {\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static ManageAPIKey = {\n        function: {\n            name: 'manage_api_key',\n            description: 'Get or set API keys for various services. Use this to manage API keys for OpenAI and other services.',\n            parameters: {\n                properties: {\n                    action: {\n                        type: 'string',\n                        description: 'The action to perform: \"get\" or \"set\"',\n                        enum: ['get', 'set']\n                    },\n                    key_name: {\n                        type: 'string',\n                        description: 'The name of the API key to manage (e.g., \"openai-key\")',\n                        enum: ['openai-key']\n                    },\n                    value: {\n                        type: 'string',\n                        description: 'The API key value to set (only required for \"set\" action)'\n                    },\n                    reason: {\n                        type: 'string',\n                        description: 'The reason for the action, recipient of the key'\n                    }\n                },\n                required: ['action', 'key_name', 'reason']\n            }\n        },\n        execute: async function(scope, args) {\n            let { action, key_name, value, reason } = args;\n            \n            if (action === 'get') {\n                const is_encrypted = scope.settings?.encryptedKeys?.get(key_name);\n                let keyExists = is_encrypted || (scope.settings?.keyValuePairs?.has(key_name) && \n                                scope.settings?.keyValuePairs?.get(key_name)?.length > 0);\n\n                scope.logMessage('ManageAPIKeyDEBUG: ' + JSON.stringify({\n                    scope,\n                    settings: scope.settings,\n                    is_encrypted,\n                    keyExists,\n                    key_name,\n                    value,\n                    reason\n                }));\n                \n                if(is_encrypted) {\n                    const response = await scope.promptAccessRequest({\n                        prompt: `Allow ${reason} (and this page) access to ${key_name}?`,\n                        default_value: 'yes'\n                    });\n                    if(!response.confirmed ){\n                        return response;\n                    }\n\n                    const promise = new Promise((resolve, reject) => {\n                                            \n                        window.addEventListener('message', (event) => {\n                            if(event.data.type === 'CARBON_GET_ENCRYPTED_VALUE_RESPONSE' && event.data.payload.key === key_name) {\n                                resolve(event.data.payload.value);\n                            }\n                        });\n                        scope.bar.postMessage({\n                            type: 'GET_ENCRYPTED_VALUE',\n                            payload: {\n                                key: key_name\n                            }\n                        });\n                    });\n\n                    value = await promise;\n                }\n                \n                return {\n                    success: true,\n                    result: {\n                        key_name,\n                        is_set: keyExists,\n                        is_encrypted: is_encrypted,\n                        value: value\n                    }\n                };\n            } else if (action === 'set') {\n                if (!value) {\n                    return {\n                        success: false,\n                        error: 'Value is required for set action'\n                    };\n                }\n\n                if (key_name === 'openai-key') {\n                    // Use the existing SetOpenAIKey tool's functionality\n                    return await CarbonBarHelpTools.SetOpenAIKey.execute(scope, { key: value });\n                }\n\n                // For future key types, add handling here\n                return {\n                    success: false,\n                    error: `Unsupported key_name: ${key_name}`\n                };\n            }\n\n            return {\n                success: false,\n                error: `Invalid action: ${action}`\n            };\n        }\n    };\n}\nif(window.sbaiTools) {\n    window.sbaiTools['GeneralTools'] = GeneralTools;\n} else {\n    window.sbaiTools = {\n        'GeneralTools': GeneralTools\n    };\n}\n\nexport { GeneralTools };","class BitbucketTools {\n    static name = \"BitbucketTools\";\n\n    static _CarbonBarPageLoadFilter = (window) => {\n        return window.location.hostname.includes('bitbucket.org');\n    }\n\n    static CreatePullRequest = {\n        function: {\n            name: 'create_pullrequest',\n            description: 'Create a new pull request',\n            parameters: {\n                properties: {\n                    title: {\n                        type: 'string',\n                        description: 'Title of the pull request'\n                    },\n                    source_branch: {\n                        type: 'string',\n                        description: 'Source branch name'\n                    },\n                    target_branch: {\n                        type: 'string',\n                        description: 'Target branch name (default: main/master)'\n                    },\n                    description: {\n                        type: 'string',\n                        description: 'Description of the changes'\n                    },\n                    reviewers: {\n                        type: 'string',\n                        description: 'Comma-separated list of reviewer usernames'\n                    }\n                },\n                required: ['title', 'source_branch']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                // Get repository info from current URL\n                const [workspace, repo] = window.location.pathname.split('/').filter(Boolean);\n                \n                const prData = {\n                    title: args.title,\n                    source: {\n                        branch: { name: args.source_branch }\n                    },\n                    target: {\n                        branch: { name: args.target_branch || 'main' }\n                    },\n                    description: args.description || '',\n                    reviewers: args.reviewers ? \n                        args.reviewers.split(',').map(username => ({ username: username.trim() })) \n                        : []\n                };\n\n                const response = await scope.$http.post(\n                    `/api/2.0/repositories/${workspace}/${repo}/pullrequests`,\n                    prData\n                );\n\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error creating pull request:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static GetPullRequests = {\n        function: {\n            name: 'get_pullrequests',\n            description: 'Get list of pull requests',\n            parameters: {\n                properties: {\n                    state: {\n                        type: 'string',\n                        description: 'Filter by PR state (OPEN, MERGED, DECLINED, SUPERSEDED)'\n                    },\n                    author: {\n                        type: 'string',\n                        description: 'Filter by author username'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                // Get repository info from current URL\n                const [workspace, repo] = window.location.pathname.split('/').filter(Boolean);\n                \n                let endpoint = `/api/2.0/repositories/${workspace}/${repo}/pullrequests`;\n                const params = new URLSearchParams();\n                \n                if (args.state) params.append('state', args.state);\n                if (args.author) params.append('q', `author.username=\"${args.author}\"`);\n                \n                if (params.toString()) {\n                    endpoint += `?${params.toString()}`;\n                }\n\n                const response = await scope.$http.get(endpoint);\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error getting pull requests:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static GetRecentCommits = {\n        function: {\n            name: 'get_recent_commits',\n            description: 'Get recent commits for a branch',\n            parameters: {\n                properties: {\n                    branch: {\n                        type: 'string',\n                        description: 'Branch name (default: main/master)'\n                    },\n                    limit: {\n                        type: 'number',\n                        description: 'Maximum number of commits to return (default: 10)'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                // Get repository info from current URL\n                const [workspace, repo] = window.location.pathname.split('/').filter(Boolean);\n                \n                const branch = args.branch || 'main';\n                const limit = args.limit || 10;\n                \n                const endpoint = `/api/2.0/repositories/${workspace}/${repo}/commits/${branch}?limit=${limit}`;\n                \n                const response = await scope.$http.get(endpoint);\n                \n                // Format the commit data\n                const commits = response.data.values.map(commit => ({\n                    hash: commit.hash,\n                    message: commit.message,\n                    author: commit.author.raw,\n                    date: commit.date,\n                    links: commit.links\n                }));\n\n                return { success: true, result: commits };\n            } catch (error) {\n                scope.logError('Error getting recent commits:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n}\n\nif(window.sbaiTools) {\n    window.sbaiTools['BitbucketTools'] = BitbucketTools;\n} else {\n    window.sbaiTools = {\n        'BitbucketTools': BitbucketTools\n    };\n}\n\nexport { BitbucketTools }; ","class HackerNewsTools {\n    static name = \"HackerNewsTools\";\n\n    static _CarbonBarPageLoadFilter = (window) => {\n        return window.location.hostname.includes('news.ycombinator.com');\n    }\n\n    static _CarbonBarBuildScope = async (scope) => {\n        try{\n            var articleName = document.querySelector('.titleline a');\n            scope.appName = `HackerNews [${articleName}]`;\n        } catch (error) {\n            scope.logError('Error building scope', error);\n            scope.appName = 'HackerNews [Unknown Article]';\n        }\n\n        return scope;\n    }\n\n    static ReadPage = {\n        function: {\n            name: 'read_hn_page',\n            description: 'Read a specific page from Hacker News',\n            parameters: {\n                properties: {\n                    page_number: {\n                        type: 'number',\n                        description: 'The page number to read (defaults to 1)'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                const pageNum = args.page_number || 1;\n                const response = await scope.$http.get(`https://news.ycombinator.com/news?p=${pageNum}`);\n                \n                // Parse the HTML response\n                const parser = new DOMParser();\n                const doc = parser.parseFromString(response.data, 'text/html');\n                \n                // Extract stories\n                const stories = [];\n                const storyRows = doc.querySelectorAll('.athing');\n                \n                storyRows.forEach(row => {\n                    const subtext = row.nextElementSibling;\n                    const title = row.querySelector('.titleline a');\n                    const score = subtext?.querySelector('.score');\n                    const age = subtext?.querySelector('.age');\n                    const comments = subtext?.querySelectorAll('a')[3]; // Last link is usually comments\n                    \n                    stories.push({\n                        id: row.id,\n                        title: title?.textContent,\n                        url: title?.href,\n                        score: score?.textContent,\n                        age: age?.textContent,\n                        comments: comments?.textContent,\n                        commentsUrl: comments?.href ? `https://news.ycombinator.com/${comments.href}` : null\n                    });\n                });\n\n                return { \n                    success: true, \n                    result: {\n                        page: pageNum,\n                        stories: stories\n                    }\n                };\n            } catch (error) {\n                scope.logError('Error reading HN page:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n}\n\nif(window.sbaiTools) {\n    window.sbaiTools['HackerNewsTools'] = HackerNewsTools;\n} else {\n    window.sbaiTools = {\n        'HackerNewsTools': HackerNewsTools\n    };\n}\n\nexport { HackerNewsTools }; ","class JiraTools {\n    static name = \"JiraTools\";\n\n    static _CarbonBarPageLoadFilter = (window) => {\n        // Match Jira Cloud or Server URLs\n        return window.location.hostname.includes('atlassian.net') || \n               window.location.pathname.includes('/jira/');\n    }\n\n    static GetSprints = {\n        function: {\n            name: 'get_sprints',\n            description: 'Get list of sprints for a board',\n            parameters: {\n                properties: {\n                    board_id: {\n                        type: 'string',\n                        description: 'The ID of the board to get sprints from'\n                    },\n                    state: {\n                        type: 'string',\n                        description: 'Filter sprints by state (active, future, closed)'\n                    }\n                },\n                required: ['board_id']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                let endpoint = `/rest/agile/1.0/board/${args.board_id}/sprint`;\n                if (args.state) {\n                    endpoint += `?state=${args.state}`;\n                }\n                \n                const response = await scope.$http.get(endpoint);\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error getting sprints:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static ReadSprintBoard = {\n        function: {\n            name: 'read_sprint_board',\n            description: 'Get all issues in a sprint board',\n            parameters: {\n                properties: {\n                    board_id: {\n                        type: 'string',\n                        description: 'The ID of the board to read'\n                    },\n                    sprint_id: {\n                        type: 'string',\n                        description: 'The ID of the sprint to read (optional)'\n                    }\n                },\n                required: ['board_id']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                let endpoint = `/rest/agile/1.0/board/${args.board_id}/issue`;\n                if (args.sprint_id) {\n                    endpoint += `?sprint=${args.sprint_id}`;\n                }\n                \n                const response = await scope.$http.get(endpoint);\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error reading sprint board:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static CreateIssue = {\n        function: {\n            name: 'create_issue',\n            description: 'Create a new issue (bug or task)',\n            parameters: {\n                properties: {\n                    project_key: {\n                        type: 'string',\n                        description: 'The project key (e.g., \"PROJ\")'\n                    },\n                    issue_type: {\n                        type: 'string',\n                        description: 'Type of issue (bug, task)'\n                    },\n                    summary: {\n                        type: 'string',\n                        description: 'Issue summary/title'\n                    },\n                    description: {\n                        type: 'string',\n                        description: 'Detailed description of the issue'\n                    },\n                    priority: {\n                        type: 'string',\n                        description: 'Issue priority (Highest, High, Medium, Low, Lowest)'\n                    },\n                    assignee: {\n                        type: 'string',\n                        description: 'Username of the assignee'\n                    },\n                    sprint_id: {\n                        type: 'string',\n                        description: 'ID of the sprint to add the issue to'\n                    }\n                },\n                required: ['project_key', 'issue_type', 'summary']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                const issueData = {\n                    fields: {\n                        project: { key: args.project_key },\n                        issuetype: { name: args.issue_type },\n                        summary: args.summary,\n                        description: args.description,\n                        priority: args.priority ? { name: args.priority } : undefined,\n                        assignee: args.assignee ? { name: args.assignee } : undefined\n                    }\n                };\n\n                // Create the issue\n                const response = await scope.$http.post('/rest/api/2/issue', issueData);\n                \n                // If sprint_id is provided, add issue to sprint\n                if (args.sprint_id && response.data.id) {\n                    await scope.$http.post(`/rest/agile/1.0/sprint/${args.sprint_id}/issue`, {\n                        issues: [response.data.id]\n                    });\n                }\n\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error creating issue:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static ChangeIssueStatus = {\n        function: {\n            name: 'change_issue_status',\n            description: 'Change the status of an issue',\n            parameters: {\n                properties: {\n                    issue_key: {\n                        type: 'string',\n                        description: 'The issue key (e.g., \"PROJ-123\")'\n                    },\n                    status: {\n                        type: 'string',\n                        description: 'The new status to set'\n                    }\n                },\n                required: ['issue_key', 'status']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                // First get available transitions\n                const transitionsResponse = await scope.$http.get(\n                    `/rest/api/2/issue/${args.issue_key}/transitions`\n                );\n                \n                // Find the transition ID that matches the requested status\n                const transition = transitionsResponse.data.transitions.find(\n                    t => t.name.toLowerCase() === args.status.toLowerCase()\n                );\n\n                if (!transition) {\n                    throw new Error(`Status transition to \"${args.status}\" not available`);\n                }\n\n                // Perform the transition\n                const response = await scope.$http.post(\n                    `/rest/api/2/issue/${args.issue_key}/transitions`,\n                    { transition: { id: transition.id } }\n                );\n\n                return { success: true, result: `Issue ${args.issue_key} status changed to ${args.status}` };\n            } catch (error) {\n                scope.logError('Error changing issue status:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n}\n\nif(window.sbaiTools) {\n    window.sbaiTools['JiraTools'] = JiraTools;\n} else {\n    window.sbaiTools = {\n        'JiraTools': JiraTools\n    };\n}\n\nexport { JiraTools }; ","class RocketChatTools {\n    static name = \"RocketChatTools\";\n\n    static _CarbonBarPageLoadFilter = (window) => {\n        // Match Rocket.Chat URLs - both cloud and self-hosted instances\n        return window.location.hostname.includes('rocket.chat') || \n               document.querySelector('meta[name=\"application-name\"][content=\"Rocket.Chat\"]') !== null;\n    }\n\n    static ReadChannel = {\n        function: {\n            name: 'read_channel',\n            description: 'Read messages from a Rocket.Chat channel',\n            parameters: {\n                properties: {\n                    channel_name: {\n                        type: 'string',\n                        description: 'Name of the channel to read'\n                    },\n                    limit: {\n                        type: 'number',\n                        description: 'Maximum number of messages to return (default: 50)'\n                    },\n                    include_threads: {\n                        type: 'boolean',\n                        description: 'Whether to include thread messages (default: false)'\n                    }\n                },\n                required: ['channel_name']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                const limit = args.limit || 50;\n                const includeThreads = args.include_threads || false;\n\n                // Get the Meteor instance from window\n                const Meteor = window.Meteor;\n                if (!Meteor) {\n                    throw new Error('Rocket.Chat Meteor instance not found');\n                }\n\n                // Get room ID from channel name\n                const room = await new Promise((resolve, reject) => {\n                    Meteor.call('getRoomByName', args.channel_name, (error, result) => {\n                        if (error) reject(error);\n                        else resolve(result);\n                    });\n                });\n\n                if (!room) {\n                    throw new Error(`Channel \"${args.channel_name}\" not found`);\n                }\n\n                // Get messages\n                const messages = await new Promise((resolve, reject) => {\n                    Meteor.call('loadHistory', room._id, null, limit, null, (error, result) => {\n                        if (error) reject(error);\n                        else resolve(result.messages);\n                    });\n                });\n\n                // Format messages\n                let formattedMessages = messages.map(msg => ({\n                    id: msg._id,\n                    text: msg.msg,\n                    sender: msg.u.username,\n                    timestamp: msg.ts,\n                    attachments: msg.attachments,\n                    reactions: msg.reactions,\n                    threadCount: msg.tcount || 0,\n                    threadMainMessage: msg.tmid ? true : false\n                }));\n\n                // Get thread messages if requested\n                if (includeThreads) {\n                    const threadMainMessages = formattedMessages.filter(msg => msg.threadCount > 0);\n                    for (const mainMsg of threadMainMessages) {\n                        const threadMessages = await new Promise((resolve, reject) => {\n                            Meteor.call('getThreadMessages', mainMsg.id, (error, result) => {\n                                if (error) reject(error);\n                                else resolve(result);\n                            });\n                        });\n\n                        mainMsg.thread = threadMessages.map(msg => ({\n                            id: msg._id,\n                            text: msg.msg,\n                            sender: msg.u.username,\n                            timestamp: msg.ts,\n                            attachments: msg.attachments,\n                            reactions: msg.reactions\n                        }));\n                    }\n                }\n\n                return { \n                    success: true, \n                    result: {\n                        channel: {\n                            id: room._id,\n                            name: room.name,\n                            type: room.t,\n                            topic: room.topic,\n                            memberCount: room.usersCount\n                        },\n                        messages: formattedMessages\n                    }\n                };\n            } catch (error) {\n                scope.logError('Error reading channel:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n}\n\nif(window.sbaiTools) {\n    window.sbaiTools['RocketChatTools'] = RocketChatTools;\n} else {\n    window.sbaiTools = {\n        'RocketChatTools': RocketChatTools\n    };\n}\n\nexport { RocketChatTools }; ","\n//TODO: Reduce size of SM content returns\n\nclass SmarterMailTools {\n    static name = \"SmarterMailTools\";\n\n    static _CarbonBarPageLoadFilter = (window) => {\n        try{\n            const user = angular.element(document).injector().get('coreData').user;\n            if(user.username != null && user.username != '') {\n                //If system admin, don't allow tools to be called they have a seperate list of tools\n                if(user.isSysAdmin) {\n                    return false;\n                }\n                //smartermail user logged in\n                return true;\n            }\n            return false;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    static _CarbonBarBuildScope = async (scope) => {\n        scope.getService = (serviceName) => {\n            return angular.element(document).injector().get(serviceName);\n        }\n        scope.$http = scope.getService('$http');\n        scope.$rootScope = window.smRsHook.$root;\n        scope.getUserInfo = () => \n        {\n            return new Promise(async (resolve, reject) => {\n              try {\n                const userService = await scope.getService('userDataService');\n                const timeService = await scope.getService('userTimeService');\n                \n                resolve({\n                  displayName: userService.user.displayName,\n                  username: userService.user.username,\n                  emailAddress: userService.user.emailAddress,\n                  locale: userService.user.settings.userMailSettings.localeId,\n                  categories: userService.user.categories,\n                  tzid: timeService.userTimeZone.id\n                });\n              } catch (error) {\n                reject(error);\n              }\n            });\n        }\n\n        try{\n            var userInfo = await scope.getUserInfo();\n            scope.appName = `SmarterMail [${userInfo.emailAddress}]`;\n        } catch (error) {\n            scope.logError('Error building scope', error);\n            scope.appName = 'SmarterMail [Unknown User]';\n        }\n\n        return scope;\n    }\n\n    static _CarbonBarSystemPrompt = async (basePrompt, scope) => {\n        var systemPrompt = basePrompt + '\\n';\n        try {\n            var userInfo = await scope.getUserInfo();\n            //include the user info\n            systemPrompt += `The user is \"${userInfo.displayName}\" with email \"${userInfo.emailAddress}\" and timezone \"${userInfo.tzid}\" and locale \"${userInfo.locale}\"`;\n    \n            //include the categories\n            if (userInfo.categories) {\n              systemPrompt += `. User categories: ${userInfo.categories.map(category => category.name).join(', ')}`;\n            }\n          } catch (error) {\n            scope.logError('Error getting user info:', error);\n            systemPrompt += '. Unable to get user info.';\n          }\n\n        return systemPrompt;\n    }\n\n\n    static GetHelp = {\n        function: {\n            name: 'get_help',\n            description: 'User is asking for help with something',\n            parameters: {\n                properties: {\n                    topic: {\n                        type: 'string'\n                    },\n                    command: {\n                        type: 'string'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            scope.logMessage(`GetHelp: ${JSON.stringify(args, null, 2)}`);\n            const { topic, command } = args;\n            const result = await scope.$http.get(`https://api.openai.com/v1/chat/completions`, {\n                headers: {\n                    'Authorization': `Bearer ${scope.apiKey}`\n                }\n            });\n            scope.logMessage(`GetHelp result: ${JSON.stringify(result, null, 2)}`);\n            var response = result.data.choices[0].message.content;\n            return { success: true, result: response };\n        }\n    };\n\n    \n    static GetCategoriesAndOtherFolders = {\n        function: {\n            name: 'get_categories_and_other_folders',\n            description: \"Get user's categories and folders for non-email sources\",\n        },\n        execute: async function(scope, args) {\n            const catService = scope.getService('coreDataCategories');\n            const coreDataCalendar = scope.getService('coreDataCalendar');\n            const coreDataNotes = scope.getService('coreDataNotes');\n            const coreDataTasks = scope.getService('coreDataTasks');\n            const coreDataContacts = scope.getService('coreDataContacts');\n            await catService.loadUsersCategories();           \n            const categories = await catService.getUsersCategories();\n            //const folderList = await coreMailService.getFolderList();\n            var folderList = [];\n\n            coreDataCalendar.loadSources().then(function () {\n                var calendars = coreDataCalendar.getCalendars();\n                var calItems = [];\n                for (var i = 0; i < calendars.length; i++) {\n                    if (calendars[i].isSharedItem)\n                        continue;\n                    calItems.push({ translation: calendars[i].untranslatedName ? $translate.instant(calendars[i].untranslatedName) : calendars[i].name, value: calendars[i].id });\n                }\n                folderList['calendar'] = calItems;\n            });\n            coreDataNotes.ensureSourcesLoadedPromise().then(function () {\n                var notes = coreDataNotes.getSources();\n                notes = notes.filter((f) => {\n                    return !f.isSharedItem;\n                });\n                folderList['notes'] = notes;\n            });\n\n            coreDataTasks.ensureSourcesLoadedPromise().then(function () {\n                var tasks = coreDataTasks.getSources();\n                tasks = tasks.filter((f) => {\n                    return !f.isSharedItem;\n                });\n                folderList['tasks'] = tasks;\n            });\n\n            coreDataContacts.ensureSourcesLoadedPromise().then(function () {\n                $scope.contactFolders = coreDataContacts.getSources();\n                var contacts = coreDataContacts.getSources();\n                contacts = contacts.filter((f) => {\n                    return !f.isSharedItem;\n                });\n                folderList['contacts'] = contacts;\n            });\n            \n            return { success: true, result: { categories, folderList } };\n        }\n    };\n\n    static UpdateCategory = {\n        function: {\n            name: 'update_category',\n            description: \"Update or create a category for the user's account.\",\n            parameters: {\n                properties: {\n                    guid: {\n                        type: 'string',\n                        description: 'The guid of the category to update (only for updating)'\n                    },\n                    name: {\n                        type: 'string'\n                    },\n                    color_index: {\n                        type: 'number',\n                        description: 'The color index (-1 = none/default, 0 = red, 1 = orange, 3 = yellow, 4 = green, 7 = blue, 8 = purple)'\n                    },\n                    is_default: {\n                        type: 'boolean',\n                        description: 'Whether this category is the default category'\n                    }\n                },\n                required: ['name']\n            }\n        },\n        execute: async function(scope, args) {\n            const { guid, name, color_index, is_default } = args;\n            var catResult = await scope.$http.get(\"~/api/v1/categories/user-category-settings\");\n            var catSettings = catResult.categorySettings;\n\n            if(is_default) {\n                catSettings.defaultCategory = name;\n            }\n\n            if(guid) {\n                catSettings.categories = catSettings.categories.filter(cat => cat.guid !== guid);\n            }\n            catSettings.categories.push({ guid, name, colorIndex: color_index });\n            try {\n                await scope.$http.post(\"~/api/v1/categories/user-category-settings\", catSettings);\n                return { success: true, result: \"Categories set\" };\n            } catch (error) {\n                scope.logError('Error setting categories:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    //TODO: Newsfeeds?\n    //TODO: basic user settings, contents filters, etc\n\n    //TODO: (later) domain and system admin tools \n    //TODO: force user verification based on tool property\n\n\n\n    static GetEmailFolders = {\n        function: {\n            name: 'get_email_folders',\n            description: \"Get folders for the user's emails\"\n        },\n        execute: async function(scope, args) {\n            const coreMailService = scope.getService('coreDataMail');\n            const folderList = await coreMailService.getFolderList();\n            return { success: true, result: folderList };\n        }\n    };\n\n    static RemoveFolders = {\n        function: {\n            name: 'remove_folders',\n            description: 'Remove folders for the user.',\n            parameters: {\n                properties: {\n                    folder_ids: {\n                        type: 'string',\n                        description: \"The id's of the folders to remove. Child folders are also removed. (comma separated)\"\n                    }\n                },\n                required: ['folder_ids']\n            }\n        },\n        execute: async function(scope, args) {\n            let folderIds = args.folder_ids.split(',').map(f => f.trim());\n            const coreMailService = scope.getService('coreDataMail');\n            await coreMailService.loadMailTree();\n\n            const tasksService = scope.getService('coreDataTasks');\n            await tasksService.ensureSourcesLoadedPromise();\n\n            const notesService = scope.getService('coreDataNotes');\n            await notesService.ensureSourcesLoadedPromise();\n\n            const contactService = scope.getService('coreDataContacts');\n            await contactService.ensureSourcesLoadedPromise();\n\n            const calendarService = scope.getService('coreDataCalendar');\n            await calendarService.loadSources();\n\n            let totalRemovedFolders = 0;\n            let removedFolders = [];\n            let aiOutput = '';\n\n            for(var i = 0; i < folderIds.length; i++) {\n                //email folders\n                const emailFolders = await coreMailService.getFolderList();\n                var emailFolder = null;\n                for(var j = 0; j < emailFolders.length; j++) { \n                    scope.logMessage(`Checking email folder: ${emailFolders[j].name} (${emailFolders[j].id})`, `Match: ${emailFolders[j].id} == ${folderIds[i]}`);\n                    if(emailFolders[j].id == folderIds[i]) {\n                        emailFolder = emailFolders[j];\n                        break;\n                    }\n                }\n                if(emailFolder) {\n                    try {\n                        var result = await scope.$http.post('~/api/v1/folders/delete-folder', { \n                            folder: emailFolder.path,\n                            parentFolder: \"\"\n                        });\n                        scope.logMessage('RemoveEmailFolder result:', result);\n                        if(result.data.success) {\n                            removedFolders.push({name: emailFolder.name, id: emailFolder.id});\n                        } else {\n                            aiOutput += `Error removing email folder: ${folderIds[i]} - ${result.data.message}\\n`;\n                        }\n                    } catch (error) {\n                        scope.logError('Error removing email folder:', error);\n                        aiOutput += `Error removing email folder: ${folderIds[i]} - ${error.data?.message}\\n`;\n                    }\n                }\n            }\n            if(removedFolders.length > 0) {\n                aiOutput += `Removed email folders: ${removedFolders.map(rf => rf.name).join(', ')}\\n`;\n                folderIds = folderIds.filter(f => !removedFolders.some(rf => rf.id == f));\n                totalRemovedFolders += removedFolders.length;\n                removedFolders = [];\n            }\n\n            for(var i = 0; i < folderIds.length; i++) {\n                const taskFolders = await tasksService.getSources();\n                var taskFolder = null;\n                for(var j = 0; j < taskFolders.length; j++) { \n                    scope.logMessage(`Checking task folder: ${taskFolders[j].name} (${taskFolders[j].folderId})`, `Match: ${taskFolders[j].folderId} == ${folderIds[i]}`);\n                    if(taskFolders[j].folderId == folderIds[i]) {\n                        taskFolder = taskFolders[j];\n                        break;\n                    }\n                }\n                if(taskFolder) {\n                    try {\n                        var result = await scope.$http.post('~/api/v1/tasks/sources/delete', { \n                            folder: taskFolder.name,\n                            uid: taskFolder.id\n                        });\n                        scope.logMessage('RemoveTaskFolder result:', result);\n                        if(result.success) {\n                            removedFolders.push({name: taskFolder.name, id: taskFolder.id});\n                        } else {\n                            aiOutput += `Error removing task folder: ${folderIds[i]}\\n`;\n                        }\n                    } catch (error) {\n                        scope.logError('Error removing task folder:', error);\n                        aiOutput += `Error removing task folder: ${folderIds[i]}\\n`;\n                    }\n                }\n            }\n            if(removedFolders.length > 0) {\n                aiOutput += `Removed task folders: ${removedFolders.map(rf => rf.name).join(', ')}\\n`;\n                folderIds = folderIds.filter(f => !removedFolders.some(rf => rf.id == f));\n                totalRemovedFolders += removedFolders.length;\n                removedFolders = [];\n            }\n\n            for(var i = 0; i < folderIds.length; i++) {\n                const noteFolders = await notesService.getSources();\n                var noteFolder = null;\n                for(var j = 0; j < noteFolders.length; j++) { \n                    scope.logMessage(`Checking note folder: ${noteFolders[j].displayName} (${noteFolders[j].folderId})`, `Match: ${noteFolders[j].folderId} == ${folderIds[i]}`);\n                    if(noteFolders[j].folderId == folderIds[i]) {\n                        noteFolder = noteFolders[j];\n                        break;\n                    }\n                }\n                if(noteFolder) {\n                    try {\n                        var result = await scope.$http.post('~/api/v1/notes/sources/delete', { \n                            uid: noteFolder.itemID,\n                            folder: noteFolder.displayName\n                        });\n                        scope.logMessage('RemoveNoteFolder result:', result);\n                        if(result.success) {\n                            removedFolders.push({name: noteFolder.displayName, id: noteFolder.itemID});\n                        } else {\n                            aiOutput += `Error removing note folder: ${folderIds[i]}\\n`;\n                        }\n                    } catch (error) {\n                        scope.logError('Error removing note folder:', error);\n                        aiOutput += `Error removing note folder: ${folderIds[i]}\\n`;\n                    }\n                }\n            }\n            if(removedFolders.length > 0) {\n                aiOutput += `Removed note folders: ${removedFolders.map(rf => rf.displayName).join(', ')}\\n`;\n                folderIds = folderIds.filter(f => !removedFolders.some(rf => rf.id == f));\n                totalRemovedFolders += removedFolders.length;\n                removedFolders = [];\n            }\n\n            for(var i = 0; i < folderIds.length; i++) {\n                const contactFolders = await contactService.getSources();\n                var contactFolder = null;\n                for(var j = 0; j < contactFolders.length; j++) { \n                    scope.logMessage(`Checking contact folder: ${contactFolders[j].displayName} (${contactFolders[j].folderId})`, `Match: ${contactFolders[j].folderId} == ${folderIds[i]}`);\n                    if(contactFolders[j].folderId == folderIds[i]) {\n                        contactFolder = contactFolders[j];\n                        break;\n                    }\n                }\n                if(contactFolder) {\n                    try {\n                        var result = await scope.$http.post('~/api/v1/contacts/address-book/delete', { \n                            uid: contactFolder.itemID,\n                            //folder: contactFolder.displayName //not needed\n                        });\n                        scope.logMessage('RemoveContactFolder result:', result);\n                        if(result.success) {\n                            removedFolders.push({name: contactFolder.displayName, id: contactFolder.itemID});\n                        } else {\n                            aiOutput += `Error removing contact folder: ${folderIds[i]}\\n`;\n                        }\n                    } catch (error) {\n                        scope.logError('Error removing contact folder:', error);\n                        aiOutput += `Error removing contact folder: ${folderIds[i]}\\n`;\n                    }\n                }\n            }\n            if(removedFolders.length > 0) {\n                aiOutput += `Removed contact folders: ${removedFolders.map(rf => rf.displayName).join(', ')}\\n`;\n                folderIds = folderIds.filter(f => !removedFolders.some(rf => rf.id == f));\n                totalRemovedFolders += removedFolders.length;\n                removedFolders = [];\n            }\n\n\n            for(var i = 0; i < folderIds.length; i++) {\n                const calendarFolders = await calendarService.getCalendars();\n                var calendarFolder = null;\n                for(var j = 0; j < calendarFolders.length; j++) { \n                    scope.logMessage(`Checking calendar folder: ${calendarFolders[j].name} (${calendarFolders[j].folderId})`, `Match: ${calendarFolders[j].folderId} == ${folderIds[i]}`);\n                    if(calendarFolders[j].folderId == folderIds[i]) {\n                        calendarFolder = calendarFolders[j];\n                        break;\n                    }\n                }\n                if(calendarFolder) {\n                    try {\n                        var result = await scope.$http.post(`~/api/v1/calendars/calendar-delete/${calendarFolder.id}`);\n                        scope.logMessage('RemoveCalendarFolder result:', result);\n                        if(result.success) {\n                            removedFolders.push({name: calendarFolder.name, id: calendarFolder.id});\n                        } else {\n                            aiOutput += `Error removing calendar folder: ${folderIds[i]}\\n`;\n                        }\n                    } catch (error) {\n                        scope.logError('Error removing calendar folder:', error);\n                        aiOutput += `Error removing calendar folder: ${folderIds[i]}\\n`;\n                    }\n                }\n            }\n            if(removedFolders.length > 0) {\n                aiOutput += `Removed calendar folders: ${removedFolders.map(rf => rf.name).join(', ')}\\n`;\n                folderIds = folderIds.filter(f => !removedFolders.some(rf => rf.id == f));\n                totalRemovedFolders += removedFolders.length;\n                removedFolders = [];    \n            }\n\n            if(totalRemovedFolders > 0) {\n                return { success: true, result: aiOutput };\n            } else {\n                aiOutput += \"\\nNo folders removed\";\n                return { success: false, error: aiOutput };\n            }\n        }\n    };\n\n    static UpdateFolder = {\n        function: {\n            name: 'update_folder',\n            description: 'Update or create a folder for the user.',\n            parameters: {\n                properties: {\n                    type: {\n                        type: 'string',\n                        description: 'The type of the folder to update (email, calendar, notes, tasks, contacts)'\n                    },\n                    name: {\n                        type: 'string',\n                        description: 'The name of the folder to update'\n                    },\n                    parent_folder_id: {\n                        type: 'string',\n                        description: 'The parent folder_id to nest the folder in (optional, only for email)'\n                    },\n                    folder_id: {\n                        type: 'string',\n                        description: 'The id of the folder to update (only for updating)'\n                    },\n                    color: {\n                        type: 'string',\n                        description: 'The hex color of the calendar to update (only for calendars and tasks)'\n                    }\n                },\n                required: ['type', 'name']\n            }\n        },\n        execute: async function(scope, args) {\n            const { type, name, parent_folder_id, folder_id, color } = args;\n\n            if(type == 'email') {\n                const coreMailService = scope.getService('coreDataMail');\n                await coreMailService.loadMailTree();\n                const folderList = await coreMailService.getFolderList();\n                if(folder_id) {\n                    //update in place\n                    var folder = folderList.find(f => f.id == folder_id);\n                    var parentFolder = parent_folder_id ? folderList.find(f => f.id == parent_folder_id) : null;\n                    \n                    if(parent_folder_id && !parentFolder) {\n                        scope.logMessage(`Parent folder not found: ${parent_folder_id}`, folderList.map(f => `(${f.id} - ${f.path})`));\n                        return { success: false, error: `Parent folder not found: ${parent_folder_id}, folderList: ${folderList.map(f => ` (${f.id} - ${f.path})`)}` };\n                    }\n\n                    if(folder) {\n                        //This uses the folder names so we need to get the folders by id first\n                        try {\n                            var result = await scope.$http.post(\"~/api/v1/folders/folder-put\", {\n                                folder: name,\n                                parentFolder: parentFolder?.path,\n                                //ownerEmailAddress: \"\"\n                            });\n                            return { success: true, result: result.data };\n                        } catch (error) {\n                            scope.logError('Error updating folder:', error);\n                            return { success: false, error: error.data };\n                        }\n                    } else {\n                        return { success: false, error: `Folder to update not found: folder_id = ${folder_id}` };\n                    }\n                } else {\n                    var parentFolder = parent_folder_id ? folderList.find(f => f.id == parent_folder_id) : null;\n                    try {\n                        var result = await scope.$http.post(\"~/api/v1/folders/folder-put\", {\n                            folder: name,\n                            parentFolder: parentFolder?.path,\n                        });\n                        return { success: true, result: result.data };\n                    } catch (error) {\n                        scope.logError('Error creating folder:', error);\n                        return { success: false, error: error.message };\n                    }\n                }\n\n            } else if(type == 'calendar') {\n                var calendarService = scope.getService('coreDataCalendar');\n                await calendarService.loadSources();\n                var calendars = await calendarService.getCalendars();\n\n                if(folder_id) {\n                    var calendar = calendars.find(c => c.folderId == folder_id);\n                    if(calendar) {\n                        try {\n                            let request = await scope.$http.post('~/api/v1/calendars/calendar', {\n                                setting: {\n                                    id: calendar.id,\n                                    friendlyName: name || calendar.friendlyName,\n                                    calendarViewColor: color || calendar.calendarViewColor,\n                                    isPrimary: calendar.isPrimary\n                                }\n                            });\n                            if(request.data.success) {\n                                return { success: true, result: request.data };\n                            } else {\n                                if(request.data)\n                                    request.data.success = false; //Fixes an issue with calendar api\n                                return { success: false, error: request.data };\n                            }\n                        } catch (error) {\n                            if(error.data)\n                                error.data.success = false; //Fixes an issue with calendar api\n                            scope.logError('Error updating calendar:', error);\n                            return { success: false, error: error.data };\n                        }\n                    } else {\n                        return { success: false, error: `Calendar to update not found: folder_id = ${folder_id}` };\n                    }\n                } else {\n                    try {\n                        let request = await scope.$http.post('~/api/v1/calendars/calendar-put', {\n                            setting: {\n                                friendlyName: name,\n                                calendarViewColor: color || \"#7FC56F\",\n                                isPrimary: false\n                            }\n                        });\n                        if(request.data.success) {\n                            return { success: true, result: request.data };\n                        } else {\n                            if(request.data)\n                                request.data.success = false; //Fixes an issue with calendar api\n                            return { success: false, error: request.data };\n                        }\n                    } catch (error) {\n                        if(error.data)\n                            error.data.success = false; //Fixes an issue with calendar api\n                        scope.logError('Error adding calendar:', error);\n                        return { success: false, error: error.data };\n                    }\n                }\n                \n            } else if(type == 'notes') {\n                var notesService = scope.getService('coreDataNotes');\n                await notesService.ensureSourcesLoadedPromise();\n                var noteFolders = await notesService.getSources();\n\n                if(folder_id) {\n                    var noteFolder = noteFolders.find(n => n.folderId == folder_id);\n                    if(noteFolder) {\n                        try {\n                            let request = await scope.$http.post('~/api/v1/notes/sources/edit', {\n                                folder: name,\n                                uid: noteFolder.itemID\n                            });\n                            if(request.data.success) {\n                                return { success: true, result: request.data };\n                            } else {\n                                return { success: false, error: request.data };\n                            }\n                        } catch (error) {\n                            scope.logError('Error updating note:', error);\n                            return { success: false, error: error.data };\n                        }\n                    } else {\n                        return { success: false, error: `Note to update not found: folder_id = ${folder_id}` };\n                    }\n                } else {\n                    try {\n                        let request = await scope.$http.post('~/api/v1/notes/sources/add', {\n                            folder: name\n                        });\n                        if(request.data.success) {\n                            return { success: true, result: request.data };\n                        } else {\n                            return { success: false, error: request.data };\n                        }\n                    } catch (error) {\n                        scope.logError('Error adding note:', error);\n                        return { success: false, error: error.data };\n                    }\n                }\n\n            } else if(type == 'tasks') {\n\n                var tasksService = scope.getService('coreDataTasks');\n                await tasksService.ensureSourcesLoadedPromise();\n                var taskFolders = await tasksService.getSources();\n\n                if(folder_id) {\n                    var taskFolder = taskFolders.find(t => t.folderId == folder_id);\n                    if(taskFolder) {\n                        try {\n                            let request = await scope.$http.post('~/api/v1/tasks/sources/edit', {\n                                folder: name,\n                                uid: taskFolder.id,\n                                color: color || \"#7FC56F\"\n                            });\n                            if(request.data.success) {\n                                return { success: true, result: request.data };\n                            } else {\n                                return { success: false, error: request.data };\n                            }\n                        } catch (error) {\n                            scope.logError('Error updating task:', error);\n                            return { success: false, error: error.data };\n                        }\n                    } else {\n                        return { success: false, error: `Task to update not found: folder_id = ${folder_id}` };\n                    }\n                } else {\n                    try {\n                        let request = await scope.$http.post('~/api/v1/tasks/sources/add', {\n                            folder: name,\n                            color: color || \"#7FC56F\"\n                        });\n                        if(request.data.success) {\n                            return { success: true, result: request.data };\n                        } else {\n                            return { success: false, error: request.data };\n                        }\n                    } catch (error) {\n                        scope.logError('Error adding task:', error);\n                        return { success: false, error: error.data };\n                    }\n                }\n                \n            } else if(type == 'contacts') {\n                var contactService = scope.getService('coreDataContacts');\n                var contactFolders = await contactService.getSources();\n                \n                if(folder_id) {\n                    var folder = contactFolders.find(f => f.folderId == folder_id);\n                    if(folder) {\n                        try {\n                            let request = await scope.$http.post('~/api/v1/contacts/address-book/edit', {\n                                folder: name,\n                                uid: folder.itemID,\n                                //ownerEmailAddress: \"\"\n                            });\n                            if(request.data.success) {\n                                return { success: true, result: request.data };\n                            } else {\n                                return { success: false, error: request.data };\n                            }\n                        } catch (error) {\n                            scope.logError('Error updating folder:', error);\n                            return { success: false, error: error.data };\n                        }\n                    } else {\n                        return { success: false, error: `Folder to update not found: folder_id = ${folder_id}` };\n                    }\n                } else {\n                    try {\n                        let request = await scope.$http.post('~/api/v1/contacts/address-book/add', {\n                            folder: name,\n                            //ownerEmailAddress: \"\"\n                        });\n                        if(request.data.success) {\n                            return { success: true, result: request.data };\n                        } else {\n                            return { success: false, error: request.data };\n                        }\n                    } catch (error) {\n                        scope.logError('Error adding folder:', error);\n                        return { success: false, error: error.data };\n                    }\n                }\n            }\n            \n            return { success: false, error: `Folder type not supported: ${type}, supported types are: email, calendar, notes, tasks, contacts` };\n        }\n    }\n\n\n\n\n    static ReadEmailsFast = {\n        function: {\n            name: 'read_emails_fast',\n            description: 'Get the emails including only the subject and metadata for a given folder',\n            parameters: {\n                properties: {\n                    message_filter: {\n                        type: 'number',\n                        description: '0 = most recent, 1 = unread, 2 = flagged, 3 = calendar, 4 = replied, -1 = all'\n                    },\n                    folder: {\n                        type: 'string',\n                        description: 'The folder to read emails from (default = inbox)'\n                    },\n                    max_results: {\n                        type: 'number',\n                        description: 'The maximum number of results to return'\n                    },\n                    startIndex: {\n                        type: 'number',\n                        description: 'The index to start from'\n                    }\n                },\n                required: ['message_filter']\n            }\n        },\n        execute: async function(scope, args) {\n            const coreMailService = scope.getService('coreDataMail');\n            const folder = args.folder?.toLowerCase() || 'inbox';\n            const maxResults = args.max_results || 10;\n            const startIndex = args.startIndex || 0;\n\n            let searchCriteria = {\n                folder: folder,\n                ownerEmailAddress: '',\n                sortType: 5, // internalDate\n                sortAscending: false,\n                startIndex: startIndex,\n                maxResults: maxResults\n            };\n\n            // Add filter based on message_filter parameter\n            if (args.message_filter !== -1) {\n                searchCriteria.searchFlags = {};\n                switch(args.message_filter) {\n                    case 0: // most recent - no additional flags needed\n                        break;\n                    case 1: // unread\n                        searchCriteria.searchFlags[0] = false; \n                        break;\n                    case 2: // flagged\n                        searchCriteria.searchFlags[4] = true;\n                        break;\n                    case 3: // calendar\n                        searchCriteria.searchFlags[8] = true;\n                        break;\n                    case 4: // replied\n                        searchCriteria.searchFlags[1] = true;\n                        break;\n                }\n            }\n\n            try {\n                const result = await scope.$http.post(\"~/api/v1/mail/messages\", searchCriteria);\n                return { success: true, result: result.data };\n            } catch (error) {\n                scope.logError('Error fetching emails:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static ReadEmail = {\n        function: {\n            name: 'read_email',\n            description: 'Get the full email data for a given email by folder and uid',\n            parameters: {\n                properties: {\n                    uid: {\n                        type: 'string',\n                        description: 'The uid of the email to read'\n                    },\n                    folder: {\n                        type: 'string',\n                        description: 'The folder to read emails from (default = inbox)'\n                    },\n                    include_attachments: {\n                        type: 'boolean',\n                        description: 'Whether to include attachments in the email data (default = false)'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                const parameters = {\n                    'Folder': args.folder || 'inbox',\n                    'UID': args.uid,\n                    'OwnerEmailAddress': \"\"\n                };\n\n                // Get the full message data\n                const messageResponse = await scope.$http.post(\"~/api/v1/mail/message\", parameters);\n                \n                // If attachments are requested, get them\n                if (args.include_attachments && messageResponse.data.messageData.hasAttachments) {\n                    const attachmentResponse = await scope.$http.post(\"~/api/v1/mail/message/attachments\", parameters);\n                    messageResponse.data.messageData.attachments = attachmentResponse.data.attachments;\n                }\n\n                return { success: true, result: messageResponse.data.messageData };\n            } catch (error) {\n                scope.logError('Error fetching email:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static GetCalendarEvents = {\n        function: {\n            name: \"get_calendar_events\",\n            description: \"Get calendar events for a given date range\",\n            parameters: {\n                properties: {\n                    start_date: {\n                        type: 'string',\n                        description: 'The start date of the range to get events for (YYYY-MM-DDTHH:mm:ss)'\n                    },\n                    end_date:{ \n                        type: 'string',\n                        description: 'The end date of the range to get events for (YYYY-MM-DDTHH:mm:ss)'\n                    },\n                    max_results: {\n                        type: 'number',\n                        description: 'The maximum number of results to return (default = 10)'\n                    },\n                    startIndex: {\n                        type: 'number',\n                        description: 'The index to start from (default = 0)'\n                    }\n                },\n                required: ['start_date', 'end_date']\n            }\n        },\n        execute: async function(scope, args) {\n            const cs = scope.getService('coreDataCalendar');\n            await cs.loadSources();\n            const maxResults = args.max_results || 10;\n            const startIndex = args.startIndex || 0;\n            const calendarId = args.calendar_id || (await cs.getCalendars()).filter(x=> x.isPrimary)[0].id;\n\n            const calendar = (await cs.getCalendars()).filter(x=> x.id == calendarId)[0];\n            \n            const startDate = moment(args.start_date);\n            const endDate = moment(args.end_date);\n\n\n            var params = JSON.stringify({\n                startDate: moment.utc(startDate),\n                endDate: moment.utc(endDate),\n            });\n            var result = await scope.$http.post(\"~/api/v1/calendars/events/\" + calendar.owner + \"/\" + calendar.id, params);\n            var events = result.data.events;\n\n            return { success: true, result: events };\n        }\n    };\n\n    static GetNotes = {\n        function: {\n            name: 'get_notes',\n            description: 'Get notes sorted by most recently edited',\n            parameters: {\n                properties: {\n                    max_results: {\n                        type: 'number',\n                        description: 'The maximum number of results to return (default = 5)'\n                    },\n                    startIndex: {\n                        type: 'number',\n                        description: 'The index to start from (default = 0)'\n                    },\n                    search_text: {\n                        type: 'string',\n                        description: \"Text to search for in notes (default = '')\"\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const notesService = scope.getService('coreDataNotes');\n            const maxResults = args.max_results || 5;\n            const startIndex = args.startIndex || 0;\n\n            await notesService.ensureSourcesLoadedPromise();\n            await notesService.ensureNotesLoadedPromise();\n            \n            const sources = notesService.getSources();\n            scope.logMessage('SOURCES', sources);\n            // Set search parameters if provided\n            if (args.search_text) {\n                notesService.parameters.searchText = args.search_text;\n            }\n\n            // Get filtered notes\n            const notes = notesService.getFilteredNotes();\n            \n            // Apply pagination\n            const paginatedNotes = notes.slice(startIndex, startIndex + maxResults);\n            \n            // Format the response\n            const formattedNotes = paginatedNotes.map(note => ({\n                id: note.id,\n                title: note.subject,\n                content: note.text,\n                color: note.color,\n                dateCreated: note.dateCreated,\n                lastModified: note.lastModifiedUTC,\n                categories: note.categoriesString,\n                hasAttachments: note.hasAttachments\n            }));\n\n            return { success: true, result: formattedNotes };\n        }\n    };\n\n    static GetTasks = {\n        function: {\n            name: \"get_tasks\",\n            description: \"Get tasks sorted by most recently edited\",\n            parameters: {\n                properties: {\n                    max_results: {\n                        type: \"number\",\n                        description: \"The maximum number of results to return (default = 5)\"\n                    },\n                    startIndex: {\n                        type: \"number\",\n                        description: \"The index to start from\"\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const tasksService = scope.getService('coreDataTasks');\n            const maxResults = args.max_results || 5;\n            const startIndex = args.startIndex || 0;\n\n            // Load sources and tasks\n            await tasksService.ensureSourcesLoadedPromise();\n            await tasksService.ensureTasksLoadedPromise();\n\n            // Get filtered tasks\n            const tasks = tasksService.getFilteredTasks();\n            \n            // Apply pagination\n            const paginatedTasks = tasks.slice(startIndex, startIndex + maxResults);\n            \n            return { success: true, result: paginatedTasks };\n        }\n    };\n\n    static GetContacts = {\n        function: {\n            name: 'get_contacts',\n            description: 'Get contacts sorted by most recently contacted',\n            parameters: {\n                properties: {\n                    search_query: {\n                        type: 'string',\n                        description: 'The search query to filter contacts by (searches all fields)'\n                    },\n                    max_results: {\n                        type: 'number',\n                        description: 'The maximum number of results to return (default = 5)'\n                    },\n                    startIndex: {\n                        type: 'number',\n                        description: 'The index to start from'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const contactsService = scope.getService('coreDataContacts');\n            const maxResults = args.max_results || 5;\n            const startIndex = args.startIndex || 0;\n\n            // Set search parameters if provided\n            if (args.search_query) {\n                contactsService.parameters.searchText = args.search_query;\n            }\n\n            // Load sources and contacts\n            await contactsService.ensureSourcesLoadedPromise();\n            await contactsService.ensureContactsLoadedPromise();\n\n            // Get filtered contacts\n            const contacts = contactsService.getFilteredContacts();\n            \n            // Apply pagination\n            const paginatedContacts = contacts.slice(startIndex, startIndex + maxResults);\n\n            const mappedContacts = paginatedContacts.map(contact => ({  \n                id: contact.id,\n                name: contact.displayAs,\n                email: contact.emailAddressList[0] || undefined,\n                phone: contact.phoneNumberList[0]?.number || undefined,\n                quick_notes: contact.additionalInfo || undefined,\n                flagInfo: contact.flagInfo,\n                categories: contact.categoriesString || undefined\n            }));\n            \n            return { success: true, result: mappedContacts };\n        }\n    };\n\n    //static OpenComposerWindow = {\n    //    function: {\n    //        name: \"OpenComposerWindow\",\n    //        description: \"Open the email composer window\",\n    //        parameters: {\n    //            properties: {\n    //                ai_prompt: {\n    //                    type: \"string\",\n    //                    description: \"The prompt that will be given to the reasoning model to generate the email content once the window is opened\"\n    //                }\n    //            }\n    //        }\n    //    },\n    //    execute: async function(scope, args) {\n    //        // Open composer window with AI prompt\n    //        const composerWindow = window.open('/composer', 'composer', 'width=800,height=600');\n    //        composerWindow.aiPrompt = args.ai_prompt;\n    //        return { success: true, result: `Composer window opened` };\n    //    }\n    //};\n\n    static NewOrUpdateNote = {\n        function: {\n            name: 'new_or_update_note',\n            description: 'Create a new note or update an existing one',\n            parameters: {\n                properties: {\n                    title: {\n                        type: 'string',\n                        description: 'The title of the note'\n                    },\n                    content: {\n                        type: 'string', \n                        description: 'The content of the note'\n                    },\n                    note_id: {\n                        type: 'string',\n                        description: 'The id of the note to update (guid)'\n                    },\n                    color: {\n                        type: 'string',\n                        description: 'The color of the note (white, yellow, pink, green, blue)'\n                    }\n                },\n                required: ['title', 'content']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                // First get the primary source\n                const sourcesResult = await scope.$http.get(\"~/api/v1/notes/sources\");\n                const sources = sourcesResult.data.sharedLists;\n                const primarySource = sources.find(s => s.isPrimary);\n                \n                if (!primarySource) {\n                    throw new Error('No primary notes source found');\n                }\n\n                // Format note object according to API requirements\n                const note = {\n                    subject: args.title,\n                    text: `<div>${args.content}</div>`, // Wrap content in div as expected by the API\n                    color: args.color || 'white',\n                    sourceOwner: primarySource.ownerUsername || \"~\",\n                    sourceId: primarySource.itemID,\n                    sourceName: primarySource.displayName,\n                    sourcePermission: primarySource.access,\n                    isVisible: primarySource.enabled\n                };\n\n                if (args.note_id) {\n                    note.id = args.note_id;\n                    // Update existing note\n                    const params = JSON.stringify(note);\n                    await scope.$http.post(`~/api/v1/notes/note-patch/${note.id}/${note.sourceId}/${note.sourceOwner}`, params);\n                } else {\n                    // Create new note\n                    const params = JSON.stringify(note);\n                    await scope.$http.post(`~/api/v1/notes/note-put/${note.sourceId}/${note.sourceOwner}/`, params);\n                }\n\n                return { success: true, result: `Note ${args.title} saved` };\n            } catch (error) {\n                scope.logError('Error saving note:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static NewOrUpdateContact = {\n        function: {\n            name: 'new_or_update_contact',\n            description: 'Create a new contact or update an existing one',\n            parameters: {\n                properties: {\n                    name: {\n                        type: 'string',\n                        description: 'The name of the contact'\n                    },\n                    email: {\n                        type: 'string',\n                        description: 'The email address of the contact'\n                    },\n                    phone: {\n                        type: 'string',\n                        description: 'The phone number of the contact'\n                    },\n                    address: {\n                        type: 'string',\n                        description: 'The address of the contact'\n                    },\n                    quick_notes: {\n                        type: 'string',\n                        description: 'Quick notes about the contact'\n                    },\n                    contact_id: {\n                        type: 'string',\n                        description: 'The id of the contact to update (guid)'\n                    }\n                },\n                required: ['name']\n            }\n        },\n        execute: async function(scope, args) {\n            const contactsService = scope.getService('coreDataContacts');\n            \n            // Load sources first\n            await contactsService.ensureSourcesLoadedPromise();\n            await contactsService.ensureContactsLoadedPromise();\n            const sources = contactsService.getSources();\n            \n            // Find primary source\n            const primarySource = sources.find(s => s.isPrimary);\n            if (!primarySource) {\n                throw new Error('No primary contacts source found');\n            }\n\n            const contact = {\n                id: args.contact_id || null,\n                displayAs: args.name,\n                email: args.email,\n                phoneNumberList: args.phone ? [{ number: args.phone }] : [],\n                busStreet: args.address,\n                additionalInfo: args.quick_notes,\n                source: primarySource,\n                sourceOwner: primarySource.ownerUsername,\n                sourceId: primarySource.itemID\n            };\n\n            if (args.contact_id) {\n                // Update existing contact\n                await contactsService.editContact(contact);\n            } else {\n                // Create new contact\n                await contactsService.addContact(contact);\n            }\n\n            return { success: true, result: `Contact ${args.name} saved` };\n        }\n    };\n\n    static NewOrUpdateTask = {\n        function: {\n            name: 'new_or_update_task',\n            description: 'Create a new task or update an existing one',\n            parameters: {\n                properties: {\n                    task_id: {\n                        type: 'string',\n                        description: 'The id of the task to update (guid)'\n                    },\n                    subject: {\n                        type: 'string',\n                        description: 'The subject of the task'\n                    },\n                    description: {\n                        type: 'string',\n                        description: 'The description of the task'\n                    },\n                    percent_complete: {\n                        type: 'number',\n                        description: 'The percentage of the task that is complete (0-100)'\n                    },\n                    start: {\n                        type: 'string',\n                        description: 'The start date of the task (YYYY-MM-DD HH:mm)'\n                    },\n                    due: {\n                        type: 'string',\n                        description: 'The due date of the task (YYYY-MM-DD HH:mm)'\n                    },\n                    reminder: {\n                        type: 'string',\n                        description: 'The reminder date of the task (YYYY-MM-DD HH:mm)'\n                    }\n                },\n                required: ['subject']\n            }\n        },\n        execute: async function(scope, args) {\n            const tasksService = scope.getService('coreDataTasks');\n\n            await tasksService.ensureSourcesLoadedPromise();\n            await tasksService.ensureTasksLoadedPromise();\n            \n            const sources = tasksService.getSources();\n            \n            // Find primary source\n            const primarySource = sources.find(s => s.isPrimary);\n            if (!primarySource) {\n                throw new Error('No primary tasks source found');\n            }\n\n            if(args.due && !args.start) {\n                args.start = moment().toDate();\n            }\n\n\n            const task = {\n                id: args.task_id || null,\n                description: args.description,\n                subject: args.subject,\n                percentComplete: args.percent_complete || 0,\n                due: args.due ? moment(args.due).toDate() : null,\n                start: args.start ? moment(args.start).toDate() : null,\n                reminder: args.reminder ? moment(args.reminder).toDate() : null,\n                sourceOwner: primarySource.owner,\n                sourceId: primarySource.id,\n                useDateTime: (args.start || args.due) ? true : false,\n                reminderSet: args.reminder ? true : false\n            };\n\n            scope.logMessage('TASK', task, args.due, args.start);\n\n            // Use saveTasks for both new and update\n            await tasksService.saveTasks([task]);\n\n            return { success: true, result: `Task ${args.subject} saved` };\n        }\n    };\n\n    static NewOrUpdateCalendarEvent = {\n        function: {\n            name: 'new_or_update_calendar_event',\n            description: 'Create a new calendar event or update an existing one',\n            parameters: {\n                properties: {\n                    event_id: {\n                        type: 'string',\n                        description: 'The id of the event to update (if it exists)'\n                    },\n                    subject: {\n                        type: 'string',\n                        description: 'The title of the event'\n                    },\n                    start_time: {\n                        type: 'string', \n                        description: 'The start time of the event (YYYY-MM-DDTHH:mm:ss)'\n                    },\n                    end_time: {\n                        type: 'string',\n                        description: 'The end time of the event (YYYY-MM-DDTHH:mm:ss)'\n                    },\n                    location: {\n                        type: 'string',\n                        description: 'The location of the event'\n                    },\n                    description: {\n                        type: 'string',\n                        description: 'The description of the event'\n                    },\n                    calendar_id: {\n                        type: 'string',\n                        description: 'The id of the calendar to add/update the event to (default is primary calendar)'\n                    }\n                },\n                required: ['subject', 'start_time', 'end_time']\n            }\n        },\n        execute: async function(scope, args) {\n            let responseContext = '';\n            const cs = scope.getService('coreDataCalendar');\n            await cs.loadSources();\n            const calendars = await cs.getCalendars();\n            let calendar = args.calendar_id ? calendars.find(x=> x.id == args.calendar_id) : calendars.find(x=> x.isPrimary);\n\n            if (!calendar) {\n                responseContext = `Calendar (${args.calendar_id}) not found, using primary calendar`;\n                calendar = calendars.find(x=> x.isPrimary);\n            }\n\n            // Format the event object according to API requirements\n            const event = {\n                id: args.event_id || null,\n                subject: args.subject,\n                start: {\n                    dt: moment(args.start_time).toISOString(),\n                    tz: moment.tz.guess()\n                },\n                end: {\n                    dt: moment(args.end_time).toISOString(), \n                    tz: moment.tz.guess()\n                },\n                location: args.location,\n                description: args.description,\n                calendarId: calendar.id,\n                calendarOwner: calendar.owner || null\n            };\n\n            try {\n                if (args.event_id) {\n                    // Update existing event\n                    await scope.$http.post(`~/api/v1/calendars/events/save/${calendar.owner}/${calendar.id}/${args.event_id}`, JSON.stringify(event));\n                } else {\n                    // Create new event\n                    await scope.$http.post(`~/api/v1/calendars/events/save/${calendar.owner}/${calendar.id}/null`, JSON.stringify(event));\n                }\n                \n                return { success: true, result: `Event ${args.subject} saved. ${responseContext}` };\n            } catch (error) {\n                scope.logError('Error saving event:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static SendMeetingInvite = {\n        function: {\n            name: 'send_meeting_invite',\n            description: 'Send a meeting invite',\n            parameters: {\n                properties: {\n                    to: {\n                        type: 'string',\n                        description: 'The email addresses to send the meeting invite to, separated by commas'\n                    },\n                    subject: {\n                        type: 'string',\n                        description: 'The subject of the meeting'\n                    },\n                    start_time: {\n                        type: 'string',\n                        description: 'The start time of the meeting'\n                    },\n                    end_time: {\n                        type: 'string',\n                        description: 'The end time of the meeting'\n                    },\n                    location: {\n                        type: 'string',\n                        description: 'The location of the meeting'\n                    },\n                    description: {\n                        type: 'string',\n                        description: 'The description of the meeting'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const calendarService = scope.getService('coreDataCalendar');\n            const emailService = scope.getService('coreDataMail');\n\n            // Create calendar event\n            const event = {\n                title: args.subject,\n                start: moment(args.start_time).toDate(),\n                end: moment(args.end_time).toDate(),\n                location: args.location,\n                description: args.description\n            };\n\n            // Add event to calendar\n            await calendarService.addEvents([event]);\n\n            // Send email invite\n            const emailData = {\n                to: args.to,\n                subject: args.subject,\n                body: `You are invited to: ${args.subject}\\n\\nWhen: ${args.start_time} - ${args.end_time}\\nWhere: ${args.location}\\n\\n${args.description}`,\n                isHtml: false\n            };\n\n            await emailService.sendEmail(emailData);\n            return { success: true, result: `Meeting invite sent to ${args.to}` };\n        }\n    };\n\n    static RemoveItems = {\n        function: {\n            name: 'remove_items',\n            description: 'Remove items from the system',\n            parameters: {\n                properties: {\n                    item_id: {\n                        type: 'string',\n                        description: \"The id's of the items to remove, comma separated. (id/guid only)\"\n                    },\n                    item_type: {\n                        type: 'string',\n                        description: 'The type of the item to remove - note, task, contact, event'\n                    },\n                    calendar_id: {\n                        type: 'string',\n                        description: 'The id of the calendar to remove the event from'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const ids = args.item_id.split(',').map(id => id.trim());\n            const type = args.item_type.toLowerCase();\n            const calendarId = args.calendar_id;\n            const cs = scope.getService('coreDataCalendar');\n            await cs.loadSources();\n            const calendar = (await cs.getCalendars()).filter(x=> x.id == calendarId)[0];\n            try{\n                let service;\n                switch(type) {\n                    case 'note':\n                        service = scope.getService('coreDataNotes');\n                        await service.removeNotes(ids);\n                        break;\n                    case 'task':\n                        service = scope.getService('coreDataTasks');\n                        await service.removeTasks(ids);\n                        break;\n                    case 'contact':\n                        // Get contacts service to find source info for the contacts\n                        service = scope.getService('coreDataContacts');\n                        await service.ensureSourcesLoadedPromise();\n                        await service.ensureContactsLoadedPromise();\n                        \n                        // Find the contacts to get their source info\n                        const contacts = ids.map(id => service.getContactById(id))\n                            .filter(contact => contact && contact.sourceId !== \"gal\") // Filter out null contacts and GAL contacts\n                            .map(contact => ({\n                                sourceOwner: contact.sourceOwner,\n                                sourceId: contact.sourceId,\n                                id: contact.id\n                            }));\n\n                        if (contacts.length === 0) {\n                            throw new Error('No valid contacts found to delete');\n                        }\n\n                        // Call delete-bulk API directly\n                        await scope.$http.post('~/api/v1/contacts/delete-bulk', JSON.stringify(contacts));\n                        break;\n                    case 'event':\n                        var deleteMetaData = [];\n                        for(var i = 0; i < ids.length; i++){\n                            deleteMetaData.push({ \"owner\": calendar.owner, \"calendarId\": calendar.id, \"eventId\": ids[i] });\n                        }\n\n                        scope.logMessage('DELETE METADATA', deleteMetaData);\n                        const params = JSON.stringify(deleteMetaData);\n                        var result = await scope.$http.post('~/api/v1/calendars/events/delete-bulk/', params);\n                        scope.logMessage('DELETE RESULT', result);\n\n                        await cs.removeCalendarEvents(ids);\n                        break;\n                    default:\n                        throw new Error('Invalid item type');\n                }\n            }catch(e){\n                scope.logError('Error removing items', e);\n                return { success: false, error: e.message };\n            }\n\n            return { success: true, result: `Items removed` };\n        }\n    };\n\n    static RemoveEmails = {\n        function: {\n            name: 'remove_emails',\n            description: 'Remove emails from the system',\n            parameters: {\n                properties: {\n                    uid: {\n                        type: 'string',\n                        description: \"The id's of the emails to remove, comma separated.\"\n                    },\n                    folder: {\n                        type: 'string',\n                        description: 'The folder to remove the emails from.'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const mailService = scope.getService('coreDataMail');\n            const uids = args.uid.split(',').map(id => id.trim());\n\n            const parameters = {\n                'UID': uids,\n                'folder': args.folder,\n                'ownerEmailAddress': '',\n                'moveToDeleted': true\n            };\n\n            await scope.$http.post(\"~/api/v1/mail/delete-messages\", parameters);\n            return { success: true, result: `Emails removed` };\n        }\n    };\n\n    static MoveEmails = {\n        function: {\n            name: 'move_emails',\n            description: 'Move emails to a different folder',\n            parameters: {\n                properties: {\n                    uid: {\n                        type: 'string',\n                        description: \"The uid's of the emails to move, comma separated (get uids with read_emails_fast tool).\"\n                    },\n                    src_folder: {\n                        type: 'string',\n                        description: 'The folder the emails are in.'\n                    },\n                    dest_folder: {\n                        type: 'string',\n                        description: 'The folder to move the emails to.'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const coreMailService = scope.getService('coreDataMail');\n\n            //uids need to not be strings\n            const uids = args.uid.split(',').map(id => id.trim()).map(id => parseInt(id));\n\n            //if src_folder is an integer, its a folder_id, fetch email folders and get the path\n            if(typeof args.src_folder === 'number'){\n                await coreMailService.loadMailTree();\n                const folders = await coreMailService.getFolderList();\n                const folder = folders.find(x => x.id == args.src_folder);\n                args.src_folder = folder.path;\n            }\n\n            //if dest_folder is an integer, its a folder_id, fetch email folders and get the path\n            if(typeof args.dest_folder === 'number'){\n                await coreMailService.loadMailTree();\n                const folders = await coreMailService.getFolderList();\n                const folder = folders.find(x => x.id == args.dest_folder);\n                args.dest_folder = folder.path;\n            }\n\n\n            const parameters = {\n                'UID': uids,\n                'folder': args.src_folder,\n                'ownerEmailAddress': '',\n                'destinationFolder': args.dest_folder,\n                'destinationOwnerEmailAddress': ''\n            };\n\n            await scope.$http.post(\"~/api/v1/mail/move-messages\", parameters);\n            return { success: true, result: `Emails moved to ${args.dest_folder}` };\n        }\n    };\n\n    static SetEmailProperties = {\n        function: {\n            name: 'set_email_properties',\n            description: 'Mark emails as read/unread, flagged/unflagged, or add tags',\n            parameters: {\n                properties: {\n                    uid: {\n                        type: 'string',\n                        description: \"The id's of the emails to mark, comma separated.\"\n                    },\n                    folder: {\n                        type: 'string',\n                        description: 'The folder the emails are in.'\n                    },\n                    read: {\n                        type: 'boolean',\n                        description: 'Whether to mark the emails as read or unread'\n                    },\n                    flagged: {\n                        type: 'boolean',\n                        description: 'Whether to mark the emails as flagged or unflagged'\n                    },\n                    tags: {\n                        type: 'string',\n                        description: 'The tags to add to the emails, comma separated'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            const mailService = scope.getService('coreDataMail');\n            const uids = args.uid.split(',').map(id => id.trim());\n\n            const parameters = {\n                'UID': uids,\n                'folder': args.folder,\n                'ownerEmailAddress': ''\n            };\n\n            if (args.read !== undefined) {\n                parameters.markRead = args.read;\n            }\n\n            if (args.flagged !== undefined) {\n                parameters.flagAction = {\n                    type: args.flagged ? 'SetBasic' : 'Clear'\n                };\n            }\n\n            if (args.tags) {\n                parameters.categories = args.tags.split(',').map(tag => tag.trim());\n            }\n\n            await scope.$http.post(\"~/api/v1/mail/messages-patch\", parameters);\n            return { success: true, result: `Emails marked as ${args.read ? 'read' : 'unread'}, ${args.flagged ? 'flagged' : 'unflagged'}, and tagged with ${args.tags}` };\n        }\n    };\n\n    static SendEmail = {\n        function: {\n            name: \"send_email\",\n            description: \"Send a simple email\",\n            parameters: {\n                properties: {\n                    to: {\n                        type: 'string',\n                        description: 'The email addresses to send the email to, separated by commas'\n                    },\n                    subject: {\n                        type: 'string',\n                        description: 'The subject of the email'\n                    },\n                    body: {\n                        type: 'string',\n                        description: 'The body of the email'\n                    },\n                    cc: {\n                        type: 'string',\n                        description: 'The email address to cc'\n                    },\n                    bcc: {\n                        type: 'string',\n                        description: 'The email address to bcc'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n\n                var userInfo = scope.getUserInfo();\n\n                const emailData = {\n                    to: args.to,\n                    subject: args.subject,\n                    body: args.body,\n                    cc: args.cc,\n                    bcc: args.bcc,\n                    isHtml: false\n                };\n\n\n                // Check if the to field is empty\n                if(!emailData.to || emailData.to.length == 0 || emailData.to == 'undefined' || emailData.to == 'null'){\n                    emailData.to = userInfo.emailAddress;\n                }\n\n                if(!emailData.subject || emailData.subject.length == 0 || emailData.subject == 'undefined' || emailData.subject == 'null'){\n                    emailData.subject = 'No subject';\n                }\n\n                if(!emailData.body || emailData.body.length == 0 || emailData.body == 'undefined' || emailData.body == 'null'){\n                    emailData.body = 'No body';\n                }\n\n                // Post directly to the mail API endpoint\n                await scope.$http.post('~/api/v1/mail/message-put', {\n                    to: emailData.to,\n                    cc: emailData.cc || '',\n                    bcc: emailData.bcc || '',\n                    date: new Date(),\n                    from: userInfo.emailAddress,\n                    replyTo: userInfo.emailAddress,\n                    subject: emailData.subject,\n                    messageHTML: `<div>${emailData.body}</div>`,\n                    priority: 1,\n                    selectedFrom: `default:${userInfo.emailAddress}`\n                });\n\n                return { success: true, result: 'Email sent successfully' };\n            } catch (error) {\n                scope.logError('Error sending email:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n} \n\n(window.sbaiTools ??= {}).SmarterMailTools = SmarterMailTools;\n\nexport { SmarterMailTools };","class SmarterTrackPortalTools {\n    static name = \"SmarterTrackPortalTools\";\n\n    static _CarbonBarPageLoadFilter = (window) => {\n        return window.location.hostname.includes('portal.smartertools.com');\n    }\n\n    static ReadCommunitySection = {\n        function: {\n            name: 'read_community_section',\n            description: 'Read a section of the SmarterTrack community portal',\n            parameters: {\n                properties: {\n                    section: {\n                        type: 'string',\n                        description: 'The section to read (recent, unread, votes, my_activity)'\n                    }\n                },\n                required: ['section']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                let endpoint;\n                switch(args.section.toLowerCase()) {\n                    case 'recent':\n                        endpoint = '/community/recent';\n                        break;\n                    case 'unread':\n                        endpoint = '/community/unread';\n                        break;\n                    case 'votes':\n                        endpoint = '/community/votes';\n                        break;\n                    case 'my_activity':\n                        endpoint = '/community/my-activity';\n                        break;\n                    default:\n                        throw new Error('Invalid section specified');\n                }\n\n                const response = await scope.$http.get(endpoint);\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error reading community section:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static ReadCommunityPost = {\n        function: {\n            name: 'read_community_post',\n            description: 'Read a specific community post',\n            parameters: {\n                properties: {\n                    post_id: {\n                        type: 'string',\n                        description: 'The ID of the post to read'\n                    }\n                },\n                required: ['post_id']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                const response = await scope.$http.get(`/community/post/${args.post_id}`);\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error reading community post:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static ReadKnowledgeBase = {\n        function: {\n            name: 'read_kb',\n            description: 'Search or browse the knowledge base',\n            parameters: {\n                properties: {\n                    search_query: {\n                        type: 'string',\n                        description: 'Search query for the knowledge base'\n                    },\n                    category: {\n                        type: 'string',\n                        description: 'Category to browse'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                let endpoint = '/kb';\n                if (args.search_query) {\n                    endpoint = `/kb/search?q=${encodeURIComponent(args.search_query)}`;\n                } else if (args.category) {\n                    endpoint = `/kb/category/${encodeURIComponent(args.category)}`;\n                }\n\n                const response = await scope.$http.get(endpoint);\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error reading knowledge base:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static ReadTicketQueue = {\n        function: {\n            name: 'read_ticket_queue',\n            description: 'Read tickets from a specific queue',\n            parameters: {\n                properties: {\n                    queue_id: {\n                        type: 'string',\n                        description: 'The ID of the queue to read'\n                    }\n                },\n                required: ['queue_id']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                const response = await scope.$http.get(`/tickets/queue/${args.queue_id}`);\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error reading ticket queue:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static ReadAllTickets = {\n        function: {\n            name: 'read_all_tickets',\n            description: 'Read all tickets with optional filtering',\n            parameters: {\n                properties: {\n                    status: {\n                        type: 'string',\n                        description: 'Filter by ticket status (open, closed, etc.)'\n                    },\n                    priority: {\n                        type: 'string',\n                        description: 'Filter by priority (low, medium, high)'\n                    }\n                }\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                let endpoint = '/tickets/all';\n                const params = new URLSearchParams();\n                \n                if (args.status) params.append('status', args.status);\n                if (args.priority) params.append('priority', args.priority);\n\n                if (params.toString()) {\n                    endpoint += `?${params.toString()}`;\n                }\n\n                const response = await scope.$http.get(endpoint);\n                return { success: true, result: response.data };\n            } catch (error) {\n                scope.logError('Error reading all tickets:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n}\n\nif(window.sbaiTools) {\n    window.sbaiTools['SmarterTrackPortalTools'] = SmarterTrackPortalTools;\n} else {\n    window.sbaiTools = {\n        'SmarterTrackPortalTools': SmarterTrackPortalTools\n    };\n}\n\nexport { SmarterTrackPortalTools }; ","class StackOverflowTools {\n    static name = \"StackOverflowTools\";\n\n    static _CarbonBarPageLoadFilter = (window) => {\n        return window.location.hostname.includes('stackoverflow.com');\n    }\n\n    static GetPageInfo = {\n        function: {\n            name: 'get_so_page_info',\n            description: 'Get information about the current Stack Overflow page',\n            parameters: {}\n        },\n        execute: async function(scope, args) {\n            try {\n                // Get page type and relevant information\n                const url = window.location.href;\n                const pageInfo = {\n                    type: 'unknown',\n                    data: {}\n                };\n\n                // Question page\n                if (url.includes('/questions/')) {\n                    pageInfo.type = 'question';\n                    const questionEl = document.querySelector('.question');\n                    if (questionEl) {\n                        pageInfo.data = {\n                            title: document.querySelector('#question-header h1')?.textContent?.trim(),\n                            votes: questionEl.querySelector('.js-vote-count')?.textContent?.trim(),\n                            views: document.querySelector('.js-view-count')?.textContent?.trim(),\n                            tags: Array.from(questionEl.querySelectorAll('.post-tag')).map(tag => tag.textContent),\n                            answers: Array.from(document.querySelectorAll('.answer')).map(answer => ({\n                                votes: answer.querySelector('.js-vote-count')?.textContent?.trim(),\n                                isAccepted: answer.classList.contains('accepted-answer'),\n                                answerId: answer.getAttribute('data-answerid')\n                            }))\n                        };\n                    }\n                }\n                // Search results page\n                else if (url.includes('/search')) {\n                    pageInfo.type = 'search';\n                    pageInfo.data = {\n                        query: new URLSearchParams(window.location.search).get('q'),\n                        results: Array.from(document.querySelectorAll('.question-summary')).map(result => ({\n                            title: result.querySelector('.question-hyperlink')?.textContent?.trim(),\n                            url: result.querySelector('.question-hyperlink')?.href,\n                            votes: result.querySelector('.vote-count-post')?.textContent?.trim(),\n                            answers: result.querySelector('.status strong')?.textContent?.trim(),\n                            tags: Array.from(result.querySelectorAll('.post-tag')).map(tag => tag.textContent)\n                        }))\n                    };\n                }\n                // Tag page\n                else if (url.includes('/tags/')) {\n                    pageInfo.type = 'tag';\n                    pageInfo.data = {\n                        tag: document.querySelector('.post-tag')?.textContent?.trim(),\n                        description: document.querySelector('.tag-wiki')?.textContent?.trim(),\n                        questionCount: document.querySelector('.fs-body3')?.textContent?.trim()\n                    };\n                }\n                // User profile page\n                else if (url.includes('/users/')) {\n                    pageInfo.type = 'user';\n                    pageInfo.data = {\n                        name: document.querySelector('[itemprop=\"name\"]')?.textContent?.trim(),\n                        reputation: document.querySelector('.reputation')?.textContent?.trim(),\n                        badges: {\n                            gold: document.querySelector('.badge1')?.title,\n                            silver: document.querySelector('.badge2')?.title,\n                            bronze: document.querySelector('.badge3')?.title\n                        }\n                    };\n                }\n                // Home page\n                else if (url === 'https://stackoverflow.com/' || url === 'https://stackoverflow.com') {\n                    pageInfo.type = 'home';\n                    pageInfo.data = {\n                        questions: Array.from(document.querySelectorAll('.question-summary')).map(question => ({\n                            title: question.querySelector('.question-hyperlink')?.textContent?.trim(),\n                            url: question.querySelector('.question-hyperlink')?.href,\n                            votes: question.querySelector('.vote-count-post')?.textContent?.trim(),\n                            answers: question.querySelector('.status strong')?.textContent?.trim(),\n                            tags: Array.from(question.querySelectorAll('.post-tag')).map(tag => tag.textContent)\n                        }))\n                    };\n                }\n\n                return { success: true, result: pageInfo };\n            } catch (error) {\n                scope.logError('Error getting Stack Overflow page info:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n}\n\nif(window.sbaiTools) {\n    window.sbaiTools['StackOverflowTools'] = StackOverflowTools;\n} else {\n    window.sbaiTools = {\n        'StackOverflowTools': StackOverflowTools\n    };\n}\n\nexport { StackOverflowTools }; ","class TwitchTools {\n    static name = \"TwitchTools\";\n\n    static _CarbonBarPageLoadFilter = (window) => {\n        return window.location.hostname.includes('twitch.tv');\n    }\n\n    static ListLiveStreams = {\n        function: {\n            name: 'list_live_streams',\n            description: 'List live streams based on category',\n            parameters: {\n                properties: {\n                    category: {\n                        type: 'string',\n                        description: 'Category to list streams from (following, front_page, game)'\n                    },\n                    game_name: {\n                        type: 'string',\n                        description: 'Name of the game to list streams for (required if category is \"game\")'\n                    },\n                    limit: {\n                        type: 'number',\n                        description: 'Maximum number of streams to return (default: 20)'\n                    }\n                },\n                required: ['category']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                let streams = [];\n                const limit = args.limit || 20;\n\n                // Get the GQL client from window\n                const gqlClient = window.__twilightBuildID;\n                if (!gqlClient) {\n                    throw new Error('Twitch GQL client not found');\n                }\n\n                switch(args.category.toLowerCase()) {\n                    case 'following':\n                        // Get followed streams\n                        const followingResponse = await scope.$http.post('/gql', {\n                            operationName: 'FollowedStreams',\n                            variables: {\n                                limit: limit\n                            },\n                            extensions: {\n                                persistedQuery: {\n                                    version: 1,\n                                    sha256Hash: gqlClient\n                                }\n                            }\n                        });\n                        streams = followingResponse.data.data.followedStreams;\n                        break;\n\n                    case 'front_page':\n                        // Get front page streams\n                        const frontPageResponse = await scope.$http.post('/gql', {\n                            operationName: 'BrowsePage_Popular',\n                            variables: {\n                                limit: limit\n                            },\n                            extensions: {\n                                persistedQuery: {\n                                    version: 1,\n                                    sha256Hash: gqlClient\n                                }\n                            }\n                        });\n                        streams = frontPageResponse.data.data.streams;\n                        break;\n\n                    case 'game':\n                        if (!args.game_name) {\n                            throw new Error('game_name is required when category is \"game\"');\n                        }\n                        // First get game ID\n                        const gameResponse = await scope.$http.post('/gql', {\n                            operationName: 'GamePage',\n                            variables: {\n                                name: args.game_name\n                            },\n                            extensions: {\n                                persistedQuery: {\n                                    version: 1,\n                                    sha256Hash: gqlClient\n                                }\n                            }\n                        });\n                        const gameId = gameResponse.data.data.game.id;\n                        \n                        // Then get streams for that game\n                        const gameStreamsResponse = await scope.$http.post('/gql', {\n                            operationName: 'GameStreams',\n                            variables: {\n                                gameId: gameId,\n                                limit: limit\n                            },\n                            extensions: {\n                                persistedQuery: {\n                                    version: 1,\n                                    sha256Hash: gqlClient\n                                }\n                            }\n                        });\n                        streams = gameStreamsResponse.data.data.streams;\n                        break;\n\n                    default:\n                        throw new Error('Invalid category specified');\n                }\n\n                // Format the streams data\n                const formattedStreams = streams.map(stream => ({\n                    id: stream.id,\n                    title: stream.title,\n                    broadcaster: stream.broadcaster.displayName,\n                    game: stream.game?.name,\n                    viewers: stream.viewersCount,\n                    thumbnailUrl: stream.previewImageURL,\n                    url: `https://twitch.tv/${stream.broadcaster.login}`\n                }));\n\n                return { success: true, result: formattedStreams };\n            } catch (error) {\n                scope.logError('Error listing streams:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n\n    static OpenStream = {\n        function: {\n            name: 'open_stream',\n            description: 'Open a Twitch stream',\n            parameters: {\n                properties: {\n                    username: {\n                        type: 'string',\n                        description: 'Username/channel name of the streamer'\n                    },\n                    theater_mode: {\n                        type: 'boolean',\n                        description: 'Whether to open in theater mode (default: false)'\n                    }\n                },\n                required: ['username']\n            }\n        },\n        execute: async function(scope, args) {\n            try {\n                let url = `https://twitch.tv/${args.username}`;\n                if (args.theater_mode) {\n                    url += '?mode=theater';\n                }\n\n                // Open in current window if we're already on Twitch\n                if (window.location.hostname.includes('twitch.tv')) {\n                    window.location.href = url;\n                } else {\n                    // Open in new window otherwise\n                    window.open(url, '_blank');\n                }\n\n                return { \n                    success: true, \n                    result: `Opened stream: ${args.username}${args.theater_mode ? ' in theater mode' : ''}`\n                };\n            } catch (error) {\n                scope.logError('Error opening stream:', error);\n                return { success: false, error: error.message };\n            }\n        }\n    };\n}\n\nif(window.sbaiTools) {\n    window.sbaiTools['TwitchTools'] = TwitchTools;\n} else {\n    window.sbaiTools = {\n        'TwitchTools': TwitchTools\n    };\n}\n\nexport { TwitchTools }; ","var map = {\n\t\"./CarbonBarHelpTools.js\": \"./src/tools/CarbonBarHelpTools.js\",\n\t\"./GeneralTools.js\": \"./src/tools/GeneralTools.js\",\n\t\"./external/BitbucketTools.js\": \"./src/tools/external/BitbucketTools.js\",\n\t\"./external/HackerNewsTools.js\": \"./src/tools/external/HackerNewsTools.js\",\n\t\"./external/JiraTools.js\": \"./src/tools/external/JiraTools.js\",\n\t\"./external/RocketChatTools.js\": \"./src/tools/external/RocketChatTools.js\",\n\t\"./external/SmarterMailTools.js\": \"./src/tools/external/SmarterMailTools.js\",\n\t\"./external/SmarterTrackPortalTools.js\": \"./src/tools/external/SmarterTrackPortalTools.js\",\n\t\"./external/StackOverflowTools.js\": \"./src/tools/external/StackOverflowTools.js\",\n\t\"./external/TwitchTools.js\": \"./src/tools/external/TwitchTools.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/tools sync recursive \\\\.js$\";","export class APITests {\n    async testOpenAIIntegration() {\n        console.log('Testing OpenAI integration');\n        try {\n            // Test OpenAI API integration\n            console.log('Checking OpenAI connection...');\n            throw new Error('SKIP'); // Skip until API keys are mocked\n        } catch (error) {\n            if (error.message === 'SKIP') throw error;\n            console.error('OpenAI integration test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testOllamaIntegration() {\n        console.log('Testing Ollama integration');\n        try {\n            // Test Ollama API integration\n            console.log('Checking Ollama connection...');\n            throw new Error('SKIP'); // Skip until Ollama mock is implemented\n        } catch (error) {\n            if (error.message === 'SKIP') throw error;\n            console.error('Ollama integration test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testMCPServiceConnection() {\n        console.log('Testing MCP service connection');\n        try {\n            // Test MCP service connection\n            // This is a placeholder for actual implementation\n            console.log('Checking MCP service connection...');\n            return true;\n        } catch (error) {\n            console.error('MCP service connection test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testExternalToolAPIs() {\n        console.log('Testing external tool APIs');\n        try {\n            // Test external tool API connections\n            // This is a placeholder for actual implementation\n            console.log('Checking external tool APIs...');\n            return true;\n        } catch (error) {\n            console.error('External tool APIs test failed:', error.message);\n            throw error;\n        }\n    }\n} ","// Import CarbonCommander as a module\nimport { CarbonCommander } from '../../src/chrome-carbonbar-page/carbon-commander.js';\n\n// Use the global marked instance from CDN\nconst marked = window.marked;\n\nexport class CarbonBarTests {\n    // Helper method to setup window mock\n    setupWindowMock() {\n        // Store original window properties\n        const originalWindow = { ...window };\n        \n        // Mock window location\n        window.location = {\n            hostname: 'test.example.com',\n            origin: 'http://test.example.com'\n        };\n\n        // Mock window.postMessage\n        window.postMessage = (message, targetOrigin) => {\n            // Simulate message event\n            if (message.type === 'GET_SETTINGS') {\n                setTimeout(() => {\n                    const event = new MessageEvent('message', {\n                        data: {\n                            type: 'GET_SETTINGS_RESPONSE',\n                            _authToken: 'test-auth-token',\n                            payload: {}\n                        }\n                    });\n                    window.dispatchEvent(event);\n                }, 0);\n            }\n            return Promise.resolve();\n        };\n\n        return () => {\n            // Restore original window properties\n            Object.assign(window, originalWindow);\n        };\n    }\n\n    async testCarbonBarInitialization() {\n        console.log('Running CarbonBar initialization test');\n        const restoreWindow = this.setupWindowMock();\n        \n        try {\n            // Create mock document\n            const mockDocument = {\n                createElement: (tag) => ({\n                    style: {},\n                    classList: {\n                        add: () => {},\n                        remove: () => {},\n                        contains: () => false\n                    },\n                    appendChild: () => {},\n                    querySelector: () => null,\n                    querySelectorAll: () => [],\n                    addEventListener: () => {},\n                    attachShadow: () => ({\n                        appendChild: () => {}\n                    }),\n                    getAttribute: (attr) => {\n                        if (attr === 'content') return 'test-tab-id';\n                        if (attr === 'cc-data-key') return 'test-key';\n                        return null;\n                    }\n                }),\n                body: {\n                    appendChild: () => {}\n                },\n                addEventListener: () => {},\n                head: {\n                    appendChild: () => {}\n                }\n            };\n\n            // Create mock meta element for tabId\n            const mockMeta = mockDocument.createElement('meta');\n            mockMeta.getAttribute = () => 'test-tab-id';\n            mockDocument.querySelector = (selector) => {\n                if (selector === 'meta[name=\"tabId\"]') {\n                    return mockMeta;\n                }\n                if (selector === 'script[cc-data-key]') {\n                    const mockScript = mockDocument.createElement('script');\n                    mockScript.getAttribute = () => 'test-key';\n                    return mockScript;\n                }\n                return null;\n            };\n\n            // Initialize CarbonBar with mock document\n            const carbonBar = new CarbonCommander(mockDocument);\n            \n            // Wait for initialization\n            await new Promise(resolve => setTimeout(resolve, 100));\n            \n            // Verify initialization\n            if (!carbonBar) {\n                throw new Error('CarbonBar failed to initialize');\n            }\n\n            // Verify essential properties\n            if (!carbonBar.root || !carbonBar.container) {\n                throw new Error('CarbonBar missing essential DOM elements');\n            }\n\n            // Verify initial state\n            if (carbonBar.isVisible) {\n                throw new Error('CarbonBar should be hidden initially');\n            }\n\n            console.log('CarbonBar initialization test passed');\n        } catch (error) {\n            console.error('CarbonBar initialization test failed:', error.message);\n            throw error;\n        } finally {\n            restoreWindow();\n        }\n    }\n\n    async testCommandPalette() {\n        console.log('Running command palette test');\n        const restoreWindow = this.setupWindowMock();\n        \n        try {\n            // Create mock elements array to track created elements\n            const elements = [];\n            const eventHandlers = new Map();\n            let inputValue = '';\n\n            // Create mock document with event handling\n            const mockDocument = {\n                createElement: (tag) => {\n                    const element = {\n                        style: {},\n                        classList: {\n                            add: () => {},\n                            remove: () => {},\n                            contains: () => false\n                        },\n                        appendChild: () => {},\n                        querySelector: () => null,\n                        querySelectorAll: () => [],\n                        addEventListener: (event, handler) => {\n                            eventHandlers.set(event, handler);\n                        },\n                        get value() { return inputValue; },\n                        set value(val) { inputValue = val; },\n                        attachShadow: () => ({\n                            appendChild: () => {}\n                        }),\n                        getAttribute: (attr) => {\n                            if (attr === 'content') return 'test-tab-id';\n                            if (attr === 'cc-data-key') return 'test-key';\n                            return null;\n                        }\n                    };\n                    elements.push({ tag, element });\n                    return element;\n                },\n                body: {\n                    appendChild: () => {}\n                },\n                addEventListener: (event, handler) => {\n                    eventHandlers.set(event, handler);\n                },\n                head: {\n                    appendChild: () => {}\n                }\n            };\n\n            // Create mock meta element for tabId\n            const mockMeta = mockDocument.createElement('meta');\n            mockMeta.getAttribute = () => 'test-tab-id';\n            mockDocument.querySelector = (selector) => {\n                if (selector === 'meta[name=\"tabId\"]') {\n                    return mockMeta;\n                }\n                if (selector === 'script[cc-data-key]') {\n                    const mockScript = mockDocument.createElement('script');\n                    mockScript.getAttribute = () => 'test-key';\n                    return mockScript;\n                }\n                return null;\n            };\n\n            // Initialize CarbonBar\n            const carbonBar = new CarbonCommander(mockDocument);\n            \n            // Wait for initialization\n            await new Promise(resolve => setTimeout(resolve, 100));\n\n            // Test show/hide functionality\n            carbonBar.show();\n            if (!carbonBar.isVisible) {\n                throw new Error('CarbonBar should be visible after show()');\n            }\n\n            carbonBar.hide();\n            if (carbonBar.isVisible) {\n                throw new Error('CarbonBar should be hidden after hide()');\n            }\n\n            // Test toggle functionality\n            carbonBar.toggle();\n            if (!carbonBar.isVisible) {\n                throw new Error('CarbonBar should be visible after toggle() from hidden state');\n            }\n\n            carbonBar.toggle();\n            if (carbonBar.isVisible) {\n                throw new Error('CarbonBar should be hidden after toggle() from visible state');\n            }\n\n            // Test command input\n            const testCommand = 'test command';\n            inputValue = testCommand;\n            \n            // Simulate Enter key press\n            const keydownHandler = eventHandlers.get('keydown');\n            if (!keydownHandler) {\n                throw new Error('Keydown handler not registered');\n            }\n\n            await keydownHandler({ \n                key: 'Enter',\n                preventDefault: () => {},\n                target: { value: testCommand }\n            });\n\n            // Verify command was added to history\n            if (!carbonBar.commandHistory.includes(testCommand)) {\n                throw new Error('Command not added to history');\n            }\n\n            console.log('Command palette test passed');\n        } catch (error) {\n            console.error('Command palette test failed:', error.message);\n            throw error;\n        } finally {\n            restoreWindow();\n        }\n    }\n\n    async testToolExecution() {\n        console.log('Running tool execution test');\n        const restoreWindow = this.setupWindowMock();\n        \n        try {\n            // Create mock elements and event handlers\n            const elements = [];\n            const eventHandlers = new Map();\n            let inputValue = '';\n\n            // Create mock document with event handling\n            const mockDocument = {\n                createElement: (tag) => {\n                    const element = {\n                        style: {},\n                        classList: {\n                            add: () => {},\n                            remove: () => {},\n                            contains: () => false\n                        },\n                        appendChild: () => {},\n                        querySelector: () => null,\n                        querySelectorAll: () => [],\n                        addEventListener: (event, handler) => {\n                            eventHandlers.set(event, handler);\n                        },\n                        get value() { return inputValue; },\n                        set value(val) { inputValue = val; },\n                        attachShadow: () => ({\n                            appendChild: () => {}\n                        })\n                    };\n                    elements.push({ tag, element });\n                    return element;\n                },\n                body: {\n                    appendChild: () => {}\n                },\n                addEventListener: (event, handler) => {\n                    eventHandlers.set(event, handler);\n                }\n            };\n\n            // Create mock meta element for tabId\n            const mockMeta = mockDocument.createElement('meta');\n            mockMeta.getAttribute = () => 'test-tab-id';\n            mockDocument.querySelector = (selector) => {\n                if (selector === 'meta[name=\"tabId\"]') {\n                    return mockMeta;\n                }\n                if (selector === 'script[cc-data-key]') {\n                    const mockScript = mockDocument.createElement('script');\n                    mockScript.getAttribute = () => 'test-key';\n                    return mockScript;\n                }\n                return null;\n            };\n\n            // Initialize CarbonBar\n            const carbonBar = new CarbonCommander(mockDocument);\n            \n            // Wait for initialization\n            await new Promise(resolve => setTimeout(resolve, 100));\n\n            // Create a test tool\n            const testTool = {\n                name: 'test-tool',\n                description: 'A test tool',\n                parameters: {\n                    type: 'object',\n                    properties: {\n                        message: { type: 'string' }\n                    }\n                },\n                execute: async (scope, args) => ({ \n                    success: true,\n                    result: `Executed with ${args.message}` \n                })\n            };\n\n            // Register the test tool\n            carbonBar.toolCaller.registerTool('test', testTool);\n\n            // Test tool execution\n            const toolCommand = 'test-tool {\"message\": \"test execution\"}';\n            inputValue = toolCommand;\n\n            // Simulate Enter key press\n            const keydownHandler = eventHandlers.get('keydown');\n            if (!keydownHandler) {\n                throw new Error('Keydown handler not registered');\n            }\n\n            await keydownHandler({ \n                key: 'Enter',\n                preventDefault: () => {},\n                target: { value: toolCommand }\n            });\n\n            // Verify tool execution\n            // Note: In a real implementation, we would verify the tool's output\n            // through the UI or message system. For this test, we're just\n            // verifying the command was processed.\n\n            if (!carbonBar.commandHistory.includes(toolCommand)) {\n                throw new Error('Tool command not added to history');\n            }\n\n            console.log('Tool execution test passed');\n        } catch (error) {\n            console.error('Tool execution test failed:', error.message);\n            throw error;\n        } finally {\n            restoreWindow();\n        }\n    }\n} ","export class HackerNewsTests {\n    async testHNSearch() {\n        console.log('Running HackerNews search test');\n        // This is a passing test example\n        console.log('Checking search functionality...');\n        return true;\n    }\n\n    async testHNComments() {\n        console.log('Running HackerNews comments test');\n        // This is a skipped test example\n        throw new Error('SKIP');\n    }\n\n    async testHNSubmission() {\n        console.log('Running HackerNews submission test');\n        // This is a passing test example\n        console.log('Checking submission functionality...');\n        return true;\n    }\n} ","export class IntegrationTests {\n    async testCommandPaletteEndToEnd() {\n        console.log('Testing command palette end-to-end functionality');\n        try {\n            // Test full command palette workflow\n            // This is a placeholder for actual implementation\n            console.log('Checking command palette workflow...');\n            return true;\n        } catch (error) {\n            console.error('Command palette end-to-end test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testToolExecutionFlow() {\n        console.log('Testing tool execution flow');\n        try {\n            // Test tool execution from command to result\n            // This is a placeholder for actual implementation\n            console.log('Checking tool execution flow...');\n            return true;\n        } catch (error) {\n            console.error('Tool execution flow test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testAIProviderIntegration() {\n        console.log('Testing AI provider integration');\n        try {\n            // Test integration with AI providers (OpenAI, Ollama)\n            console.log('Checking AI provider integration...');\n            throw new Error('SKIP'); // Skip until AI provider mocks are implemented\n        } catch (error) {\n            if (error.message === 'SKIP') throw error;\n            console.error('AI provider integration test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testSecureMessaging() {\n        console.log('Testing secure messaging system');\n        try {\n            // Test secure messaging between components\n            // This is a placeholder for actual implementation\n            console.log('Checking secure messaging...');\n            return true;\n        } catch (error) {\n            console.error('Secure messaging test failed:', error.message);\n            throw error;\n        }\n    }\n} ","export class JiraTests {\n    async testJiraAuthentication() {\n        console.log('Testing Jira authentication');\n        try {\n            // Test Jira authentication flow\n            console.log('Checking Jira auth...');\n            throw new Error('SKIP'); // Skip until Jira auth can be mocked\n        } catch (error) {\n            if (error.message === 'SKIP') throw error;\n            console.error('Jira authentication test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testIssueCreation() {\n        console.log('Testing Jira issue creation');\n        try {\n            // Test creating a Jira issue\n            // This is a placeholder for actual implementation\n            console.log('Testing issue creation...');\n            return true;\n        } catch (error) {\n            console.error('Issue creation test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testIssueSearch() {\n        console.log('Testing Jira issue search');\n        try {\n            // Test searching for Jira issues\n            // This is a placeholder for actual implementation\n            console.log('Testing issue search...');\n            return true;\n        } catch (error) {\n            console.error('Issue search test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testIssueUpdate() {\n        console.log('Testing Jira issue update');\n        try {\n            // Test updating a Jira issue\n            // This is a placeholder for actual implementation\n            console.log('Testing issue update...');\n            return true;\n        } catch (error) {\n            console.error('Issue update test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testJiraWebhooks() {\n        console.log('Testing Jira webhooks');\n        try {\n            // Test Jira webhook functionality\n            console.log('Testing webhooks...');\n            throw new Error('SKIP'); // Skip until webhook testing is implemented\n        } catch (error) {\n            if (error.message === 'SKIP') throw error;\n            console.error('Webhook test failed:', error.message);\n            throw error;\n        }\n    }\n} ","export class MCPTests {\n    async testMCPConnection() {\n        console.log('Testing MCP connection');\n        try {\n            // Test MCP connection establishment\n            // This is a placeholder for actual implementation\n            console.log('Testing connection establishment...');\n            return true;\n        } catch (error) {\n            console.error('MCP connection test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testToolDiscovery() {\n        console.log('Testing MCP tool discovery');\n        try {\n            // Test discovering available tools from MCP service\n            // This is a placeholder for actual implementation\n            console.log('Testing tool discovery...');\n            return true;\n        } catch (error) {\n            console.error('Tool discovery test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testToolExecution() {\n        console.log('Testing MCP tool execution');\n        try {\n            // Test executing tools through MCP\n            console.log('Testing tool execution...');\n            throw new Error('SKIP'); // Skip until MCP execution can be mocked\n        } catch (error) {\n            if (error.message === 'SKIP') throw error;\n            console.error('Tool execution test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testContextManagement() {\n        console.log('Testing MCP context management');\n        try {\n            // Test context management functionality\n            // This is a placeholder for actual implementation\n            console.log('Testing context management...');\n            return true;\n        } catch (error) {\n            console.error('Context management test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testSecureChannels() {\n        console.log('Testing MCP secure channels');\n        try {\n            // Test secure channel establishment and communication\n            console.log('Testing secure channels...');\n            throw new Error('SKIP'); // Skip until secure channel testing is implemented\n        } catch (error) {\n            if (error.message === 'SKIP') throw error;\n            console.error('Secure channels test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testErrorHandling() {\n        console.log('Testing MCP error handling');\n        try {\n            // Test error handling and recovery\n            // This is a placeholder for actual implementation\n            console.log('Testing error handling...');\n            return true;\n        } catch (error) {\n            console.error('Error handling test failed:', error.message);\n            throw error;\n        }\n    }\n} ","export class ServiceWorkerTests {\n    async testServiceWorkerInitialization() {\n        console.log('Testing service worker initialization');\n        // Test that the service worker can be registered\n        return true;\n    }\n\n    async testMessageHandling() {\n        console.log('Testing message handling between service worker and content script');\n        try {\n            // This test needs implementation with chrome.runtime mocking\n            throw new Error('SKIP');\n        } catch (error) {\n            if (error.message === 'SKIP') throw error;\n            console.error('Message handling test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testAIServiceIntegration() {\n        console.log('Testing AI service integration');\n        try {\n            // Test AI service integration\n            // This is a placeholder for actual implementation\n            console.log('Checking AI service connections...');\n            return true;\n        } catch (error) {\n            console.error('AI service integration test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testStorageOperations() {\n        console.log('Testing storage operations');\n        try {\n            // Test storage operations\n            // This is a placeholder for actual implementation\n            console.log('Checking storage operations...');\n            return true;\n        } catch (error) {\n            console.error('Storage operations test failed:', error.message);\n            throw error;\n        }\n    }\n} ","export class ToolCallerTests {\n    async testToolRegistration() {\n        console.log('Testing tool registration');\n        try {\n            // Test tool registration functionality\n            // This is a placeholder for actual implementation\n            console.log('Checking tool registration...');\n            return true;\n        } catch (error) {\n            console.error('Tool registration test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testLocalToolExecution() {\n        console.log('Testing local tool execution');\n        try {\n            // Test local tool execution\n            // This is a placeholder for actual implementation\n            console.log('Checking local tool execution...');\n            return true;\n        } catch (error) {\n            console.error('Local tool execution test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testMCPToolExecution() {\n        console.log('Testing MCP tool execution');\n        try {\n            // Test MCP tool execution\n            console.log('Checking MCP tool execution...');\n            throw new Error('SKIP'); // Skip until MCP mock is implemented\n        } catch (error) {\n            if (error.message === 'SKIP') throw error;\n            console.error('MCP tool execution test failed:', error.message);\n            throw error;\n        }\n    }\n\n    async testToolDiscovery() {\n        console.log('Testing tool discovery');\n        try {\n            // Test tool discovery functionality\n            // This is a placeholder for actual implementation\n            console.log('Checking tool discovery...');\n            return true;\n        } catch (error) {\n            console.error('Tool discovery test failed:', error.message);\n            throw error;\n        }\n    }\n} ","/**\n * marked v15.0.6 - a markdown parser\n * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n/**\n * Gets the original marked default options.\n */\nfunction _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n\nconst noopTest = { exec: () => null };\nfunction edit(regex, opt = '') {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(other.caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\nconst other = {\n    codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n    outputLinkReplace: /\\\\([\\[\\]])/g,\n    indentCodeCompensation: /^(\\s+)(?:```)/,\n    beginningSpace: /^\\s+/,\n    endingHash: /#$/,\n    startingSpaceChar: /^ /,\n    endingSpaceChar: / $/,\n    nonSpaceChar: /[^ ]/,\n    newLineCharGlobal: /\\n/g,\n    tabCharGlobal: /\\t/g,\n    multipleSpaceGlobal: /\\s+/g,\n    blankLine: /^[ \\t]*$/,\n    doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n    blockquoteStart: /^ {0,3}>/,\n    blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n    blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n    listReplaceTabs: /^\\t+/,\n    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n    listIsTask: /^\\[[ xX]\\] /,\n    listReplaceTask: /^\\[[ xX]\\] +/,\n    anyLine: /\\n.*\\n/,\n    hrefBrackets: /^<(.*)>$/,\n    tableDelimiter: /[:|]/,\n    tableAlignChars: /^\\||\\| *$/g,\n    tableRowBlankLine: /\\n[ \\t]*$/,\n    tableAlignRight: /^ *-+: *$/,\n    tableAlignCenter: /^ *:-+: *$/,\n    tableAlignLeft: /^ *:-+ *$/,\n    startATag: /^<a /i,\n    endATag: /^<\\/a>/i,\n    startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n    endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n    startAngleBracket: /^</,\n    endAngleBracket: />$/,\n    pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n    unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n    escapeTest: /[&<>\"']/,\n    escapeReplace: /[&<>\"']/g,\n    escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n    escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n    unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n    caret: /(^|[^\\[])\\^/g,\n    percentDecode: /%25/g,\n    findPipe: /\\|/g,\n    splitPipe: / \\|/,\n    slashPipe: /\\\\\\|/g,\n    carriageReturn: /\\r\\n|\\r/g,\n    spaceLine: /^ +$/gm,\n    notSpaceStart: /^\\S*/,\n    endingNewline: /\\n$/,\n    listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n    nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n    hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n    fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n    headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n    htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n};\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n/**\n * Inline-Level Grammar\n */\nconst escape$1 = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n    .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n    .replace(/punct/g, _punctuationGfmStrongEm)\n    .getRegex();\nconst emStrongRDelimAstCore = '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n    + '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n    .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n    .replace(/punctSpace/g, _punctuationOrSpace)\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n    .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n    .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n    .replace(/punct/g, _punctuationGfmStrongEm)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n    + '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n    .replace(/punctSpace/g, _punctuationOrSpace)\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape: escape$1,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    emStrongRDelimAst: emStrongRDelimAstGfm,\n    emStrongLDelim: emStrongLDelimGfm,\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n/**\n * exports\n */\nconst block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n\n/**\n * Helpers\n */\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n    if (encode) {\n        if (other.escapeTest.test(html)) {\n            return html.replace(other.escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (other.escapeTestNoEncode.test(html)) {\n            return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(other.percentDecode, '%');\n    }\n    catch {\n        return null;\n    }\n    return href;\n}\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(other.splitPipe);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells.at(-1)?.trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && true) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nfunction outputLink(cap, link, raw, lexer, rules) {\n    const href = link.href;\n    const title = link.title || null;\n    const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text,\n    };\n}\nfunction indentCodeCompensation(raw, text, rules) {\n    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(rules.other.beginningSpace);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nclass _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (this.rules.other.endingHash.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: rtrim(cap[0], '\\n'),\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], '\\n').split('\\n');\n            let raw = '';\n            let text = '';\n            const tokens = [];\n            while (lines.length > 0) {\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for (i = 0; i < lines.length; i++) {\n                    // get lines up to a continuation\n                    if (this.rules.other.blockquoteStart.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    }\n                    else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join('\\n');\n                const currentText = currentRaw\n                    // precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n                    .replace(this.rules.other.blockquoteSetextReplace2, '');\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'code') {\n                    // blockquote continuation cannot be preceded by a code block\n                    break;\n                }\n                else if (lastToken?.type === 'blockquote') {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                }\n                else if (lastToken?.type === 'list') {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens.at(-1).raw.length).split('\\n');\n                    continue;\n                }\n            }\n            return {\n                type: 'blockquote',\n                raw,\n                tokens,\n                text,\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = this.rules.other.listItemRegex(bull);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                let raw = '';\n                let itemContents = '';\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else if (blankLine) {\n                    indent = cap[1].length + 1;\n                }\n                else {\n                    indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n                    const hrRegex = this.rules.other.hrRegex(indent);\n                    const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n                    const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n                    const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n                            nextLineWithoutTabs = nextLine;\n                        }\n                        else {\n                            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of html block\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (this.rules.other.doubleBlankLine.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = this.rules.other.listIsTask.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            const lastItem = list.items.at(-1);\n            if (lastItem) {\n                lastItem.raw = lastItem.raw.trimEnd();\n                lastItem.text = lastItem.text.trimEnd();\n            }\n            else {\n                // not a list since there were no items\n                return;\n            }\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!this.rules.other.tableDelimiter.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n        const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (this.rules.other.tableAlignRight.test(align)) {\n                item.align.push('right');\n            }\n            else if (this.rules.other.tableAlignCenter.test(align)) {\n                item.align.push('center');\n            }\n            else if (this.rules.other.tableAlignLeft.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (let i = 0; i < headers.length; i++) {\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i],\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i],\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: cap[1],\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = this.rules.other.pedanticHrefTitle.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (this.rules.other.startAngleBracket.test(href)) {\n                if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer, this.rules);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer, this.rules);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = cap[1];\n                href = 'mailto:' + text;\n            }\n            else {\n                text = cap[1];\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = cap[0];\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = cap[0];\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            const escaped = this.lexer.state.inRawBlock;\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                escaped,\n            };\n        }\n    }\n}\n\n/**\n * Block Lexer\n */\nclass _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n        const rules = {\n            other,\n            block: block.normal,\n            inline: inline.normal,\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src.replace(other.carriageReturn, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n        }\n        while (src) {\n            let token;\n            if (this.options.extensions?.block?.some((extTokenizer) => {\n                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.raw.length === 1 && lastToken !== undefined) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    lastToken.raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title,\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                const lastToken = tokens.at(-1);\n                if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match = null;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index)\n                            + '[' + 'a'.repeat(match[0].length - 2) + ']'\n                            + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        let keepPrevChar = false;\n        let prevChar = '';\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            let token;\n            // extensions\n            if (this.options.extensions?.inline?.some((extTokenizer) => {\n                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.type === 'text' && lastToken?.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n\n/**\n * Renderer\n */\nclass _Renderer {\n    options;\n    parser; // set by the parser\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(token) {\n        return '';\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || '').match(other.notSpaceStart)?.[0];\n        const code = text.replace(other.endingNewline, '') + '\\n';\n        if (!langString) {\n            return '<pre><code>'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape(langString)\n            + '\">'\n            + (escaped ? code : escape(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return '<hr>\\n';\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = '';\n        for (let j = 0; j < token.items.length; j++) {\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? 'ol' : 'ul';\n        const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(item) {\n        let itemBody = '';\n        if (item.task) {\n            const checkbox = this.checkbox({ checked: !!item.checked });\n            if (item.loose) {\n                if (item.tokens[0]?.type === 'paragraph') {\n                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n                        item.tokens[0].tokens[0].escaped = true;\n                    }\n                }\n                else {\n                    item.tokens.unshift({\n                        type: 'text',\n                        raw: checkbox + ' ',\n                        text: checkbox + ' ',\n                        escaped: true,\n                    });\n                }\n            }\n            else {\n                itemBody += checkbox + ' ';\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = '';\n        // header\n        let cell = '';\n        for (let j = 0; j < token.header.length; j++) {\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({ text: cell });\n        let body = '';\n        for (let j = 0; j < token.rows.length; j++) {\n            const row = token.rows[j];\n            cell = '';\n            for (let k = 0; k < row.length; k++) {\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({ text: cell });\n        }\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? 'th' : 'td';\n        const tag = token.align\n            ? `<${type} align=\"${token.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${escape(text, true)}</code>`;\n    }\n    br(token) {\n        return '<br>';\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + (escape(title)) + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image({ href, title, text }) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return escape(text);\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${escape(title)}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(token) {\n        return 'tokens' in token && token.tokens\n            ? this.parser.parseInline(token.tokens)\n            : ('escaped' in token && token.escaped ? token.text : escape(token.text));\n    }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return '' + text;\n    }\n    image({ text }) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n\n/**\n * Parsing & Compiling\n */\nclass _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'space': {\n                    out += this.renderer.space(token);\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr(token);\n                    continue;\n                }\n                case 'heading': {\n                    out += this.renderer.heading(token);\n                    continue;\n                }\n                case 'code': {\n                    out += this.renderer.code(token);\n                    continue;\n                }\n                case 'table': {\n                    out += this.renderer.table(token);\n                    continue;\n                }\n                case 'blockquote': {\n                    out += this.renderer.blockquote(token);\n                    continue;\n                }\n                case 'list': {\n                    out += this.renderer.list(token);\n                    continue;\n                }\n                case 'html': {\n                    out += this.renderer.html(token);\n                    continue;\n                }\n                case 'paragraph': {\n                    out += this.renderer.paragraph(token);\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = this.renderer.text(textToken);\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + this.renderer.text(textToken);\n                    }\n                    if (top) {\n                        out += this.renderer.paragraph({\n                            type: 'paragraph',\n                            raw: body,\n                            text: body,\n                            tokens: [{ type: 'text', raw: body, text: body, escaped: true }],\n                        });\n                    }\n                    else {\n                        out += body;\n                    }\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer = this.renderer) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'escape': {\n                    out += renderer.text(token);\n                    break;\n                }\n                case 'html': {\n                    out += renderer.html(token);\n                    break;\n                }\n                case 'link': {\n                    out += renderer.link(token);\n                    break;\n                }\n                case 'image': {\n                    out += renderer.image(token);\n                    break;\n                }\n                case 'strong': {\n                    out += renderer.strong(token);\n                    break;\n                }\n                case 'em': {\n                    out += renderer.em(token);\n                    break;\n                }\n                case 'codespan': {\n                    out += renderer.codespan(token);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br(token);\n                    break;\n                }\n                case 'del': {\n                    out += renderer.del(token);\n                    break;\n                }\n                case 'text': {\n                    out += renderer.text(token);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n\nclass _Hooks {\n    options;\n    block;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n     * Provide function to tokenize markdown\n     */\n    provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n     * Provide function to parse tokens\n     */\n    provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n}\n\nclass Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.parseMarkdown(true);\n    parseInline = this.parseMarkdown(false);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity);\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (['options', 'parser'].includes(prop)) {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (['options', 'block'].includes(prop)) {\n                        // ignore options and block properties\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(blockType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n            }\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n            const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n\nexport { _Hooks as Hooks, _Lexer as Lexer, Marked, _Parser as Parser, _Renderer as Renderer, _TextRenderer as TextRenderer, _Tokenizer as Tokenizer, _defaults as defaults, _getDefaults as getDefaults, lexer, marked, options, parse, parseInline, parser, setOptions, use, walkTokens };\n//# sourceMappingURL=marked.esm.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { ccLogger } from '../src/global.js';\nimport { HackerNewsTests } from './suites/HackerNewsTests.js';\nimport { JiraTests } from './suites/JiraTests.js';\nimport { MCPTests } from './suites/MCPTests.js';\nimport { CarbonBarTests } from './suites/CarbonBarTests.js';\nimport { ServiceWorkerTests } from './suites/ServiceWorkerTests.js';\nimport { ToolCallerTests } from './suites/ToolCallerTests.js';\nimport { IntegrationTests } from './suites/IntegrationTests.js';\nimport { APITests } from './suites/APITests.js';\n\nclass TestSuiteRunner {\n    static suites = {\n        HackerNews: HackerNewsTests,\n        Jira: JiraTests,\n        MCP: MCPTests,\n        CarbonBar: CarbonBarTests,\n        ServiceWorker: ServiceWorkerTests,\n        ToolCaller: ToolCallerTests,\n        Integration: IntegrationTests,\n        API: APITests\n    };\n\n    static async runSuite(suiteName) {\n        ccLogger.group(`Running Test Suite: ${suiteName}`);\n        \n        const suite = this.suites[suiteName];\n        if (!suite) {\n            const error = `Test suite '${suiteName}' not found`;\n            ccLogger.error(error);\n            ccLogger.groupEnd();\n            throw new Error(error);\n        }\n\n        const results = {\n            total: 0,\n            passed: 0,\n            failed: 0,\n            skipped: 0\n        };\n\n        try {\n            ccLogger.info(`Initializing ${suiteName} test suite...`);\n            const suiteInstance = new suite();\n            const tests = Object.getOwnPropertyNames(Object.getPrototypeOf(suiteInstance))\n                .filter(prop => prop.startsWith('test') && typeof suiteInstance[prop] === 'function');\n\n            results.total = tests.length;\n            ccLogger.info(`Found ${tests.length} tests to run`);\n\n            for (const testName of tests) {\n                ccLogger.group(`Running test: ${testName}`);\n                try {\n                    ccLogger.time(testName);\n                    await suiteInstance[testName]();\n                    ccLogger.timeEnd(testName);\n                    results.passed++;\n                    ccLogger.info(` Test passed: ${testName}`);\n                } catch (error) {\n                    ccLogger.timeEnd(testName);\n                    if (error.message === 'SKIP') {\n                        results.skipped++;\n                        ccLogger.warn(` Test skipped: ${testName}`);\n                    } else {\n                        results.failed++;\n                        ccLogger.error(` Test failed: ${testName}`);\n                        ccLogger.error(`Error: ${error.message}`);\n                        if (error.stack) {\n                            ccLogger.error(`Stack: ${error.stack}`);\n                        }\n                    }\n                }\n                ccLogger.groupEnd();\n            }\n        } catch (error) {\n            ccLogger.error(`Fatal error in suite ${suiteName}:`, error);\n            results.failed++;\n        }\n\n        ccLogger.group(`${suiteName} Suite Results`);\n        ccLogger.info(`Total: ${results.total}`);\n        ccLogger.info(`Passed: ${results.passed}`);\n        ccLogger.info(`Failed: ${results.failed}`);\n        ccLogger.info(`Skipped: ${results.skipped}`);\n        ccLogger.groupEnd();\n        \n        ccLogger.groupEnd();\n        return results;\n    }\n\n    static async runAllTests() {\n        ccLogger.group('Running All Test Suites');\n        \n        const results = {\n            total: 0,\n            passed: 0,\n            failed: 0,\n            skipped: 0\n        };\n\n        for (const suiteName of Object.keys(this.suites)) {\n            try {\n                const suiteResults = await this.runSuite(suiteName);\n                results.total += suiteResults.total;\n                results.passed += suiteResults.passed;\n                results.failed += suiteResults.failed;\n                results.skipped += suiteResults.skipped;\n            } catch (error) {\n                ccLogger.error(`Failed to run suite ${suiteName}:`, error);\n            }\n        }\n\n        ccLogger.group('Final Results');\n        ccLogger.info(`Total Tests: ${results.total}`);\n        ccLogger.info(`Passed: ${results.passed}`);\n        ccLogger.info(`Failed: ${results.failed}`);\n        ccLogger.info(`Skipped: ${results.skipped}`);\n        ccLogger.groupEnd();\n        \n        ccLogger.groupEnd();\n        return results;\n    }\n}\n\n// If this script is run directly (not imported), run all tests\nif (import.meta.url === new URL(window.location.href).href) {\n    TestSuiteRunner.runAllTests();\n}\n\nexport { TestSuiteRunner }; "],"names":[],"sourceRoot":""}