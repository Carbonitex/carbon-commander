{"version":3,"file":"service-dist.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,yCAAyC,YAAY;AACrD,6CAA6C,sBAAsB;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,6CAA6C,oBAAoB;AACjE;AACA;;AAEA;AACA,yCAAyC,cAAc;AACvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oDAAe,cAAc;;AC7C7B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbgD;AACT;;AAEvC;;AAEA;AACA;AACA,+BAA+B,oBAAoB;AACnD;;AAEA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA,KAAK;;AAEL,IAAI,QAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,QAAQ;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,EAAE,QAAQ;AACV;AACA,EAAE,aAAc;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,IAAI,QAAQ;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,QAAQ;AACd;;AAEA;AACA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,UAAU,QAAQ;AAClB;AACA,OAAO;AACP;;AAEA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,UAAU;AACV,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,UAAU,QAAQ;AAClB;AACA;AACA,kBAAkB,aAAc;AAChC;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2CAA2C,gCAAgC;AAC3E,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,UAAU,QAAQ;AAClB;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,SAAS;AACT,OAAO;AACP;;AAEA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA,SAAS;AACT;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,QAAQ;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;;AAGH;;;;;AAKA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB;AACA;AACA;AACA,kBAAkB,wDAAwD;AAC1E;AACA,oBAAoB,QAAQ;AAC5B;AACA,sBAAsB,QAAQ;AAC9B;AACA,sBAAsB;AACtB,sBAAsB,QAAQ;AAC9B;AACA,sBAAsB;AACtB,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA,SAAS;;AAET,QAAQ,QAAQ;AAChB;AACA,MAAM;AACN,QAAQ,QAAQ;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,QAAQ;AACpB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI,QAAQ;AACZ;AACA,QAAQ,gFAAgF;AACxF;AACA;AACA,cAAc,QAAQ;AACtB,YAAY;AACZ,cAAc,QAAQ;AACtB;AACA;AACA;AACA,IAAI;AACJ,IAAI,QAAQ;AACZ;AACA,C","sources":["webpack://carboncommander/./src/local-storage.js","webpack://carboncommander/./src/global.js","webpack://carboncommander/./src/service.js"],"sourcesContent":["class CCLocalStorage {\n    static #pass = 'CarbonLocalSecurityKey';\n    \n    static async setEncrypted(key, value) {\n        let enc = '';\n        for(let i = 0; i < value.length; i++) {\n            const c = value.charCodeAt(i) ^ this.#pass.charCodeAt(i % this.#pass.length);\n            enc += c.toString(16).padStart(4, '0');\n        }\n        await chrome.storage.local.set({ [key]: enc });\n        console.log('setEncrypted', key, `[${value.substring(0, 4)}...]`);\n    }\n\n    static async getEncrypted(key) {\n        const result = await chrome.storage.local.get([key]);\n        const enc = result[key];\n        if (!enc) return null;\n        \n        let dec = '';\n        for(let i = 0; i < enc.length; i += 4) {\n            const c = parseInt(enc.slice(i, i + 4), 16);\n            dec += String.fromCharCode(c ^ this.#pass.charCodeAt((i/4) % this.#pass.length));\n        }\n        console.log('getEncrypted', key, `[${dec.substring(0, 4)}...]`);\n        return dec;\n    }\n\n    static async set(key, value) {\n        await chrome.storage.local.set({ [key]: value });\n    }\n\n    static async get(key) {\n        const result = await chrome.storage.local.get([key]);\n        return result[key] || null;\n    }\n\n    static async getAll() {\n        return await chrome.storage.local.get(null);\n    }\n\n    static async remove(key) {\n        await chrome.storage.local.remove(key);\n    }\n}\n\nexport default CCLocalStorage;","/**\n * Global logger implementation for Carbon Commander\n */\nexport const ccLogger = {\n    log: console.log.bind(console),\n    info: console.info.bind(console),\n    warn: console.warn.bind(console),\n    error: console.error.bind(console),\n    debug: console.debug.bind(console),\n    group: console.group.bind(console),\n    groupEnd: console.groupEnd.bind(console),\n    time: console.time.bind(console),\n    timeEnd: console.timeEnd.bind(console)\n};","import CCLocalStorage from './local-storage.js';\nimport { ccLogger } from './global.js';\n\nconst inIframe = window.self !== window.top;\n\nfunction injectCarbonBar(file_path, tag) {\n  // Send message to background script to get tab ID\n  chrome.runtime.sendMessage({ type: 'GET_TAB_ID' }, function(response) {\n    const currentTabId = response.tabId;\n\n    // Create extension icon click handler\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      if (message.type === 'TOGGLE_CARBONBAR') {\n        window.postMessage({ type: 'TOGGLE_CARBONBAR' }, window.location.origin);\n        sendResponse(true);\n      }\n      if (message.type === 'SHOW_KEYBIND_DIALOG') {\n        window.postMessage({ type: 'SHOW_KEYBIND_DIALOG' }, window.location.origin);\n        sendResponse(true);\n      }\n    });\n\n    ccLogger.debug('Injecting carbonbar script:', file_path, currentTabId);\n    var node = document.getElementsByTagName(tag)[0];\n    \n    // Inject the tabId script\n    const addMetaTabId = document.createElement('meta');\n    addMetaTabId.setAttribute('name', 'tabId');\n    addMetaTabId.setAttribute('content', currentTabId);\n    node.appendChild(addMetaTabId);\n    \n    // Inject the main carbonbar script\n    ccLogger.debug('Injecting carbonbar script:', file_path);\n    const script = document.createElement('script');\n    script.setAttribute('type', 'text/javascript');\n    script.setAttribute('src', file_path);\n    node.appendChild(script);\n  });\n}\n\n// make sure this only gets injected once\nif (!window.carbonBarInjected && !inIframe) {\n  ccLogger.debug('Injecting carbonbar script:', chrome.runtime.getURL('carbon-commander-dist.js'));\n  // Check for saved OpenAI key and update status\n  CCLocalStorage.getEncrypted('openai_api_key').then(key => {\n    if (key) {\n      //TODO: find a better way than timeouts\n      setTimeout(() => {\n        window.postMessage({\n            type: 'PROVIDER_STATUS_UPDATE',\n          provider: 'openai',\n          status: true\n        }, window.location.origin);\n      }, 1000);\n    }\n  });\n\n  // Load saved keybind if it exists\n  chrome.storage.local.get(['carbonbar_keybind'], (result) => {\n    if (result.carbonbar_keybind) {\n      window.postMessage({\n        type: 'SET_KEYBIND',\n        payload: result.carbonbar_keybind\n      }, window.location.origin);\n    }\n  });\n\n  injectCarbonBar(chrome.runtime.getURL('carbon-commander-dist.js'), 'body');\n  window.carbonBarInjected = true;\n\n  // Listen for messages from the injected script\n  window.addEventListener('message', async (event) => {\n    ccLogger.debug('Received message:', event);\n    // We only accept messages from ourselves\n    if (event.source !== window) {\n      return;\n    }\n\n    if (event.data.type === \"AI_REQUEST\") {\n      var response = await aiRequest(event);\n      ccLogger.debug('AI_REQUEST_RESPONSE', response);\n    }\n\n    if (event.data.type === \"AI_TOOL_RESPONSE\") {\n      toolResponseProxy(event);\n      ccLogger.debug('AI_TOOL_RESPONSE', event);\n    }\n    \n    // Add handler for confirmation dialog responses\n    if (event.data.type === \"CONFIRMATION_DIALOG_RESPONSE\") {\n      chrome.runtime.sendMessage(\n        { \n          type: 'CONFIRMATION_DIALOG_RESPONSE', \n          payload: event.data.payload,\n          tabId: event.data.tabId \n        },\n        (response) => {\n          if (chrome.runtime.lastError) {\n            ccLogger.error('Error sending confirmation response:', chrome.runtime.lastError.message);\n          }\n        }\n      );\n    }\n\n    // Add handler for input dialog responses\n    if (event.data.type === \"INPUT_DIALOG_RESPONSE\") {\n      chrome.runtime.sendMessage(\n        { \n          type: 'INPUT_DIALOG_RESPONSE', \n          payload: event.data.payload,\n          tabId: event.data.tabId \n        },\n        (response) => {\n          if (chrome.runtime.lastError) {\n            ccLogger.error('Error sending input response:', chrome.runtime.lastError.message);\n          }\n        }\n      );\n    }\n\n    if (event.data.type === \"SAVE_COMMAND_HISTORY\") {\n      chrome.storage.local.set({ \n        'carbonbar_command_history': event.data.payload \n      }, () => {\n        if (chrome.runtime.lastError) {\n          ccLogger.error('Error saving command history:', chrome.runtime.lastError);\n        }\n      });\n    }\n\n    if (event.data.type === \"GET_COMMAND_HISTORY\") {\n      ccLogger.debug('GET_COMMAND_HISTORY');\n      chrome.storage.local.get(['carbonbar_command_history'], (result) => {\n        window.postMessage({\n          type: 'COMMAND_HISTORY_LOADED',\n          payload: result.carbonbar_command_history || []\n        }, window.location.origin);\n      });\n    }\n\n    if (event.data.type === \"GET_AUTOCOMPLETE\") {\n      ccLogger.debug('GET_AUTOCOMPLETE');\n        try {\n            // Use the tabId that was already set during initialization\n            chrome.runtime.sendMessage(\n                { \n                    type: 'GET_AUTOCOMPLETE', \n                    payload: event.data.payload,\n                    tabId: window.tabId\n                },\n                (response) => {\n                    if (chrome.runtime.lastError) {\n                        ccLogger.error('Error getting autocomplete:', chrome.runtime.lastError);\n                        return;\n                    }\n                    \n                    // Forward the suggestion back to the window with the request ID\n                    window.postMessage({\n                        type: 'AUTOCOMPLETE_SUGGESTION',\n                        payload: {\n                            text: response,\n                            requestId: event.data.payload.requestId\n                        }\n                    }, window.location.origin);\n                }\n            );\n        } catch (error) {\n            ccLogger.error('Error sending autocomplete request:', error);\n        }\n    }\n\n    if (event.data.type === \"SET_OPENAI_KEY\") {\n      ccLogger.debug('SET_OPENAI_KEY', event.data.payload);\n      chrome.runtime.sendMessage(\n        { \n          type: 'SET_OPENAI_KEY', \n          payload: event.data.payload,\n          tabId: event.data.tabId \n        },\n        async (response) => {\n          ccLogger.debug('SET_OPENAI_KEY_RESPONSE and PROVIDER_STATUS_UPDATE', response.success);\n          if(response.success){\n            // Save the key to storage\n            await CCLocalStorage.setEncrypted('openai_api_key', event.data.payload.key);\n            window.postMessage({\n                type: 'PROVIDER_STATUS_UPDATE',\n                provider: 'openai',\n                status: true\n              }, window.location.origin);\n          }\n\n          window.postMessage({\n            type: 'SET_OPENAI_KEY_RESPONSE',\n            payload: response.success\n          }, window.location.origin);\n        }\n      );\n    }\n\n    if (event.data.type === \"CHECK_OLLAMA_AVAILABLE\") {\n      chrome.runtime.sendMessage(\n        { \n          type: 'CHECK_OLLAMA_AVAILABLE',\n          tabId: event.data.tabId,\n          payload: event.data.payload\n        },\n        (response) => {\n          if (response && response.available) {\n            // Add reinitialize call before success message\n            if(response.noAIMode){\n              chrome.runtime.sendMessage({ type: 'REINITIALIZE_AI_CALLER' }, (response) => {\n                ccLogger.debug('CHECK_OLLAMA_AVAILABLE', response);\n                window.postMessage({\n                  type: 'AI_RESPONSE_CHUNK',\n                  payload: {\n                    content: \"âœ… Ollama is now available! You can start using it's AI features.\",\n                    isFinished: true\n                  }\n                }, window.location.origin);\n                window.postMessage({\n                  type: 'PROVIDER_STATUS_UPDATE',\n                  provider: 'ollama',\n                  status: true\n                }, window.location.origin);\n              });\n            } else {\n              window.postMessage({\n                type: 'PROVIDER_STATUS_UPDATE',\n                provider: 'ollama',\n                status: true\n              }, window.location.origin);\n            }\n          }\n        }\n      );\n    }\n\n    if (event.data.type === \"SAVE_KEYBIND\") {\n      chrome.storage.local.set({ \n        'carbonbar_keybind': event.data.payload \n      }, () => {\n        if (chrome.runtime.lastError) {\n          ccLogger.error('Error saving keybind:', chrome.runtime.lastError);\n        }\n      });\n    }\n\n    if (event.data.type === \"GET_KEYBIND\") {\n      chrome.storage.local.get(['carbonbar_keybind'], (result) => {\n        window.postMessage({\n          type: 'SET_KEYBIND',\n          payload: result.carbonbar_keybind || { key: 'k', ctrl: true, meta: false }\n        }, window.location.origin);\n      });\n    }\n\n    if (event.data.type === \"TOGGLE_PROVIDER\") {\n      const { provider, enabled } = event.data.payload;\n      chrome.runtime.sendMessage(\n        { \n          type: 'TOGGLE_PROVIDER', \n          payload: { provider, enabled },\n          tabId: window.tabId \n        },\n        (response) => {\n          if (chrome.runtime.lastError) {\n            ccLogger.error('Error toggling provider:', chrome.runtime.lastError);\n          }\n        }\n      );\n    }\n  });\n\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n\n    if (message.type === 'FROM_BACKGROUND') {\n        const payload = message.payload;\n\n        // Forward the message to the window\n        window.postMessage({\n            type: payload.error ? 'AI_RESPONSE_ERROR' : 'AI_RESPONSE_CHUNK',\n            payload: payload\n        }, window.location.origin);\n        ccLogger.debug('FROM_BACKGROUND', payload);\n        sendResponse(true);\n        return false;\n    }\n\n    // Add handling for AI_EXECUTE_TOOL messages\n    if (message.type === 'AI_EXECUTE_TOOL') {\n      const messageId = JSON.stringify(message) + Date.now();\n      ccLogger.debug('Received AI_EXECUTE_TOOL in content script2:', message, messageId);\n      // Forward the tool execution request to the window\n      window.postMessage({\n          type: 'AI_EXECUTE_TOOL',\n          tool: message.payload.tool\n      }, window.location.origin);\n      sendResponse(true);\n      return false;\n    }\n  });\n\n\n}\n\n\n\n\nconst aiRequest = async (event) => {\n    try {\n        const tabId = event.data.tabId || (await getCurrentTabId());\n        ccLogger.debug('AI_REQUEST', event.data.payload, tabId);\n        \n        const response = await new Promise((resolve, reject) => {\n            chrome.runtime.sendMessage(\n                { type: 'AI_REQUEST', payload: event.data.payload, tabId },\n                (response) => {\n                    ccLogger.debug('AI_REQUEST_RESPONSE', response);\n                    if (chrome.runtime.lastError) {\n                      ccLogger.error('[aiRequest] AI_REQUEST_RESPONSE1', response);\n                        reject(new Error(chrome.runtime.lastError.message));\n                    } else if (response && response.error) {\n                      ccLogger.error('[aiRequest] AI_REQUEST_RESPONSE2', response);\n                        reject(new Error(response.error));\n                    } else {\n                      ccLogger.debug('[aiRequest] AI_REQUEST_RESPONSE3', response);\n                        resolve(response);\n                    }\n                }\n            );\n        });\n\n        ccLogger.debug('AI request completed:', response);\n        return response;\n    } catch (error) {\n        ccLogger.error('AI_RESPONSE_ERROR2:', error);\n        return error;\n    }\n}\n\n// Replace the getCurrentTabId function with a simpler version that uses the meta tag\nfunction getCurrentTabId() {\n    return new Promise((resolve) => {\n        const tabIdMeta = document.querySelector('meta[name=\"tabId\"]');\n        if (tabIdMeta) {\n            resolve(tabIdMeta.getAttribute('content'));\n        } else {\n            ccLogger.error('TabId meta tag not found');\n            resolve(null);\n        }\n    });\n}\n\nconst toolResponseProxy = async (event) => {\n  try {\n    ccLogger.debug('Received AI_TOOL_RESPONSE in service.js', event);\n    chrome.runtime.sendMessage(\n      { type: 'AI_TOOL_RESPONSE', payload: event.data.payload, tabId: event.data.tabId },\n      (response) => {\n          if (chrome.runtime.lastError) {\n              ccLogger.error('Error communicating with extension:', chrome.runtime.lastError.message);\n          } else {\n              ccLogger.debug('AI_TOOL_RESPONSE_RESULT', response);\n          }\n      }\n    );\n  } catch (error) {\n    ccLogger.error('Error communicating with extension:', error);\n  }\n}"],"names":[],"sourceRoot":""}