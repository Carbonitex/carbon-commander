{"version":3,"file":"service-dist.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,yCAAyC,YAAY;AACrD,6CAA6C,sBAAsB;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,6CAA6C,oBAAoB;AACjE;AACA;;AAEA;AACA,yCAAyC,cAAc;AACvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oDAAe,cAAc;;AC7C7B;AACA;AACA,aAAa,0DAA0D;AACvE,YAAY,yDAAyD;AACrE,YAAY,yDAAyD;AACrE,aAAa,0DAA0D;AACvE,aAAa,8DAA8D,cAAc,kBAAkB;AAC3G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,OAAO,qBAAqB,WAAW,IAAI,QAAQ;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,oBAAoB,EAAE,mBAAmB;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,MAAM;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO,GAAG,oBAAoB;AACnE;AACA;AACA,sCAAsC,MAAM;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;;ACnMgD;AACT;;AAEvC;;AAEA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA,IAAI,QAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,QAAQ;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,EAAE,QAAQ;AACV;AACA,EAAE,aAAc;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,IAAI,QAAQ;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,QAAQ;AACd;;AAEA;AACA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,UAAU,QAAQ;AAClB;AACA,OAAO;AACP;;AAEA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,UAAU;AACV,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,UAAU,QAAQ;AAClB;AACA;AACA,kBAAkB,aAAc;AAChC;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2CAA2C,gCAAgC;AAC3E,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,QAAQ;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,QAAQ;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;;AAGH;;;;;AAKA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB;AACA;AACA;AACA,kBAAkB,wDAAwD;AAC1E;AACA,oBAAoB,QAAQ;AAC5B;AACA,sBAAsB,QAAQ;AAC9B;AACA,sBAAsB;AACtB,sBAAsB,QAAQ;AAC9B;AACA,sBAAsB;AACtB,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA,SAAS;;AAET,QAAQ,QAAQ;AAChB;AACA,MAAM;AACN,QAAQ,QAAQ;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,QAAQ;AACpB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI,QAAQ;AACZ;AACA,QAAQ,gFAAgF;AACxF;AACA;AACA,cAAc,QAAQ;AACtB,YAAY;AACZ,cAAc,QAAQ;AACtB;AACA;AACA;AACA,IAAI;AACJ,IAAI,QAAQ;AACZ;AACA,C","sources":["webpack://carboncommander/./src/local-storage.js","webpack://carboncommander/./src/global.js","webpack://carboncommander/./src/service.js"],"sourcesContent":["class CCLocalStorage {\n    static #pass = 'CarbonLocalSecurityKey';\n    \n    static async setEncrypted(key, value) {\n        let enc = '';\n        for(let i = 0; i < value.length; i++) {\n            const c = value.charCodeAt(i) ^ this.#pass.charCodeAt(i % this.#pass.length);\n            enc += c.toString(16).padStart(4, '0');\n        }\n        await chrome.storage.local.set({ [key]: enc });\n        console.log('setEncrypted', key, `[${value.substring(0, 4)}...]`);\n    }\n\n    static async getEncrypted(key) {\n        const result = await chrome.storage.local.get([key]);\n        const enc = result[key];\n        if (!enc) return null;\n        \n        let dec = '';\n        for(let i = 0; i < enc.length; i += 4) {\n            const c = parseInt(enc.slice(i, i + 4), 16);\n            dec += String.fromCharCode(c ^ this.#pass.charCodeAt((i/4) % this.#pass.length));\n        }\n        console.log('getEncrypted', key, `[${dec.substring(0, 4)}...]`);\n        return dec;\n    }\n\n    static async set(key, value) {\n        await chrome.storage.local.set({ [key]: value });\n    }\n\n    static async get(key) {\n        const result = await chrome.storage.local.get([key]);\n        return result[key] || null;\n    }\n\n    static async getAll() {\n        return await chrome.storage.local.get(null);\n    }\n\n    static async remove(key) {\n        await chrome.storage.local.remove(key);\n    }\n}\n\nexport default CCLocalStorage;","// Log levels enum\nconst LogLevel = {\n    DEBUG: { name: 'DEBUG', color: '#7f8c8d', style: 'color: #7f8c8d' },\n    INFO: { name: 'INFO', color: '#3498db', style: 'color: #3498db' },\n    WARN: { name: 'WARN', color: '#f39c12', style: 'color: #f39c12' },\n    ERROR: { name: 'ERROR', color: '#e74c3c', style: 'color: #e74c3c' },\n    FATAL: { name: 'FATAL', color: '#c0392b', style: 'background: #c0392b; color: white; padding: 2px 4px; border-radius: 2px' }\n};\n\nclass CCLogger {\n    static #instance;\n    #logLevel = LogLevel.FATAL;\n    #logHistory = [];\n    #maxHistorySize = 1000;\n    #groupLevel = 0;\n    #timers = new Map();\n    #filters = new Set();\n\n    constructor() {\n        if (CCLogger.#instance) {\n            return CCLogger.#instance;\n        }\n        CCLogger.#instance = this;\n    }\n\n    static getInstance() {\n        if (!CCLogger.#instance) {\n            CCLogger.#instance = new CCLogger();\n        }\n        return CCLogger.#instance;\n    }\n\n    disable() {\n        this.#logLevel = LogLevel.FATAL;\n    }\n\n    enable() {\n        this.#logLevel = LogLevel.DEBUG;\n    }\n\n    setLogLevel(level) {\n        if (LogLevel[level]) {\n            this.#logLevel = LogLevel[level];\n        }\n    }\n\n    addFilter(pattern) {\n        this.#filters.add(pattern);\n    }\n\n    removeFilter(pattern) {\n        this.#filters.delete(pattern);\n    }\n\n    clearFilters() {\n        this.#filters.clear();\n    }\n\n    #shouldLog(message) {\n        if (this.#filters.size === 0) return true;\n        return Array.from(this.#filters).some(pattern => \n            message.toLowerCase().includes(pattern.toLowerCase())\n        );\n    }\n\n    #formatMessage(level, args) {\n        const timestamp = new Date().toISOString();\n        const prefix = 'â”‚'.repeat(this.#groupLevel);\n        const message = args.map(arg => \n            typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)\n        ).join(' ');\n\n        return {\n            formatted: `${prefix}[Carbon Commander][${level.name}] ${message}`,\n            timestamp,\n            level,\n            raw: message\n        };\n    }\n\n    #addToHistory(logEntry) {\n        this.#logHistory.push(logEntry);\n        if (this.#logHistory.length > this.#maxHistorySize) {\n            this.#logHistory.shift();\n        }\n    }\n\n    #log(level, ...args) {\n        if (!this.#shouldLog(args.join(' '))) return;\n\n        const logEntry = this.#formatMessage(level, args);\n        this.#addToHistory(logEntry);\n\n        const consoleArgs = [\n            `%c${logEntry.timestamp} ${logEntry.formatted}`,\n            level.style\n        ];\n\n        switch (level) {\n            case LogLevel.DEBUG:\n                console.debug(...consoleArgs);\n                break;\n            case LogLevel.INFO:\n                console.info(...consoleArgs);\n                break;\n            case LogLevel.WARN:\n                console.warn(...consoleArgs);\n                break;\n            case LogLevel.ERROR:\n            case LogLevel.FATAL:\n                console.error(...consoleArgs);\n                if (args[0] instanceof Error) {\n                    console.error(args[0].stack);\n                }\n                break;\n        }\n    }\n\n    debug(...args) {\n        this.#log(LogLevel.DEBUG, ...args);\n    }\n\n    info(...args) {\n        this.#log(LogLevel.INFO, ...args);\n    }\n\n    warn(...args) {\n        this.#log(LogLevel.WARN, ...args);\n    }\n\n    error(...args) {\n        this.#log(LogLevel.ERROR, ...args);\n    }\n\n    fatal(...args) {\n        this.#log(LogLevel.FATAL, ...args);\n    }\n\n    group(label) {\n        if (this.#logLevel === LogLevel.DEBUG) {\n            console.group(label);\n        }\n        this.#groupLevel++;\n        this.debug(`Group Start: ${label}`);\n    }\n\n    groupEnd() {\n        this.#groupLevel = Math.max(0, this.#groupLevel - 1);\n        if (this.#logLevel === LogLevel.DEBUG) {\n            console.groupEnd();\n        }\n        this.debug('Group End');\n    }\n\n    time(label) {\n        this.#timers.set(label, performance.now());\n        this.debug(`Timer Start: ${label}`);\n    }\n\n    timeEnd(label) {\n        const startTime = this.#timers.get(label);\n        if (startTime) {\n            const duration = performance.now() - startTime;\n            this.#timers.delete(label);\n            this.debug(`Timer End: ${label} (${duration.toFixed(2)}ms)`);\n            return duration;\n        }\n        this.warn(`Timer not found: ${label}`);\n        return null;\n    }\n\n    getLogHistory() {\n        return [...this.#logHistory];\n    }\n\n    clearHistory() {\n        this.#logHistory = [];\n    }\n\n    exportLogs() {\n        return {\n            logs: this.#logHistory,\n            timestamp: new Date().toISOString(),\n            filters: Array.from(this.#filters),\n            logLevel: this.#logLevel.name\n        };\n    }\n}\n\n// Create a singleton instance\nconst ccLogger = CCLogger.getInstance();\n\n\nif(typeof window !== 'undefined') {\n    window.ccLogger= ccLogger;\n}\n\nexport { ccLogger };","import CCLocalStorage from './local-storage.js';\nimport { ccLogger } from './global.js';\n\nconst inIframe = window.self !== window.top;\n\nfunction injectCarbonBar(file_path, tag) {\n  // Send message to background script to get tab ID\n  chrome.runtime.sendMessage({ type: 'GET_TAB_ID' }, function(response) {\n    const currentTabId = response.tabId;\n    ccLogger.debug('Injecting carbonbar script:', file_path, currentTabId);\n    var node = document.getElementsByTagName(tag)[0];\n    \n    // Inject the tabId script\n    const addMetaTabId = document.createElement('meta');\n    addMetaTabId.setAttribute('name', 'tabId');\n    addMetaTabId.setAttribute('content', currentTabId);\n    node.appendChild(addMetaTabId);\n    \n    // Inject the main carbonbar script\n    ccLogger.debug('Injecting carbonbar script:', file_path);\n    const script = document.createElement('script');\n    script.setAttribute('type', 'text/javascript');\n    script.setAttribute('src', file_path);\n    node.appendChild(script);\n  });\n}\n\n// make sure this only gets injected once\nif (!window.carbonBarInjected && !inIframe) {\n  ccLogger.debug('Injecting carbonbar script:', chrome.runtime.getURL('carbon-commander-dist.js'));\n  // Check for saved OpenAI key and update status\n  CCLocalStorage.getEncrypted('openai_api_key').then(key => {\n    if (key) {\n      //TODO: find a better way than timeouts\n      setTimeout(() => {\n        window.postMessage({\n            type: 'PROVIDER_STATUS_UPDATE',\n          provider: 'openai',\n          status: true\n        }, window.location.origin);\n      }, 1000);\n    }\n  });\n\n  injectCarbonBar(chrome.runtime.getURL('carbon-commander-dist.js'), 'body');\n  window.carbonBarInjected = true;\n\n  // Listen for messages from the injected script\n  window.addEventListener('message', async (event) => {\n    ccLogger.debug('Received message:', event);\n    // We only accept messages from ourselves\n    if (event.source !== window) {\n      return;\n    }\n\n    if (event.data.type === \"AI_REQUEST\") {\n      var response = await aiRequest(event);\n      ccLogger.debug('AI_REQUEST_RESPONSE', response);\n    }\n\n    if (event.data.type === \"AI_TOOL_RESPONSE\") {\n      toolResponseProxy(event);\n      ccLogger.debug('AI_TOOL_RESPONSE', event);\n    }\n    \n    // Add handler for confirmation dialog responses\n    if (event.data.type === \"CONFIRMATION_DIALOG_RESPONSE\") {\n      chrome.runtime.sendMessage(\n        { \n          type: 'CONFIRMATION_DIALOG_RESPONSE', \n          payload: event.data.payload,\n          tabId: event.data.tabId \n        },\n        (response) => {\n          if (chrome.runtime.lastError) {\n            ccLogger.error('Error sending confirmation response:', chrome.runtime.lastError.message);\n          }\n        }\n      );\n    }\n\n    // Add handler for input dialog responses\n    if (event.data.type === \"INPUT_DIALOG_RESPONSE\") {\n      chrome.runtime.sendMessage(\n        { \n          type: 'INPUT_DIALOG_RESPONSE', \n          payload: event.data.payload,\n          tabId: event.data.tabId \n        },\n        (response) => {\n          if (chrome.runtime.lastError) {\n            ccLogger.error('Error sending input response:', chrome.runtime.lastError.message);\n          }\n        }\n      );\n    }\n\n    if (event.data.type === \"SAVE_COMMAND_HISTORY\") {\n      chrome.storage.local.set({ \n        'carbonbar_command_history': event.data.payload \n      }, () => {\n        if (chrome.runtime.lastError) {\n          ccLogger.error('Error saving command history:', chrome.runtime.lastError);\n        }\n      });\n    }\n\n    if (event.data.type === \"GET_COMMAND_HISTORY\") {\n      ccLogger.debug('GET_COMMAND_HISTORY');\n      chrome.storage.local.get(['carbonbar_command_history'], (result) => {\n        window.postMessage({\n          type: 'COMMAND_HISTORY_LOADED',\n          payload: result.carbonbar_command_history || []\n        }, window.location.origin);\n      });\n    }\n\n    if (event.data.type === \"GET_AUTOCOMPLETE\") {\n      ccLogger.debug('GET_AUTOCOMPLETE');\n        try {\n            // Use the tabId that was already set during initialization\n            chrome.runtime.sendMessage(\n                { \n                    type: 'GET_AUTOCOMPLETE', \n                    payload: event.data.payload,\n                    tabId: window.tabId\n                },\n                (response) => {\n                    if (chrome.runtime.lastError) {\n                        ccLogger.error('Error getting autocomplete:', chrome.runtime.lastError);\n                        return;\n                    }\n                    \n                    // Forward the suggestion back to the window with the request ID\n                    window.postMessage({\n                        type: 'AUTOCOMPLETE_SUGGESTION',\n                        payload: {\n                            text: response,\n                            requestId: event.data.payload.requestId\n                        }\n                    }, window.location.origin);\n                }\n            );\n        } catch (error) {\n            ccLogger.error('Error sending autocomplete request:', error);\n        }\n    }\n\n    if (event.data.type === \"SET_OPENAI_KEY\") {\n      ccLogger.debug('SET_OPENAI_KEY', event.data.payload);\n      chrome.runtime.sendMessage(\n        { \n          type: 'SET_OPENAI_KEY', \n          payload: event.data.payload,\n          tabId: event.data.tabId \n        },\n        async (response) => {\n          ccLogger.debug('SET_OPENAI_KEY_RESPONSE and PROVIDER_STATUS_UPDATE', response.success);\n          if(response.success){\n            // Save the key to storage\n            await CCLocalStorage.setEncrypted('openai_api_key', event.data.payload.key);\n            window.postMessage({\n                type: 'PROVIDER_STATUS_UPDATE',\n                provider: 'openai',\n                status: true\n              }, window.location.origin);\n          }\n\n          window.postMessage({\n            type: 'SET_OPENAI_KEY_RESPONSE',\n            payload: response.success\n          }, window.location.origin);\n        }\n      );\n    }\n\n    if (event.data.type === \"CHECK_OLLAMA_AVAILABLE\") {\n      chrome.runtime.sendMessage(\n        { \n          type: 'CHECK_OLLAMA_AVAILABLE',\n          tabId: event.data.tabId,\n          payload: event.data.payload\n        },\n        (response) => {\n          if (response && response.available) {\n            // Add reinitialize call before success message\n            if(response.noAIMode){\n              chrome.runtime.sendMessage({ type: 'REINITIALIZE_AI_CALLER' }, (response) => {\n                ccLogger.debug('CHECK_OLLAMA_AVAILABLE', response);\n                window.postMessage({\n                  type: 'AI_RESPONSE_CHUNK',\n                  payload: {\n                    content: \"âœ… Ollama is now available! You can start using it's AI features.\",\n                    isFinished: true\n                  }\n                }, window.location.origin);\n                window.postMessage({\n                  type: 'PROVIDER_STATUS_UPDATE',\n                  provider: 'ollama',\n                  status: true\n                }, window.location.origin);\n              });\n            } else {\n              window.postMessage({\n                type: 'PROVIDER_STATUS_UPDATE',\n                provider: 'ollama',\n                status: true\n              }, window.location.origin);\n            }\n          }\n        }\n      );\n    }\n  });\n\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n\n    if (message.type === 'FROM_BACKGROUND') {\n        const payload = message.payload;\n\n        // Forward the message to the window\n        window.postMessage({\n            type: payload.error ? 'AI_RESPONSE_ERROR' : 'AI_RESPONSE_CHUNK',\n            payload: payload\n        }, window.location.origin);\n        ccLogger.debug('FROM_BACKGROUND', payload);\n        sendResponse(true);\n        return false;\n    }\n\n    // Add handling for AI_EXECUTE_TOOL messages\n    if (message.type === 'AI_EXECUTE_TOOL') {\n      const messageId = JSON.stringify(message) + Date.now();\n      ccLogger.debug('Received AI_EXECUTE_TOOL in content script2:', message, messageId);\n      // Forward the tool execution request to the window\n      window.postMessage({\n          type: 'AI_EXECUTE_TOOL',\n          tool: message.payload.tool\n      }, window.location.origin);\n      sendResponse(true);\n      return false;\n    }\n  });\n\n\n}\n\n\n\n\nconst aiRequest = async (event) => {\n    try {\n        const tabId = event.data.tabId || (await getCurrentTabId());\n        ccLogger.debug('AI_REQUEST', event.data.payload, tabId);\n        \n        const response = await new Promise((resolve, reject) => {\n            chrome.runtime.sendMessage(\n                { type: 'AI_REQUEST', payload: event.data.payload, tabId },\n                (response) => {\n                    ccLogger.debug('AI_REQUEST_RESPONSE', response);\n                    if (chrome.runtime.lastError) {\n                      ccLogger.error('[aiRequest] AI_REQUEST_RESPONSE1', response);\n                        reject(new Error(chrome.runtime.lastError.message));\n                    } else if (response && response.error) {\n                      ccLogger.error('[aiRequest] AI_REQUEST_RESPONSE2', response);\n                        reject(new Error(response.error));\n                    } else {\n                      ccLogger.debug('[aiRequest] AI_REQUEST_RESPONSE3', response);\n                        resolve(response);\n                    }\n                }\n            );\n        });\n\n        ccLogger.debug('AI request completed:', response);\n        return response;\n    } catch (error) {\n        ccLogger.error('AI_RESPONSE_ERROR2:', error);\n        return error;\n    }\n}\n\n// Replace the getCurrentTabId function with a simpler version that uses the meta tag\nfunction getCurrentTabId() {\n    return new Promise((resolve) => {\n        const tabIdMeta = document.querySelector('meta[name=\"tabId\"]');\n        if (tabIdMeta) {\n            resolve(tabIdMeta.getAttribute('content'));\n        } else {\n            ccLogger.error('TabId meta tag not found');\n            resolve(null);\n        }\n    });\n}\n\nconst toolResponseProxy = async (event) => {\n  try {\n    ccLogger.debug('Received AI_TOOL_RESPONSE in service.js', event);\n    chrome.runtime.sendMessage(\n      { type: 'AI_TOOL_RESPONSE', payload: event.data.payload, tabId: event.data.tabId },\n      (response) => {\n          if (chrome.runtime.lastError) {\n              ccLogger.error('Error communicating with extension:', chrome.runtime.lastError.message);\n          } else {\n              ccLogger.debug('AI_TOOL_RESPONSE_RESULT', response);\n          }\n      }\n    );\n  } catch (error) {\n    ccLogger.error('Error communicating with extension:', error);\n  }\n}"],"names":[],"sourceRoot":""}